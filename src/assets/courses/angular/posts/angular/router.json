[
  {
    "id": 3661,
    "date": "2020-12-07T10:46:01",
    "date_gmt": "2020-12-07T10:46:01",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3661" },
    "modified": "2020-12-09T06:51:11",
    "modified_gmt": "2020-12-09T06:51:11",
    "slug": "angular-routing-tutorial-with-example",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-routing-tutorial-with-example/",
    "title": { "rendered": "Angular Routing Tutorial with Example" },
    "content": {
      "rendered": "\n<h2>What is Routing</h2>\n\n\n\n<p>Routing allows you to move from one part of the application to another part or one View to another View.</p>\n\n\n\n<h2>The Angular Router Module</h2>\n\n\n\n<p>The Router is a separate module in Angular. It is in its own library package,&nbsp;<em>@angular/router</em>. The Router Module provides the necessary service providers and directives for navigating through application views.</p>\n\n\n\n<p>Using Angular Router you can</p>\n\n\n\n<ul><li>Navigate to a specific view by typing a URL in the address bar</li><li>Pass optional parameters to the View</li><li>Bind the clickable elements to the View and load the view when the user performs application tasks</li><li>Handles back and forward buttons of the browser</li><li>Allows you to dynamically load the view</li><li>Protect the routes from unauthorized users using Guards</li></ul>\n\n\n\n<h2>Components of Angular Router Module</h2>\n\n\n\n<h3>Router</h3>\n\n\n\n<p>The Angular Router is an object that enables navigation from one component to the next component as users perform application tasks like clicking on menus links, buttons or clicking on back/forward button on the browser. We can access the router object and use its methods like&nbsp;<code>navigate()</code>&nbsp;or&nbsp;<code>navigateByUrl()</code>, to navigate to a route</p>\n\n\n\n<h3>Route</h3>\n\n\n\n<p><code>Route</code>&nbsp;tells the Angular Router which view to display when a user clicks a link or pastes a URL into the browser address bar. Every&nbsp;<code>Route</code>&nbsp;consists of a&nbsp;<code>path</code>&nbsp;and a component it is mapped to. The&nbsp;<code>Router</code>&nbsp;object parses and builds the final URL using the&nbsp;<code>Route</code></p>\n\n\n\n<h3>Routes</h3>\n\n\n\n<p><code>Routes</code>&nbsp;is an array of&nbsp;<code>Route</code>&nbsp;objects our application supports</p>\n\n\n\n<h3>RouterOutlet</h3>\n\n\n\n<p>The&nbsp;<code>outerOutlet</code>&nbsp;is a directive (&lt;router-outlet&gt;) that serves as a placeholder, where the&nbsp;<code>Router</code>&nbsp;should display the view</p>\n\n\n\n<h3>RouterLink</h3>\n\n\n\n<p>The&nbsp;<code>RouterLink</code>&nbsp;is a directive that binds the HTML element to a&nbsp;<code>Route</code>. Clicking on the HTML element, which is bound to a&nbsp;<code>RouterLink</code>, will result in navigation to the&nbsp;<code>Route</code>. The&nbsp;<code>RouterLink</code>&nbsp;may contain parameters to be passed to the route’s component.</p>\n\n\n\n<h3>RouterLinkActive</h3>\n\n\n\n<p><code>RouterLinkActive</code>&nbsp;is a directive for adding or removing classes from an HTML element that is bound to a&nbsp;<code>RouterLink</code>. Using this directive, we can toggle CSS classes for active&nbsp;<code>RouterLinks</code>&nbsp;based on the current&nbsp;<code>RouterState</code></p>\n\n\n\n<h3>ActivatedRoute</h3>\n\n\n\n<p>The&nbsp;<code>ActivatedRoute</code>&nbsp;is an object that represents the currently activated&nbsp;<code>route</code>&nbsp;associated with the loaded Component.</p>\n\n\n\n<h3>RouterState</h3>\n\n\n\n<p>The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.</p>\n\n\n\n<h3>RouteLink Parameters array</h3>\n\n\n\n<p>The Parameters or arguments to the&nbsp;<code>Route</code>. It is an array which you can bind to&nbsp;<code>RouterLink</code>&nbsp;directive or pass it as an argument to the&nbsp;<code>Router.navigate</code>&nbsp;method.</p>\n\n\n\n<h2>How to configure Angular Router</h2>\n\n\n\n<p>To Configure the Router in Angular, you need to follow these steps</p>\n\n\n\n<ul><li>Set the &lt;base href&gt;</li><li>Define routes for the view</li><li>Register the Router Service with Routes</li><li>Map HTML Element actions to Route</li><li>Choose where you want to display the view</li></ul>\n\n\n\n<h3>Set the &lt;base href&gt;</h3>\n\n\n\n<p>The HTML &lt;base&gt; element specifies the base URL to use for all relative URLs contained within a document.</p>\n\n\n\n<p>The Angular Router uses the HTML5 style of Routing (or PathLocationStrategy) as the default option. The router makes use of the browser’s history API for navigation and URL interaction.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;base href=\"/\"> </code></pre>\n\n\n\n<p>To make HTML5 routing to work, we need to set up the “<strong>base href”</strong>&nbsp;in the DOM. This is done in app’s&nbsp;<em>index.html</em>&nbsp;file immediately after the head tag.</p>\n\n\n\n<h3>Define the routes</h3>\n\n\n\n<p>Next, create an array of route objects. Each route maps path (URL Segment) to the component</p>\n\n\n\n<pre class=\"wp-block-code\"><code> const appRoutes={ path: 'product', component: ProductComponent } </code></pre>\n\n\n\n<p>Where</p>\n\n\n\n<p><strong>path:</strong>&nbsp;The URL path segment of the route. We will use this value to refer to this route elsewhere in the app</p>\n\n\n\n<p><strong>component:</strong>&nbsp;The component to be loaded.</p>\n\n\n\n<p>This route tells angular to render ProductComponent when the user navigate to the URL “/product”</p>\n\n\n\n<h3>Register the Routes</h3>\n\n\n\n<p>Import the Router Module from @angular/router library in the root module of the application</p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { RouterModule } from '@angular/router'; </code></pre>\n\n\n\n<p>Then, install the routes using the RouterModule.forRoot method, passing the routes as the argument in the imports array</p>\n\n\n\n<pre class=\"wp-block-code\"><code> imports: &#91;RouterModule.forRoot(routes)], </code></pre>\n\n\n\n<h4>Map Action to Routes</h4>\n\n\n\n<p>Next, we need to bind the click event of the link, image or button to a route. This is done using the routerlink directive</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li> </code></pre>\n\n\n\n<p>The&nbsp;routerLink&nbsp;directive accepts an array of route names along with parameters. This array is called as&nbsp;<strong>Link Parameters array</strong>.</p>\n\n\n\n<p>When the application requests navigation to the route “product”, the router looks in&nbsp;the routes array and activates the instance of the component associated with the route “product”, which is ProductComponent. The browser address location &amp; history is also updated to /product</p>\n\n\n\n<h4>Choose where you want to display</h4>\n\n\n\n<p>Finally, we need to tell the angular where to display the view. This is done using the&nbsp;RouterOutlet&nbsp;directive as shown. We will add the following directive to the root component.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;router-outlet>&lt;/router-outlet> </code></pre>\n\n\n\n<h2>Angular Router: Sample Application</h2>\n\n\n\n<p>Let’s build a sample application with four components and build a navigation system to route for each one of them</p>\n\n\n\n<p><strong>HomeComponent:</strong>&nbsp;This component will display the Welcome message. This is also our default component.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n} import {Component} from '@angular/core'; @Component({    template: `&lt;h1>Welcome!&lt;/h1>              &lt;p>This is Home Component &lt;/p>             `}) export class HomeComponent {} </code></pre>\n\n\n\n<p><strong>ContactComponent:</strong>&nbsp;Displays the contact message.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}</code></pre>\n\n\n\n<p><strong>ProductComponent:</strong>&nbsp;Displays the list of products. The Products are retrieved from the Angular 2 Service using Dependency injection.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component, OnInit } from '@angular/core';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\n \r\n@Component({\r\n  templateUrl: './product.component.html',\r\n})\r\n \r\nexport class ProductComponent\r\n{\r\n \r\n   products:Product&#91;];\r\n   \r\n   constructor(private productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n     this.products=this.productService.getProducts();\r\n   }\r\n  \r\n}\r\n </code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n&lt;h1>Product List&lt;/h1>\r\n&lt;div class='table-responsive'>\r\n    &lt;table class='table'>\r\n        &lt;thead>\r\n            &lt;tr>\r\n                &lt;th>ID&lt;/th>\r\n                &lt;th>Name&lt;/th>\r\n                &lt;th>Price&lt;/th>\r\n            &lt;/tr>\r\n        &lt;/thead>\r\n        &lt;tbody>\r\n            &lt;tr *ngFor=\"let product of products;\">\r\n                &lt;td>{{product.productID}}&lt;/td>\r\n                &lt;td>&lt;a &#91;routerLink]=\"&#91;'detail',product.productID]\">{{product.name}} &lt;/a> &lt;/td>\r\n                &lt;td>{{product.price}}&lt;/td>\r\n            &lt;/tr>\r\n        &lt;/tbody>\r\n    &lt;/table>\r\n&lt;/div>\r\n \r\n&lt;router-outlet>&lt;/router-outlet></code></pre>\n\n\n\n<p><strong>ErrorComponent:</strong>&nbsp;The&nbsp;ErrorComponent&nbsp;is displayed, when the user navigates to a nonexistent path. This is basically a 404 error page.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Page not found&lt;/h1>\r\n               &lt;p>This is a Error Page&lt;/p>\r\n              `\r\n})\r\n \r\nexport class ErrorComponent {\r\n}\r\n  </code></pre>\n\n\n\n<p><strong>Product Service</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Observable } from 'rxjs/Observable';\r\nimport {Product} from './Product'\r\n \r\n \r\nexport class ProductService{\r\n \r\n    public getProducts() {\r\n \r\n        let products:Product&#91;];\r\n \r\n        products=&#91;\r\n            new Product(1,'Memory Card',500),\r\n            new Product(2,'Pen Drive',750),\r\n            new Product(3,'Power Bank',100)\r\n        ]\r\n \r\n        return products;               \r\n    }\r\n \r\n \r\n    public getProduct(id) {\r\n        let products:Product&#91;]=this.getProducts();\r\n        return products.find(p => p.productID==id);\r\n    }\r\n \r\n \r\n}</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nexport class Product { \r\n \r\n    constructor(productID:number,    name: string ,   price:number) {\r\n        this.productID=productID;\r\n        this.name=name;\r\n        this.price=price;\r\n    }\r\n \r\n    productID:number ;\r\n    name: string ;\r\n    price:number;\r\n \r\n}</code></pre>\n\n\n\n<h4>Index.html</h4>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\n&lt;!doctype html>\r\n&lt;html>\r\n&lt;head>\r\n  &lt;base href=\"/\">\r\n  &lt;meta charset=\"utf-8\">\r\n  &lt;title>Angular 2 Routing&lt;/title>\r\n \r\n \r\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\r\n  &lt;link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\r\n    ...\r\n&lt;/head>\r\n&lt;body>\r\n  &lt;app-root>Loading...&lt;/app-root>\r\n&lt;/body>\r\n&lt;/html></code></pre>\n\n\n\n<p>Note the&nbsp;<strong>&lt;base href=”/”&gt;</strong>&nbsp;right after the head tag. This makes the browser know where is the root of our application is and helps it to construct the URL’s</p>\n\n\n\n<h3>Routes</h3>\n\n\n\n<p>Now, we have our components ready. The next step is to create our routes.</p>\n\n\n\n<p>It is good practice to create all our route configuration in a separate file. So create&nbsp;<strong>app.routes.ts</strong>&nbsp;under the app folder.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\nimport { ErrorComponent} from './error.component'\r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n  { path: '**', component: ErrorComponent }\r\n];</code></pre>\n\n\n\n<p>First, we import Routes from router module</p>\n\n\n\n<p>Next, we need to import all the components, that requires routing We have imported Home, Contact, Product, and Error Components</p>\n\n\n\n<p>Finally, we have defined a constant (appRoutes) that contains the&nbsp;<strong>Routes</strong>&nbsp;that we wish to create. The&nbsp;<strong>Routes</strong>&nbsp;is an array of&nbsp;<strong>route configuration object</strong>&nbsp;(or route object).</p>\n\n\n\n<p>Each route has several configurable properties.</p>\n\n\n\n<p>Our First route is</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'home', component: HomeComponent }, </code></pre>\n\n\n\n<p>The first parameter is the path, which represents the URL path segment. The second parameter is the component to display. The above route configuration means, when you navigate to /home (URL path segment), then the HomeComponent gets displayed.</p>\n\n\n\n<p><em>Note that path does not contain the leading slash</em></p>\n\n\n\n<p>The next two routes are similar to the home route</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'contact', component: ContactComponent },\n{ path: 'product', component: ProductComponent }, </code></pre>\n\n\n\n<h4>Default Route</h4>\n\n\n\n<p>The fourth route is</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: '', redirectTo: 'home', pathMatch: 'full' }, </code></pre>\n\n\n\n<p>The path is empty, indicates the default route. The default route is redirected to the home path using the RedirectTo argument. This route means that, when you navigate to the root of your application /, you are redirected to the home path (/home), which in turn displays the&nbsp;HomeComponent.</p>\n\n\n\n<p>Note, that we have&nbsp;pathMatch&nbsp;argument set to ‘full’. The pathMatch tells the Router how to match the URL.</p>\n\n\n\n<p>When it is set to full, the path is matched to the entire URL</p>\n\n\n\n<p>Every route ends in an empty space for ex: /contact/’’. If pathMatch is not set to full then the router will apply the redirect, which results in the error.</p>\n\n\n\n<h4>Wild Card Route</h4>\n\n\n\n<p>The next route is wildcard route</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: '**', component: ErrorComponent } </code></pre>\n\n\n\n<p>The “**” matches every URL. The Router will display the ErrorComponent.</p>\n\n\n\n<h4>Order matters: First one wins</h4>\n\n\n\n<p>Note that the order of the route is important. The Routes are matched in the order they are defined. The Router always returns the first matching route (first-match-wins strategy)</p>\n\n\n\n<p>Since the wildcard route (**) matches every URL and should be placed last.</p>\n\n\n\n<p>Now, we have set up our routes. Now we will add these routes to our application.</p>\n\n\n\n<h3>Register the Routes</h3>\n\n\n\n<p>Routes are registered in root module of the application. I.e. app.module.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { HttpModule } from '@angular/http';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\nimport { ErrorComponent} from './error.component'\r\n \r\nimport { ProductService } from './product.service';\r\n \r\nimport { appRoutes } from './app.routes';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,ProductComponent,ErrorComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)                           /*path location strategy */\r\n    /*RouterModule.forRoot(appRoutes, { useHash: true }) */   /*Hashlocationstrategy */\r\n  ],\r\n  providers: &#91;ProductService],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<p>First, we import the RouterModule</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { RouterModule } from '@angular/router'; </code></pre>\n\n\n\n<p>Next, import all the components</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\nimport { ErrorComponent} from './error.component'</code></pre>\n\n\n\n<p>Next import the routes, which we configured from app.routes</p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { routes } from './app.routes'; </code></pre>\n\n\n\n<p>Finally, we add the RouterModule to the import array, passing the routes we have configured via the forRoot method</p>\n\n\n\n<pre class=\"wp-block-code\"><code>imports: &#91;    BrowserModule,    FormsModule,    HttpModule,    RouterModule.forRoot(routes)], </code></pre>\n\n\n\n<p>Note that we are using the&nbsp;<strong>forRoot method</strong>.</p>\n\n\n\n<p><strong>the&nbsp;forRoot&nbsp;method</strong>&nbsp;is used, when you want to provide the service and also want to configure the service at the same time</p>\n\n\n\n<p>The&nbsp;<strong>routermodule.forroot</strong>&nbsp;method returns the Router Service configured with the routes passed in the argument and also registers the Router service. It also registers the other providers that the routing module requires.</p>\n\n\n\n<p>When the application is bootstrapped, the Router service looks at the current browser URL and performs the initial navigation.</p>\n\n\n\n<p>When the user changes the URL either clicking on a link in the page or by entering a URL in the address bar, the router looks for a corresponding Route from the Routes array and renders the associated component.</p>\n\n\n\n<h3>Defining The Navigation</h3>\n\n\n\n<p>The next step is to define the navigation</p>\n\n\n\n<p>Open the app.component.html. The AppComponent is only handling navigation. It will display the menu option, which user can click to navigate to a view</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\n&lt;div class=\"container\">\r\n \r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n    &lt;ul class=\"nav navbar-nav\">\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n \r\n &lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;/div></code></pre>\n\n\n\n<p>We are using bootstrap to style our component</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n&lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n&lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li>\r\n&lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li></code></pre>\n\n\n\n<p>We use&nbsp;<strong>the routerLink directive</strong>&nbsp;to bind anchor tag elements to the route</p>\n\n\n\n<p>RouterLink is an&nbsp;attribute&nbsp;directive. We enclose it a square bracket. The routerLink is then bound to template expression, which returns a<strong>&nbsp;link parameters array</strong>.</p>\n\n\n\n<p>The&nbsp;<strong>Link Parameters array</strong>&nbsp;is the Parameters or arguments to the Route. The Angular Router module constructs the URL using the link parameters array</p>\n\n\n\n<p>When the user clicks on the link, the Router service uses the path to locating the route associated with the path and activates the component</p>\n\n\n\n<h3>Display the component using Router-outlet</h3>\n\n\n\n<p>Finally, we need to tell Angular where to display the Component. This is done using the&nbsp;<strong>Router-outlet directive</strong></p>\n\n\n\n<p>The RouterOutlet is a directive that tells the Angular where in our page we want to display the view.<br>We do not have to import the RouterOutlet and RouterLink directives. These directives are imported when we imported RouterModule in our app.module</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;router-outlet>&lt;/router-outlet> </code></pre>\n\n\n\n<p>That’s it</p>\n\n\n\n<h2>Running the Application</h2>\n\n\n\n<p>Type the in the address bar http://localhost:4200, you should see the HomeComponent is rendered, which is the default root</p>\n\n\n\n<p>Type the invalid URL and you should see the ErrorComponent rendered.</p>\n\n\n\n<p>Click on the menu options or Type the Back &amp; forward button in the browser. Everything should work as intended.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>What is Routing Routing allows you to move from one part of the application to another part or one View to another View. The Angular Router Module The Router is a separate module in Angular. It is in its own library package,&nbsp;@angular/router. The Router Module provides the necessary service providers and directives for navigating through [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3661" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3661"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3661/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3850,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3661/revisions/3850"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3661"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3661"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3661"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3668,
    "date": "2020-12-07T10:51:02",
    "date_gmt": "2020-12-07T10:51:02",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3668" },
    "modified": "2020-12-09T06:52:20",
    "modified_gmt": "2020-12-09T06:52:20",
    "slug": "location-strategy-in-angular",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/location-strategy-in-angular/",
    "title": { "rendered": "Location Strategy in Angular" },
    "content": {
      "rendered": "\n<h2>Location Strategies in Angular Router</h2>\n\n\n\n<p>Being a Single Page Application, the Angular applications should not send the URL to the server and should not reload the page, every time user requests for a new page.&nbsp;</p>\n\n\n\n<p>The URLs are strictly local in Angular Apps. The&nbsp;Angular router&nbsp;navigates to the new component and renders its template and updates the history and URL for the view. All this happens locally in the browser.</p>\n\n\n\n<p>There are two ways, by which Angular achieves this. These are called Location Strategies.</p>\n\n\n\n<p>The Location Strategy defines how our URL/Request is resolved. It also determines how your URL will look like</p>\n\n\n\n<p>Angular supports two Location Strategies:</p>\n\n\n\n<ol><li><strong>HashLocationStrategy</strong><br>Where URL looks like http://localhost:4200/#/product</li><li><strong>PathLocationStrategy</strong><br>Where URL looks like&nbsp;http://localhost:4200/product</li></ol>\n\n\n\n<p>Before going further lets first understand what is client-side routing is</p>\n\n\n\n<h3>Client-Side Routing</h3>\n\n\n\n<p>In a Multi-page web application, Every time the application needs to a display a page it has to send a request to the webserver. You can do that by either typing the URL in the address bar, clicking on the Menu link/ button. Every such action results in browser sending a new request to the Web server</p>\n\n\n\n<p>But, the Angular Applications are single-page applications or SPA.</p>\n\n\n\n<p>All the components are displayed on a single page</p>\n\n\n\n<p>In a Typical Single Page Application, when the Web application is loaded it loads the single HTML page. Whenever the user interacts with the page, only a part of the page is dynamically updated.</p>\n\n\n\n<p>If you open the&nbsp;<code>index.html</code>&nbsp;in any of the angular application, you would see the following HTML markup</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;body>    \n&lt;app-root>Loading...&lt;/app-root>\n&lt;/body> </code></pre>\n\n\n\n<p>The&nbsp;<code>\"app-root\"</code>&nbsp;is a placeholder (selector), which is defined in the root component.</p>\n\n\n\n<p>Angular generates and loads the view associated with the root component inside the&nbsp;<code>\"app-root\"</code>. Any subsequent components are also loaded dynamically inside the&nbsp;<code>\"app-root\"</code>&nbsp;selector</p>\n\n\n\n<p>Angular does all this behind the scenes.</p>\n\n\n\n<p>In such a scenario, we are not required to change the URL. But that brings a few cons</p>\n\n\n\n<ul><li>You won’t be able to refresh the page</li><li>You won’t be able to go to a particular view by typing the URL</li><li>Sharing the URL with someone is not possible</li><li>The Back button will not work as you cannot go back to the previous page</li><li>SEO is not possible</li></ul>\n\n\n\n<p>That is where the client-side routing comes into the picture</p>\n\n\n\n<p>The Client-side routing simply mimics server-side routing by running the process in the browser. It changes the URL in the browser address bar and updates the browser history, without actually sending the request to the server</p>\n\n\n\n<h3>How Client-Side Routing works</h3>\n\n\n\n<p>The Client-side routing is handled in two ways</p>\n\n\n\n<ol><li>Hash style Routing</li><li>HTML 5 Routing</li></ol>\n\n\n\n<h2>Hash Style Routing</h2>\n\n\n\n<p>The Hash style routing using the anchor tags technique to achieve client-side routing.</p>\n\n\n\n<p>The anchor tags, when used along with the&nbsp;<code>#</code>&nbsp;allows us to jump to a place, within the web page.</p>\n\n\n\n<p>For Example</p>\n\n\n\n<p><strong>Index.html</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a name=\"contact\">Contact Us&lt;/a> </code></pre>\n\n\n\n<p>And we visited the URL&nbsp;<code>http://mysite.com/index.html#contact</code>, the browser would scroll to the location of the Contact us label</p>\n\n\n\n<p>When the requested anchor tag is on the current page, then the browser does not send the request to the Web server.</p>\n\n\n\n<p>The Hashstyle Routing uses this technique to create the URL</p>\n\n\n\n<p>The URL would look like something like</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\nhttp:&#47;&#47;www.example.com\r\nhttp://www.example.com/#/about\r\nhttp://www.example.com/#/contact</code></pre>\n\n\n\n<p>In all the above examples, only the URL sent to the server is&nbsp;<code>http://www.example.com</code>&nbsp;the URL’s&nbsp;<code>\"#/about\"</code>&nbsp;and&nbsp;<code>#/contact</code>&nbsp;is never sent to the server</p>\n\n\n\n<h2>HTML 5 routing</h2>\n\n\n\n<p>The introduction of HTML5, now allows browsers to programmatically alter the browser’s history through the history object.</p>\n\n\n\n<p>Using&nbsp;history.pushState()&nbsp;method, we can now programmatically add the browser history entries and change the location without triggering a server page request.</p>\n\n\n\n<p>The&nbsp;history.pushState&nbsp;method accepts the following three parameters.</p>\n\n\n\n<ol><li><strong>State object:</strong>&nbsp;A state object is a JavaScript object which is associated with the new history entry created by pushState()</li><li><strong>Title:</strong>&nbsp;This is an optional title for the state</li><li><strong>URL:</strong>&nbsp;The new history entry’s URL. The browser won’t jump to that page.</li></ol>\n\n\n\n<p>For example</p>\n\n\n\n<pre class=\"wp-block-code\"><code>var stateObj= { message: \"some message\" };\nhistory.pushState(stateObj, \"title\", newUrl); </code></pre>\n\n\n\n<p>Using&nbsp;<code>history.pushState</code>&nbsp;the method, The browser creates new history entries that change the displayed URL without the need for a new request.</p>\n\n\n\n<p>Example</p>\n\n\n\n<p>When you request for&nbsp;<code>http://www.example.com</code>&nbsp;the server sends the&nbsp;<code>index.html</code></p>\n\n\n\n<p>Now, When you click on&nbsp;<code>ProductList</code>&nbsp;link, Angular use’s the&nbsp;<code>history.pushState</code>&nbsp;method to push the state and change the URL to&nbsp;<code>http://www.example.com/ProductList</code></p>\n\n\n\n<p>Now, when you click on the specific Product, we again the use history method to push the state and change the URL to&nbsp;<code>http://www.example.com/product/1</code></p>\n\n\n\n<p>Here, when you click the back button, the browser will retrieve the&nbsp;<code>http://www.example.com/ProductList</code>&nbsp;from history and displays it.</p>\n\n\n\n<p>But there are cons to this approach</p>\n\n\n\n<ol><li>Not all browsers support HTML 5</li><li>The older browser does not support HTML5. So if you want to support older browser, you have to stick to the hash style routing</li><li>The server support is needed for HTML5 based routing.</li></ol>\n\n\n\n<h4>Why Server Support Needed for HTML 5 routing</h4>\n\n\n\n<p>Now, consider the above example</p>\n\n\n\n<p>What would happen, when you type the URL&nbsp;<code>http://www.example.com/ProductList</code>&nbsp;and hit the refresh button.</p>\n\n\n\n<p>The browser will send the request to the webserver. Since the page&nbsp;<code>ProductList</code>&nbsp;does not exist, it will return the 404 (page not found) error.</p>\n\n\n\n<p>This problem could be solved, if we are able to redirect all the request to the&nbsp;<code>index.html</code></p>\n\n\n\n<p>It means that when you ask from&nbsp;<code>http://www.example.com/ProductList</code>, the Web server must redirect it to index.html and return the request. Then in the Front-end Angular will read the URL and dynamically load the&nbsp;<code>ProductListComponent</code>.</p>\n\n\n\n<p>To make HTML5 routing work you need to send the instruction to the webserver to serve /index.html for any incoming request, no matter what the path is.</p>\n\n\n\n<h2>Location Strategy</h2>\n\n\n\n<p>As mentioned earlier, Angular implements both Hashstyle &amp; HTML 5 Routing.&nbsp;<code>HashLocationstrategy</code>&nbsp;implements the Hashstyle routing &amp;&nbsp;<code>Pathlocationstrategy</code>&nbsp;implements the HTML5 style routing</p>\n\n\n\n<h2>PathLocationStrategy Vs HashLocationStrategy</h2>\n\n\n\n<h3>PathLocationStrategy</h3>\n\n\n\n<p><strong>Pros:</strong></p>\n\n\n\n<ul><li>Produces a clear URL like http://example.com/foo</li><li>Supports Server-Side Rendering</li></ul>\n\n\n\n<p>Server-side Rendering is a technique that renders critical pages on the server that can greatly improve perceived responsiveness when the app first loads</p>\n\n\n\n<p>Cons:</p>\n\n\n\n<ul><li>Older browser does not support</li><li>Server Support needed for this to work</li></ul>\n\n\n\n<h3>HashLocationStrategy</h3>\n\n\n\n<p><strong>Pros:</strong></p>\n\n\n\n<ul><li>Supported by all browsers</li></ul>\n\n\n\n<p><strong>Cons:</strong></p>\n\n\n\n<ul><li>Produces a URL like http://example.com/#foo</li><li>Will not Support Server-Side Rendering</li></ul>\n\n\n\n<h2>PathLocationStrategy</h2>\n\n\n\n<p>The&nbsp;<code>PathLocationStrategy</code>&nbsp;is the default strategy in Angular application.</p>\n\n\n\n<p>To Configure the strategy, we need to add&nbsp;<code>&lt;base href&gt;</code>&nbsp;in the&nbsp;<code>&lt;head&gt;</code>&nbsp;section of root page (index.html) of our application</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;base href=\"/\"> </code></pre>\n\n\n\n<p>The Browser uses this element to construct the relative URLs for static resources (images, CSS, scripts) contained in the document.</p>\n\n\n\n<p>If you do not have access to&nbsp;<code>&lt;head&gt;</code>&nbsp;Section of the&nbsp;<code>index.html</code>, then you can follow either of the two steps</p>\n\n\n\n<p>Add the&nbsp;<code>APP_BASE_HREF</code>&nbsp;value as shown in the<a href=\"https://www.tektutorialshub.com/angular/angular-providers/\">&nbsp;</a>provider’s&nbsp;section of the root module</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Component, NgModule} from '@angular/core';\r\nimport {APP_BASE_HREF} from '@angular/common';\r\n \r\n@NgModule({\r\nproviders: &#91;{provide: APP_BASE_HREF, useValue: '/my/app'}]\r\n})\r\nclass AppModule {}</code></pre>\n\n\n\n<p>or use the absolute path for all the static resources like CSS, images, scripts, and HTML files.</p>\n\n\n\n<h2>HashLocationStrategy</h2>\n\n\n\n<p>You can use the HashLocationStrategy by providing the useHash: true in an object as the second argument of the RouterModule.forRoot in the AppModule.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n@NgModule({\r\ndeclarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,ProductComponent,ErrorComponent\r\n],\r\nimports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    Hashlocationstrategy RouterModule.forRoot(appRoutes, { useHash: true }\r\n],\r\nproviders: &#91;ProductService],\r\nbootstrap: &#91;AppComponent]\r\n})</code></pre>\n\n\n\n<h2>Which Location Strategy to Use</h2>\n\n\n\n<p>We recommend you to use the HTML 5 style (<code>PathLocationStrategy</code>&nbsp;) as your location strategy.</p>\n\n\n\n<p>Because</p>\n\n\n\n<ul><li>It produces clean and SEO Friendly URLs that are easier for users to understand and remember.</li><li>You can take advantage of the server-side rendering, which will make our application load faster, by rendering the pages in the server first before delivering it the client</li></ul>\n\n\n\n<p>Use hash location strategy only if you have to support the older browsers.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Location Strategies in Angular Router Being a Single Page Application, the Angular applications should not send the URL to the server and should not reload the page, every time user requests for a new page.&nbsp; The URLs are strictly local in Angular Apps. The&nbsp;Angular router&nbsp;navigates to the new component and renders its template and updates [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3668" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3668"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3668/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3851,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3668/revisions/3851"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3668"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3668"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3668"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3674,
    "date": "2020-12-07T11:01:26",
    "date_gmt": "2020-12-07T11:01:26",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3674" },
    "modified": "2020-12-09T06:56:47",
    "modified_gmt": "2020-12-09T06:56:47",
    "slug": "angular-route-parameters-passing-parameters-to-route",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-route-parameters-passing-parameters-to-route/",
    "title": {
      "rendered": "Angular Route Parameters: Passing Parameters to Route"
    },
    "content": {
      "rendered": "\n<h2>What are Route Parameters</h2>\n\n\n\n<p>The Route parameters are a dynamic part of the&nbsp;<code>Route</code>&nbsp;and essential in determining the route.</p>\n\n\n\n<p>For example, consider the following route</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: 'product', component: ProductComponent } </code></pre>\n\n\n\n<p>The above route match only if the URL is&nbsp;<code>/product</code></p>\n\n\n\n<p>To retrieve the product details, our URL should look something like</p>\n\n\n\n<p><code>/product/1</code><br><code>/product/2</code></p>\n\n\n\n<p>Where the second URL segment ( 1 and 2 ) being the id of the product. The&nbsp;<strong>id</strong>&nbsp;is dynamic and changes as per the selected Product. To handle such scenario&nbsp;angular router&nbsp;allows us to include&nbsp;<strong>route parameters</strong>, where we can send any dynamic value for a URL segment</p>\n\n\n\n<h2>How to Pass parameters to Angular Route</h2>\n\n\n\n<h3>Defining the Route</h3>\n\n\n\n<p>We can define parameter by adding forward slash followed colon and a placeholder (id) as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'product/:id', component: ProductDetailComponent } </code></pre>\n\n\n\n<p>Now above path matches the URLs&nbsp;<code>/product/1</code>&nbsp;,&nbsp;<code>/product/2</code>, etc.</p>\n\n\n\n<p>If you have more than one parameter, then you can extend it by adding one more forward slash followed colon and a placeholder</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: 'product/:id/:id1/:id2', component: ProductDetailComponent } </code></pre>\n\n\n\n<p>The name&nbsp;<code>id</code>,&nbsp;<code>id1</code>&nbsp;&amp;&nbsp;<code>id2</code>&nbsp;are placeholders for parameters. We will use them while retrieving the values of the parameters</p>\n\n\n\n<h3>Defining the Navigation</h3>\n\n\n\n<p>We, now need to provide both&nbsp;<strong>path</strong>&nbsp;and the<strong>&nbsp;route parameter</strong>&nbsp;<code>routerLink</code>&nbsp;directive.</p>\n\n\n\n<p>This is done by adding the&nbsp;<code>productID</code>&nbsp;as the second element to the&nbsp;<code>routerLink</code>&nbsp;parameters array as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'/Product', ‘2’]\">{{product.name}} &lt;/a> </code></pre>\n\n\n\n<p>Which translates to the URL&nbsp;<code>/product/2</code></p>\n\n\n\n<p>OR</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'/Product', product.productID]\">{{product.name}} &lt;/a> </code></pre>\n\n\n\n<p>Which, dynamically takes the value of id from the product object.</p>\n\n\n\n<h3>Retrieve the parameter in the component</h3>\n\n\n\n<p>Finally, our component needs to extract the route parameter from the URL</p>\n\n\n\n<p>This is done via the&nbsp;<strong>ActivatedRoute</strong>&nbsp;service from angular/router module to get the parameter value</p>\n\n\n\n<h2>ActviatedRoute</h2>\n\n\n\n<p>The&nbsp;ActivatedRoute&nbsp;is a service, which keeps track of the currently activated route&nbsp;associated with the loaded Component.</p>\n\n\n\n<p>To use&nbsp;<code>ActivatedRoute</code>, we need to import it in our component</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { ActivatedRoute } from '@angular/router'; </code></pre>\n\n\n\n<p>Then inject it into the component using dependency injection</p>\n\n\n\n<pre class=\"wp-block-code\"><code> constructor(private _Activatedroute:ActivatedRoute) </code></pre>\n\n\n\n<h3>ParamMap</h3>\n\n\n\n<p>The Angular adds the map all the route parameters in the&nbsp;<code>ParamMap</code>&nbsp;object, which can be accessed from the&nbsp;<code>ActivatedRoute</code>&nbsp;service</p>\n\n\n\n<p>The&nbsp;<code>ParamMap</code>&nbsp;makes it easier to work with parameters. We can use&nbsp;<code>get</code>&nbsp;or&nbsp;<code>getAll</code>&nbsp;methods to retrieve the value of the parameters in the component. Use the&nbsp;<code>has</code>&nbsp;method to check if a certain parameter exists.</p>\n\n\n\n<p>The Older version of ActivatedRoute class has a Params array which is an array of the parameter values, indexed by name. You can still use it but It is now deprecated and is replaced by the ParamMap.</p>\n\n\n\n<p>There are two ways in which you can use the&nbsp;<code>ActivatedRoute</code>&nbsp;to get the parameter value from the&nbsp;<code>ParamMap</code>&nbsp;object.</p>\n\n\n\n<ol><li>Using Snapshot</li><li>Using observable</li></ol>\n\n\n\n<h3>Using Snapshot</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>  this.id=this._Activatedroute.snapshot.paramMap.get(\"id\");</code></pre>\n\n\n\n<p>The&nbsp;<code>snapshot</code>&nbsp;property returns the initial value of the route. You can then access the&nbsp;<code>paramsMap</code>&nbsp;array, to access the value of the&nbsp;<code>id</code>, as shown above,</p>\n\n\n\n<p>Use the Snapshot option, if you only need the initial value.</p>\n\n\n\n<h3>Using Observable</h3>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nthis._Activatedroute.paramMap.subscribe(params => { \r\n    this.id = params.get('id'); \r\n});his._Activatedroute.paramMap.subscribe(params => {     this.id = params.get('id'); }); </code></pre>\n\n\n\n<p>You can retrieve the value of&nbsp;<code>id</code>&nbsp;by subscribing to the&nbsp;<code>paramMap</code>&nbsp;observable property of the&nbsp;<code>activateRoute</code>&nbsp;as shown above</p>\n\n\n\n<p>Use this option if you expect the value of the parameter to change over time.</p>\n\n\n\n<h3>Why use observable</h3>\n\n\n\n<p>We usually retrieve the value of the parameter in the&nbsp;ngOninit&nbsp;life cycle hook, when the component initialised.</p>\n\n\n\n<p>When the user navigates to the component again, the Angular does not create the new component but reuses the existing instance. In such circumstances, the&nbsp;<code>ngOnInit</code>&nbsp;method of the component is not called again. Hence you need a way to get the value of the parameter.</p>\n\n\n\n<p>By subscribing to the observable paramMap property, you will retrieve the latest value of the parameter and update the component accordingly.</p>\n\n\n\n<p>The above difference is explained in our next tutorial&nbsp;Angular child routes tutorial.</p>\n\n\n\n<h2>Passing Parameters to Route: Example</h2>\n\n\n\n<p>Here is the complete list of code.</p>\n\n\n\n<p><strong>product.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { Component, OnInit } from '@angular/core';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\n \r\n@Component({\r\n  templateUrl: './product.component.html',\r\n})\r\n \r\nexport class ProductComponent\r\n{\r\n \r\n   products:Product&#91;];\r\n   \r\n   constructor(private productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n     this.products=this.productService.getProducts();\r\n   }\r\n  \r\n}</code></pre>\n\n\n\n<p><strong>product.component.html</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1>Product List&lt;/h1>\r\n&lt;div class='table-responsive'>\r\n    &lt;table class='table'>\r\n        &lt;thead>\r\n            &lt;tr>\r\n                &lt;th>ID&lt;/th>\r\n                &lt;th>Name&lt;/th>\r\n                &lt;th>Price&lt;/th>\r\n            &lt;/tr>\r\n        &lt;/thead>\r\n        &lt;tbody>\r\n            &lt;tr *ngFor=\"let product of products;\">\r\n                &lt;td>{{product.productID}}&lt;/td>\r\n                &lt;td>&lt;a &#91;routerLink]=\"&#91;'/product',product.productID]\">{{product.name}} &lt;/a> &lt;/td>\r\n                &lt;td>{{product.price}}&lt;/td>\r\n            &lt;/tr>\r\n        &lt;/tbody>\r\n    &lt;/table>\r\n&lt;/div></code></pre>\n\n\n\n<p><strong>product.service.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Observable } from 'rxjs';\r\nimport {Product} from './Product'\r\n \r\n \r\nexport class ProductService{\r\n \r\n    public getProducts() {\r\n \r\n        let products:Product&#91;];\r\n \r\n        products=&#91;\r\n            new Product(1,'Memory Card',500),\r\n            new Product(2,'Pen Drive',750),\r\n            new Product(3,'Power Bank',100)\r\n        ]\r\n \r\n        return products;               \r\n    }\r\n \r\n \r\n    public getProduct(id) {\r\n        let products:Product&#91;]=this.getProducts();\r\n        return products.find(p => p.productID==id);\r\n    }\r\n \r\n \r\n}</code></pre>\n\n\n\n<p><strong>product.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>export class Product { \r\n \r\n    constructor(productID:number,    name: string ,   price:number) {\r\n        this.productID=productID;\r\n        this.name=name;\r\n        this.price=price;\r\n    }\r\n \r\n    productID:number ;\r\n    name: string ;\r\n    price:number;\r\n \r\n}</code></pre>\n\n\n\n<p>In the product.component.html, we have added&nbsp;<code>product.productID</code>&nbsp;as the second argument to the&nbsp;<code>routerLink</code>&nbsp;parameters array.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'/product',product.productID]\">{{product.name}} &lt;/a>  </code></pre>\n\n\n\n<h4>Product Details Component</h4>\n\n\n\n<p><strong>product-detail.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { Router,ActivatedRoute } from '@angular/router';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\n \r\n \r\n@Component({\r\n  templateUrl: './product-detail.component.html',\r\n})\r\n \r\nexport class ProductDetailComponent\r\n{\r\n \r\n   product:Product;\r\n   id;\r\n   \r\n   constructor(private _Activatedroute:ActivatedRoute,\r\n               private _router:Router,\r\n               private _productService:ProductService){\r\n   }\r\n \r\n  \r\n   /* Using snapshot */\r\n   // ngOnInit() {\r\n \r\n   //    //This still works but is deprecated\r\n   //    //this.id=this._Activatedroute.snapshot.params&#91;'id'];  \r\n \r\n   //    this.id=this._Activatedroute.snapshot.paramMap.get(\"id\");\r\n \r\n      \r\n   //    let products=this._productService.getProducts();\r\n   //    this.product=products.find(p => p.productID==this.id);\r\n   // }\r\n   \r\n \r\n   /* Using Subscribe */\r\n   \r\n   sub;\r\n \r\n   ngOnInit() {\r\n \r\n      this.sub=this._Activatedroute.paramMap.subscribe(params => { \r\n         console.log(params);\r\n          this.id = params.get('id'); \r\n          let products=this._productService.getProducts();\r\n          this.product=products.find(p => p.productID==this.id);    \r\n      });\r\n \r\n      // This params is deprecated\r\n \r\n      //this.sub=this._Activatedroute.params.subscribe(params => { \r\n      //    this.id = params&#91;'id']; \r\n      //    let products=this._productService.getProducts();\r\n      //    this.product=products.find(p => p.productID==this.id);    \r\n      //\r\n      //});\r\n   }\r\n \r\n   ngOnDestroy() {\r\n     this.sub.unsubscribe();\r\n   }\r\n   \r\n   onBack(): void {\r\n      this._router.navigate(&#91;'product']);\r\n   }\r\n}\r\n </code></pre>\n\n\n\n<p><strong>product-detail.component.html</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\n&lt;h3>Product Details Page&lt;/h3>\r\n \r\n \r\nproduct : {{product.name}}\r\nprice : {{ product.price}}\r\n&lt;p>\r\n    &lt;a class='btn btn-default' (click)=\"onBack()\">Back &lt;/a>\r\n&lt;/p></code></pre>\n\n\n\n<p>In the ProductDetailComponent, we have imported&nbsp;<code>router</code>&nbsp;and&nbsp;<code>ActivatedRoute</code>&nbsp;from the angular router module</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { Router,ActivatedRoute } from '@angular/router';</code></pre>\n\n\n\n<p>In the constructor, we inject the&nbsp;<code>ActivatedRoute</code>,&nbsp;<code>Router</code>&nbsp;service along with&nbsp;<code>ProductService</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>    constructor(private _Activatedroute:ActivatedRoute,\r\n               private _router:Router,\r\n               private _productService:ProductService){\r\n   }</code></pre>\n\n\n\n<p>Finally, we use&nbsp;<code>ngOninit</code>&nbsp;life cycle hook to retrieve the value of the&nbsp;<code>id</code>&nbsp;parameter and use that value to retrieve the details of the product.</p>\n\n\n\n<p>Note that, there are two ways, by which you can retrieve the data.</p>\n\n\n\n<p><strong>Using snapshot</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\nngOnInit() {\r\n \r\n     //This still works but is deprecated\r\n     //this.id=this._Activatedroute.snapshot.params&#91;'id'];  \r\n \r\n     this.id=this._Activatedroute.snapshot.paramMap.get(\"id\");\r\n \r\n      \r\n     let products=this._productService.getProducts();\r\n     this.product=products.find(p => p.productID==this.id);\r\n }</code></pre>\n\n\n\n<p><strong>Using Subscribe</strong></p>\n\n\n\n<p>We used snapshot method to retrieve the parameter in the ProductDetailcomponet.ts. To Subscribe to params remove the ngOnInit and replace it with the following code</p>\n\n\n\n<p>We recommend you to use the subscribe method as it offers the benefit of responding to the parameter changes dynamically.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ngOnInit() {\r\n \r\n      this.sub=this._Activatedroute.paramMap.subscribe(params => { \r\n         console.log(params);\r\n          this.id = params.get('id'); \r\n          let products=this._productService.getProducts();\r\n          this.product=products.find(p => p.productID==this.id);    \r\n      });\r\n \r\n      // This params is deprecated\r\n \r\n      //this.sub=this._Activatedroute.params.subscribe(params => { \r\n      //    this.id = params&#91;'id']; \r\n      //    let products=this._productService.getProducts();\r\n      //    this.product=products.find(p => p.productID==this.id);    \r\n      //\r\n      //});\r\n   }</code></pre>\n\n\n\n<h4>The Routes</h4>\n\n\n\n<p><strong>app.routing.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\nimport { ErrorComponent} from './error.component'\r\n \r\nimport { ProductDetailComponent} from './product-detail.component'\r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent },\r\n  { path: 'product/:id', component: ProductDetailComponent },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n  { path: '**', component: ErrorComponent }\r\n];\r\n </code></pre>\n\n\n\n<p>We have added the following route to our routes array</p>\n\n\n\n<pre class=\"wp-block-code\"><code>   { path: 'product/:id', component: ProductDetailComponent }, </code></pre>\n\n\n\n<h4>Other components</h4>\n\n\n\n<p><strong>app.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: &#91;'./app.component.css']\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Parameters Demo';\r\n}</code></pre>\n\n\n\n<p><strong>app.component.html</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;div class=\"container\">\r\n \r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n    &lt;ul class=\"nav navbar-nav\">\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n \r\n &lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;/div></code></pre>\n\n\n\n<p><strong>contact.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import {Component} from '@angular/core';\r\n \r\n@Component({\r\n     template: `&lt;h1>Contact Us&lt;/h1>\r\n                &lt;p>TekTutorialsHub &lt;/p>\r\n                `\r\n})\r\nexport class ContactComponent {\r\n}</code></pre>\n\n\n\n<p><strong>home.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> import {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}</code></pre>\n\n\n\n<p><strong>error.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Page not found&lt;/h1>\r\n               &lt;p>This is a Error Page&lt;/p>\r\n              `\r\n})\r\n \r\nexport class ErrorComponent {\r\n}\r\n </code></pre>\n\n\n\n<p><strong>app.module.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { HttpModule } from '@angular/http';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\nimport { ErrorComponent} from './error.component'\r\nimport { ProductDetailComponent} from './product-detail.component'\r\n \r\nimport { ProductService } from './product.service';\r\n \r\nimport { appRoutes } from './app.routes';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,ProductComponent,ErrorComponent,ProductDetailComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;ProductService],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { } </code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/05/Angular-Route-Parameters.gif\" alt=\"Passing data to Routes using Angular Route Parameters\" class=\"wp-image-12222\"/></figure>\n\n\n\n<h3>ActivatedRoute</h3>\n\n\n\n<p>The ActivatedRoute service has a great deal of useful information including:</p>\n\n\n\n<p><strong>url:</strong>&nbsp;This property returns an array of Url Segment objects, each of which describes a single segment in the URL that matched the current route.</p>\n\n\n\n<p><strong>params:</strong>&nbsp;This property returns a Params object, which describes the URL parameters, indexed by name.</p>\n\n\n\n<p><strong>queryParams:</strong>&nbsp;This property returns a Params object, which describes the URL query parameters, indexed by name.</p>\n\n\n\n<p><strong>fragment:</strong>&nbsp;This property returns a string containing the URL fragment.</p>\n\n\n\n<p><strong>Snapshot:</strong>&nbsp;The initial snapshot of this route</p>\n\n\n\n<p><strong>data:</strong>&nbsp;An Observable that contains the data object provided for the route</p>\n\n\n\n<p><strong>Component:</strong>&nbsp;The component of the route. It’s a constant</p>\n\n\n\n<p><strong>outlet:</strong>&nbsp;The name of the RouterOutlet used to render the route. For an unnamed outlet, the outlet name is primary.</p>\n\n\n\n<p><strong>routeConfig:</strong>&nbsp;The route configuration used for the route that contains the origin path.</p>\n\n\n\n<p><strong>parent:</strong>&nbsp;an ActivatedRoute that contains the information from the parent route when using child routes.</p>\n\n\n\n<p><strong>firstChild:</strong>&nbsp;contains the first ActivatedRoute in the list of child routes.</p>\n\n\n\n<p><strong>children:</strong>&nbsp;contains all the child routes activated under the current route</p>\n\n\n\n<p><strong>pathFromRoot:</strong>&nbsp;The path from the root of the router state tree to this route</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>What are Route Parameters The Route parameters are a dynamic part of the&nbsp;Route&nbsp;and essential in determining the route. For example, consider the following route The above route match only if the URL is&nbsp;/product To retrieve the product details, our URL should look something like /product/1/product/2 Where the second URL segment ( 1 and 2 ) [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3674" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3674"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3674/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3852,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3674/revisions/3852"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3674"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3674"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3674"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3677,
    "date": "2020-12-07T11:04:47",
    "date_gmt": "2020-12-07T11:04:47",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3677" },
    "modified": "2020-12-09T06:59:15",
    "modified_gmt": "2020-12-09T06:59:15",
    "slug": "angular-child-routes-nested-routes",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-child-routes-nested-routes/",
    "title": { "rendered": "Angular : Child Routes / Nested Routes" },
    "content": {
      "rendered": "\n<h2>Child Routes / Nested Routes</h2>\n\n\n\n<p>The Angular 2 applications are based on the idea of Components. The Components follows a Tree structure, where we have a root component at the top. We can then add child components forming loosely coupled components resembling a Tree</p>\n\n\n\n<p>The Routes in Angular also follows the component tree structure and allows us to define the nested or child routes.</p>\n\n\n\n<p>Example</p>\n\n\n\n<p>Consider the following Component Tree</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2017/05/Angular-Component-Tree-Child-Routes.png\" alt=\"Angular Component Tree Child Routes\" class=\"wp-image-5249\"/></figure>\n\n\n\n<p>In the above example, the ProductComponent displays the list of Products. The ProductDetailsComponent is defined as the child of the ProductComponent displays the details of the selected Product.</p>\n\n\n\n<p>So Our routes would be /Product and /Product/Details/:Id</p>\n\n\n\n<h2>How to Create Child Routes / Nested Routes</h2>\n\n\n\n<p>This tutorial builds on the app we have built in the&nbsp;Passing Parameters to Route Tutorial. You can download the code from&nbsp;gitHub.</p>\n\n\n\n<p>We already have created ProductDetailsComponent, but it is not designed as the child route of the ProductComponent. Let us update the code make it child route of the Product route.</p>\n\n\n\n<h3>Define the Routes</h3>\n\n\n\n<p>Open the app.routing.ts file</p>\n\n\n\n<p>You will see the following routes defined in our application.</p>\n\n\n\n<p>Here the ProductDetailComponent is defined as the sibling of the ProductComponent and not as the child</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: 'product', component: ProductComponent },\r\n{ path: 'product/:id', component: ProductDetailComponent },</code></pre>\n\n\n\n<p>To make ProductDetailComponent as the child of the ProductComponent, we need to add the children key to the product route, which is an array of all child routes as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'product', component: ProductComponent,\r\n  children: &#91;\r\n     { path: 'detail/:id', component: ProductDetailComponent }\r\n  ],\r\n </code></pre>\n\n\n\n<p>The child route definition is similar to the parent route definition. It has a path and component that gets invoked when the user navigates to the child route.</p>\n\n\n\n<p>In the above example, the parent route path is ‘product’ and the child route is ‘detail/:id’</p>\n\n\n\n<p>This is will match the URL path “/product/detail/id”.</p>\n\n\n\n<p>When the user navigates to the “/product/detail/id”, the router will start to look for a match in the routes array</p>\n\n\n\n<p>It starts off the first URL segment that is ‘product’ and finds the match in the path ‘product’ and instantiates the ProductComponent and displays it in the &lt;router-outlet&gt; directive of its parent component ( which is AppComponent)</p>\n\n\n\n<p>The router then takes the remainder of the URL segment ‘detail/id’ and continues to search for the child routes of Product route. It will match it with the path ‘detail/:id’ and instantiates the ProductDetailComponent and renders it in the &lt;router-outlet&gt; directive present in the ProductComponent</p>\n\n\n\n<p>Final app.routing.ts looks like this</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\nimport { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\nimport { ErrorComponent} from './error.component'\r\n \r\nimport { ProductDetailComponent} from './product-detail.component'\r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent, \r\n    children: &#91;\r\n      { path: 'detail/:id', component: ProductDetailComponent }\r\n    ]\r\n   },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n  { path: '**', component: ErrorComponent }\r\n];</code></pre>\n\n\n\n<h3>Display the component using Router-outlet</h3>\n\n\n\n<p>The components are always rendered in the&nbsp;<em>&lt;RouterOutlet&gt;</em>&nbsp;of the parent component.</p>\n\n\n\n<p>For ProductDetailComponent the parent component is ProductComponent and not the AppComponent</p>\n\n\n\n<p>Hence, we need to add &lt;router-outlet&gt;&lt;/router-outlet&gt; in the product.component.html as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n&lt;h1>Product List&lt;/h1>\r\n&lt;div class='table-responsive'>\r\n    &lt;table class='table'>\r\n        &lt;thead>\r\n            &lt;tr>\r\n                &lt;th>ID&lt;/th>\r\n                &lt;th>Name&lt;/th>\r\n                &lt;th>Price&lt;/th>\r\n            &lt;/tr>\r\n        &lt;/thead>\r\n        &lt;tbody>\r\n            &lt;tr *ngFor=\"let product of products;\">\r\n                &lt;td>{{product.productID}}&lt;/td>\r\n                &lt;td>&lt;a &#91;routerLink]=\"&#91;'detail',product.productID]\">{{product.name}} &lt;/a> &lt;/td>\r\n                &lt;td>{{product.price}}&lt;/td>\r\n            &lt;/tr>\r\n        &lt;/tbody>\r\n    &lt;/table>\r\n&lt;/div>\r\n \r\n&lt;router-outlet>&lt;/router-outlet> \r\n&lt;h1>Product List&lt;/h1>\r\n&lt;div class='table-responsive'>\r\n    &lt;table class='table'>\r\n        &lt;thead>\r\n            &lt;tr>\r\n                &lt;th>ID&lt;/th>\r\n                &lt;th>Name&lt;/th>\r\n                &lt;th>Price&lt;/th>\r\n            &lt;/tr>\r\n        &lt;/thead>\r\n        &lt;tbody>\r\n            &lt;tr *ngFor=\"let product of products;\">\r\n                &lt;td>{{product.productID}}&lt;/td>\r\n                &lt;td>&lt;a &#91;routerLink]=\"&#91;'detail',product.productID]\">{{product.name}} &lt;/a> &lt;/td>\r\n                &lt;td>{{product.price}}&lt;/td>\r\n            &lt;/tr>\r\n        &lt;/tbody>\r\n    &lt;/table>\r\n&lt;/div>\r\n \r\n&lt;router-outlet>&lt;/router-outlet></code></pre>\n\n\n\n<p>There is no change in the Product Detail Component.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\nimport { Router,ActivatedRoute } from '@angular/router';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\n \r\n \r\n@Component({\r\n  templateUrl: './product-detail.component.html',\r\n})\r\n \r\nexport class ProductDetailComponent\r\n{\r\n   product:Product;\r\n   id;\r\n   sub;\r\n \r\n   constructor(private _Activatedroute:ActivatedRoute,\r\n               private _router:Router,\r\n               private _productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n       this.id=this._Activatedroute.snapshot.params&#91;'id'];\r\n       let products=this._productService.getProducts();\r\n       this.product=products.find(p => p.productID==this.id);\r\n   }\r\n  \r\n} </code></pre>\n\n\n\n<p>Note that we are using the&nbsp;<strong>snapshot method</strong>&nbsp;to retrieve the route parameter id.</p>\n\n\n\n<h3>Testing the Nested/Child Route</h3>\n\n\n\n<p>Run the app and click on the Product link. You will see that the Product Page is displayed.&nbsp;Click on any of the Product, and you will see the Product details page is displayed</p>\n\n\n\n<h3>Why subscribe to route params</h3>\n\n\n\n<p>Now, click on another product, and you will notice that the Product details page does not get updated with the new product.</p>\n\n\n\n<p>Why?</p>\n\n\n\n<p>Because the angular does not create the component if it is already present in the DOM. It reuses<strong>&nbsp;the component</strong>&nbsp;instance</p>\n\n\n\n<p>This implies that the&nbsp;<strong>ngOnInit life cycle</strong>&nbsp;hook is not invoked when the user navigates to the component again. We are retrieving the parameter value in the ngOnInit using the snapshot method. Hence our component does not update itself.</p>\n\n\n\n<p>This issue can be rectified by subscribing to the observable params property. Our component will be notified, whenever the value of the parameter changes. So that we can update the component accordingly.</p>\n\n\n\n<h3>Using the Subscribe method to retrieve the parameters in child routes</h3>\n\n\n\n<p>Now, open the product-detail.component.ts and change the ngOnInit method to subscribe to the params property as shown below</p>\n\n\n\n<p>sub;</p>\n\n\n\n<pre class=\"wp-block-code\"><code> ngOnInit() {\r\n    this.sub=this._Activatedroute.params.subscribe(params => { \r\n        this.id = params&#91;'id']; \r\n        let products=this._productService.getProducts();\r\n        this.product=products.find(p => p.productID==this.id);    \r\n      });\r\n   }</code></pre>\n\n\n\n<p>We need to unsubscribe when the component is destroyed so as to stop the memory leakage</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ngOnDestroy() {    this.sub.unsubscribe();} </code></pre>\n\n\n\n<p>Now, you will see that as you click on another product, the ProductDetailComponents updates itself.</p>\n\n\n\n<h2>Nesting Children’s under a child</h2>\n\n\n\n<p>We can add child routes to a child route.</p>\n\n\n\n<p>For Example, What if we want to show Product Overview &amp; Specification under the Product Details Page. Our Component Tree is as shown below</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2017/05/Angular-Component-tree-Nested-Child-Route.png\" alt=\"ngular Component tree Nested Child Route\" class=\"wp-image-5250\"/></figure>\n\n\n\n<h3>Defining the child Route</h3>\n\n\n\n<p>First, we need to add three child routes under the Product/Details route as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>export const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent, \r\n      children: &#91;\r\n        { path: 'detail/:id', component: ProductDetailComponent, \r\n            children : &#91;\r\n                { path: 'overview', component: ProductOverviewComponent },\r\n                { path: 'spec', component: ProductSpecComponent },  \r\n                { path: '', redirectTo:'overview', pathMatch:\"full\" }\r\n            ]\r\n        }\r\n      ]\r\n    },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n  { path: '**', component: ErrorComponent }\r\n];</code></pre>\n\n\n\n<p>The first two child routes are simple. ‘Overview’ path is associated with ProductOverviewComponent &amp; ‘spec’ URL path is associated with the ProductSpecComponent</p>\n\n\n\n<p>The Url would become ‘/product/detail/:id/overview’ and ‘/product/detail/:id/spec’</p>\n\n\n\n<p>The last route is an empty path which is redirected to ‘Overview’ route. Note that&nbsp;<strong>pathMatch</strong>&nbsp;is set to ‘full’</p>\n\n\n\n<h3>Mapping the action to View</h3>\n\n\n\n<p>The updated code for Product Details page is shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1>Product Details Page&lt;/h1>\r\n \r\nproduct : {{product.name}}\r\nprice : {{ product.price}}\r\n \r\n&lt;ul class=\"nav navbar-nav\">\r\n    &lt;li>&lt;a &#91;routerLink]=\"&#91;'overview']\">OverView &lt;/a>&lt;/li>\r\n    &lt;li>&lt;a &#91;routerLink]=\"&#91;'spec']\">Specification &lt;/a>&lt;/li>\r\n&lt;/ul>\r\n \r\n&lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;p>\r\n    &lt;a class='btn btn-default' (click)=\"onBack()\">Back to Product List &lt;/a>\r\n&lt;/p></code></pre>\n\n\n\n<p>We are using a relative path to while binding path to the routerlink directive. Absolute paths will begin with a forward slash /. When using the relative path, the&nbsp;router will append the path to the parent route path to construct the final URL.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;ul class=\"nav navbar-nav\">\r\n    &lt;li>&lt;a &#91;routerLink]=\"&#91;'overview']\">OverView &lt;/a>&lt;/li>\r\n    &lt;li>&lt;a &#91;routerLink]=\"&#91;'spec']\">Specification &lt;/a>&lt;/li>\r\n&lt;/ul>\r\n </code></pre>\n\n\n\n<p>Both ProductOverviewComponent &amp; ProductSpecComponent are rendered inside the ProductDetailComponent. Hence we need to add &lt;router-outlet&gt;&lt;/router-outlet&gt; in the Template of ProductDetailComponent</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;router-outlet>&lt;/router-outlet> </code></pre>\n\n\n\n<h3>The Child Components</h3>\n\n\n\n<p>The ProductOverviewComponent just displays the text “Overview of &lt;Name of the Product&gt;” Message.</p>\n\n\n\n<p>The most important point is how we retrieve the product id from the route. We are subscribing to the params array of the parent component.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\nimport { Router,ActivatedRoute } from '@angular/router';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\n \r\n@Component({\r\n  template: `&lt;h3> Overview of {{product.name}} &lt;h3>`\r\n})\r\n \r\nexport class ProductOverviewComponent\r\n{\r\n   product:Product;\r\n   id;\r\n   sub;\r\n \r\n   constructor(private _Activatedroute:ActivatedRoute,\r\n               private _router:Router,\r\n               private _productService:ProductService){\r\n   }\r\n   ngOnInit() {\r\n \r\n      this.sub=this._Activatedroute.parent.params.subscribe(params => { \r\n          this.id = params&#91;'id']; \r\n          let products=this._productService.getProducts();\r\n          this.product=products.find(p => p.productID==this.id);    \r\n      });\r\n   }\r\n \r\n   ngOnDestroy() {\r\n     this.sub.unsubscribe();\r\n   }\r\n  \r\n}</code></pre>\n\n\n\n<p>ProductSpecComponent is similar to the above</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\n  import { Router,ActivatedRoute } from '@angular/router';\r\n \r\n  import { ProductService } from './product.service';\r\n  import { Product } from './product';\r\n \r\n  @Component({\r\n    template: `&lt;h3> Specification of {{product.name}} &lt;h3>`\r\n  })\r\n \r\n  export class ProductSpecComponent\r\n  {\r\n \r\n    product:Product;\r\n    id;\r\n    sub;\r\n \r\n    constructor(private _Activatedroute:ActivatedRoute,\r\n                private _router:Router,\r\n                private _productService:ProductService){\r\n    }\r\n \r\n    ngOnInit() {\r\n \r\n        this.sub=this._Activatedroute.parent.params.subscribe(params => { \r\n            this.id = params&#91;'id']; \r\n            let products=this._productService.getProducts();\r\n            this.product=products.find(p => p.productID==this.id);    \r\n        \r\n        });\r\n    }\r\n \r\n    ngOnDestroy() {\r\n      this.sub.unsubscribe();\r\n    }\r\n    \r\n  }</code></pre>\n\n\n\n<p>Finally, do not forget to import both the components in app.routes.ts &amp; app.module.ts</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Child Routes / Nested Routes The Angular 2 applications are based on the idea of Components. The Components follows a Tree structure, where we have a root component at the top. We can then add child components forming loosely coupled components resembling a Tree The Routes in Angular also follows the component tree structure and [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3677" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3677"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3677/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3853,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3677/revisions/3853"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3677"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3677"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3677"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3679,
    "date": "2020-12-07T11:16:37",
    "date_gmt": "2020-12-07T11:16:37",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3679" },
    "modified": "2020-12-09T07:03:08",
    "modified_gmt": "2020-12-09T07:03:08",
    "slug": "angular-passing-optional-query-parameters-to-a-route",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-passing-optional-query-parameters-to-a-route/",
    "title": {
      "rendered": "Angular : Passing Optional (Query) Parameters to a route"
    },
    "content": {
      "rendered": "\n<h2>What are query parameters</h2>\n\n\n\n<p>Query parameters are optional parameters that you pass to a route. The query parameters are added to the end of the URL Separated by Question Mark</p>\n\n\n\n<p>For Example</p>\n\n\n\n<pre class=\"wp-block-code\"><code>/product?page=2 </code></pre>\n\n\n\n<p>where&nbsp;<code>page=2</code>&nbsp;is the query parameter</p>\n\n\n\n<p>The above URL is an example of paginated product list, where URL indicates that second page of the Product list is to be loaded.</p>\n\n\n\n<h3>Difference between Query parameter and Route parameter</h3>\n\n\n\n<p>The&nbsp;route parameters&nbsp;are required and is used by&nbsp;Angular Router&nbsp;to determine the route. They are part of the route definition.</p>\n\n\n\n<p>For Example, when we define the route as shown below, the <code>id</code> is the route parameter.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n{ path: 'product', component: ProductComponent }\r\n{ path: 'product/:id', component: ProductDetailComponent }</code></pre>\n\n\n\n<p>The above route matches the following URL The angular maps the values 1 &amp; 2 to the&nbsp;<code>id</code>&nbsp;field</p>\n\n\n\n<pre class=\"wp-block-code\"><code>URL\r\n/product         matches => path: 'product'\r\n/product/1       matches => path: 'product/:id'\r\n/product/2       matches => path: 'product/:id'\r\n </code></pre>\n\n\n\n<p>The Router will not navigate to the&nbsp;<code>ProductDetailComponent</code>&nbsp;route, if the&nbsp;<code>id</code>&nbsp;is not provided. It will navigate to&nbsp;<code>ProductComponent</code>&nbsp;instead. If the&nbsp;<code>product</code>&nbsp;route is not defined, then it will result in a error.</p>\n\n\n\n<p>However, the query parameters are optional. The missing parameter does not stop angular from navigating to the route. The query parameters are added to the end of the URL Separated by Question Mark</p>\n\n\n\n<h4><strong>Route Parameters or Query Parameters?</strong></h4>\n\n\n\n<ul><li>Use route parameter when the value is required</li><li>Use query parameter, when the value is optional.</li></ul>\n\n\n\n<h2>How to use Query Parameters</h2>\n\n\n\n<p>The Query parameters are not part of the route. Hence you do not define them in the routes array like route parameters. You can add them using the&nbsp;<code>routerlink</code>&nbsp;directive or via&nbsp;<code>router.navigate</code>&nbsp;method.</p>\n\n\n\n<h3>Passing Query Parameters</h3>\n\n\n\n<p>Use the&nbsp;<code>queryParams</code>&nbsp;directive to add the query parameter. Use this directive along with the&nbsp;<code>routerlink</code>&nbsp;directive as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ page:2 }\">Page 2&lt;/a> </code></pre>\n\n\n\n<p>The&nbsp;<code>router</code>&nbsp;will construct the URL as&nbsp;<code>/product?pageNum=2</code></p>\n\n\n\n<p>You can pass more than one Query Parameter as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ val1:2 , val2:10}\">Whatever&lt;/a> </code></pre>\n\n\n\n<p>The router will construct the URL as&nbsp;<code>/product?val1=2&amp;val2=10</code></p>\n\n\n\n<p>You can also navigate programmatically using the navigate method of the Router service as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>goToPage(pageNum) {     \r\n    this.router.navigate(&#91;'/product'], { queryParams: { page: pageNum } }); \r\n}</code></pre>\n\n\n\n<h3>Reading Query Parameters</h3>\n\n\n\n<p>Reading the Query parameters is similar to reading the Router Parameter. There are two ways by which you can retrieve the query parameters.</p>\n\n\n\n<p>Note that queryParams is deprecated. It is replaced by the queryParamMap.</p>\n\n\n\n<h4>Using queryParamsMap observable</h4>\n\n\n\n<p>The&nbsp;<code>queryParamsMap</code>&nbsp;is a&nbsp;<code>Observable</code>&nbsp;that contains a&nbsp;map&nbsp;of the query parameters available to the current route. We can use this to retrieve values from the query parameter. The<br><code>queryParamsMap</code>&nbsp;is accessible via&nbsp;<code>ActivatedRoute</code></p>\n\n\n\n<p>Hence, we need to inject the&nbsp;<code>ActivatedRoute</code>&nbsp;in the constructor of the component/service,where we want to read the query parameter as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> conconstructor(private Activatedroute:ActivatedRoute,\r\n               private router:Router){\r\n   }structor(private Activatedroute:ActivatedRoute,               private router:Router){   } </code></pre>\n\n\n\n<p>You can subscribe to the&nbsp;<code>queryParamMap</code>&nbsp;of the&nbsp;<code>ActivatedRoute</code>, which returns the<br>observable of type&nbsp;ParamMap. We can then use the&nbsp;<code>get</code>&nbsp;method to read the query parameter as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nthis.sub = this.Activatedroute.queryParamMap\r\n       .subscribe(params => {\r\n     this.pageNum = +params.get('pageNum')||0;     \r\n});</code></pre>\n\n\n\n<h4>Using snapshot.queryParamMap property</h4>\n\n\n\n<p>You can also read the value of the query parameter from&nbsp;<code>queryParamMap</code>&nbsp;using the&nbsp;<code>snapshot</code>&nbsp;property of the&nbsp;<code>ActivatedRoute</code>&nbsp;as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.Activatedroute.snapshot.queryParamMap.get('pageNum')||0;; </code></pre>\n\n\n\n<p>Remember, the router populates the snapshot, when the component loads for the first time. Hence you will read only the initial value of the query parameter with the snapshot property. You will not be able to retrieve any subsequent changes to the query parameter.</p>\n\n\n\n<h2>queryParamsHandling</h2>\n\n\n\n<p>The query parameter is lost when the user navigates to another route.</p>\n\n\n\n<p>For Example, if user navigates to the product page with route&nbsp;<code>/product?pageNum=2</code>&nbsp;then he navigates to the product detail page, the angular removes the query parameter from the url. This is the default behaviour</p>\n\n\n\n<p>You can change this behavior by configuring the queryParamsHandling strategy. This Configuration strategy determines how the angular router handles query parameters, when user navigates away from the current route. It has three options</p>\n\n\n\n<h3>queryParamsHandling : null</h3>\n\n\n\n<p>This is default option. The angular removes the query parameter from the URL, when navigating to the next..</p>\n\n\n\n<pre class=\"wp-block-code\"><code>this.router.navigate(&#91;'product'], { queryParams: { pageNum: this.pageNo + 1 }, queryParamsHandling :null}   ); </code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ pageNum:2 }\">Page 2&lt;/a> </code></pre>\n\n\n\n<h3>queryParamsHandling : preserve</h3>\n\n\n\n<p>The Angular preserves or carry forwards the query parameter of the current route to next navigation. Any query parameters of the next route are discarded</p>\n\n\n\n<pre class=\"wp-block-code\"><code>this.router.navigate(&#91;'product'], { queryParams: { pageNum: this.pageNo + 1 }, queryParamsHandling :\"preserve\"}   );\r\n \r\n</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ pageNum:2 }\" queryParamsHandling=\"preserve\">Page 2&lt;/a> </code></pre>\n\n\n\n<h3>queryParamsHandling : merge</h3>\n\n\n\n<p>The Angular merges the query parameters from the current route with that of next route before navigating to the next route.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'product'], { queryParams: { pageNum: this.pageNo + 1 }, queryParamsHandling :\"merge\"}   ); </code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ pageNum:2 }\" queryParamsHandling=\"merge\">Page 2&lt;/a> </code></pre>\n\n\n\n<p>Note that&nbsp;preserveQueryParams&nbsp;is DEPRECATED</p>\n\n\n\n<h2>Query Params Example</h2>\n\n\n\n<p>Let us build a small application to demonstrate the use of Query parameters</p>\n\n\n\n<p>Let us update the app that we have built in the&nbsp;Passing Parameters to Route tutorial. You can download the code from&nbsp;gitHub. From the folder “Parameters” and the Final code at “QueryParameters”</p>\n\n\n\n<h3>AppComponent</h3>\n\n\n\n<h2>app.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Component } from '@angular/core';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: &#91;'./app.component.css']\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Query Parameters';\r\n  pageNum=0;\r\n \r\n}  </code></pre>\n\n\n\n<h2>app.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;div class=\"container\">\r\n \r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" href=\"#\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n \r\n    &lt;ul class=\"nav navbar-nav\">\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;div class=\"navbar-form navbar-left\">\r\n        &lt;div class=\"form-group\">\r\n          &lt;input type=\"text\" class=\"form-control\" placeholder=\"Page No\"  &#91;(ngModel)]=\"pageNum\">\r\n        &lt;/div>\r\n      &lt;/div>\r\n      &lt;li class=\"nav\">&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ pageNum: pageNum }\">Product&lt;/a>&lt;/li>\r\n      &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n \r\n &lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;/div></code></pre>\n\n\n\n<p>We have defined the&nbsp;<code>pageNum</code>&nbsp;variable in the component. An input box for the&nbsp;<code>pageNum</code>&nbsp;is provided, so that the user can change the page no.</p>\n\n\n\n<p>The&nbsp;<code>AppComponent</code>&nbsp;has the navigation Menu. It contains the link to the product page. The link is created using the&nbsp;<code>routerlink</code>&nbsp;directive. The&nbsp;<code>routerlink</code>&nbsp;directive contains the&nbsp;<code>queryParams</code>&nbsp;directive, where we pass the&nbsp;<code>pageNum</code>&nbsp;to&nbsp;<code>\"pageNum\"</code>&nbsp;variable.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;li class=\"nav\">&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ pageNum: pageNum }\">Product&lt;/a>&lt;/li> </code></pre>\n\n\n\n<p>The Angular will construct the URL as&nbsp;<code>/product?pageNum=2</code></p>\n\n\n\n<h3>Product Component</h3>\n\n\n\n<p>The&nbsp;<code>ProductComponent</code>&nbsp;does not display any products. But it displays the query parameters received</p>\n\n\n\n<h2>product.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Component, OnInit } from '@angular/core';\r\nimport { ActivatedRoute, Router} from '@angular/router';\r\n \r\n \r\n@Component({\r\n  templateUrl: './product.component.html',\r\n})\r\n \r\nexport class ProductComponent implements OnInit\r\n{\r\n \r\n   pageNo=0;\r\n   snapshotPageNo=0; \r\n \r\n   constructor(private Activatedroute:ActivatedRoute,\r\n               private router:Router){\r\n   }\r\n \r\n \r\n   ngOnInit() {\r\n     \r\n    //  the following code works but is DEPRECATED \r\n    //  this.snapshotPageNo =this.Activatedroute.snapshot.queryParams&#91;'pageNum']||0;\r\n     \r\n    //  this.Activatedroute.queryParams\r\n    //       .subscribe(params => { \r\n    //         this.pageNo = +params&#91;'pageNum']||0;\r\n    //         console.log('Query params ',this.pageNo) \r\n    //       });\r\n \r\n \r\n       this.snapshotPageNo =+this.Activatedroute.snapshot.queryParamMap.get('pageNum')||0;;\r\n       \r\n \r\n        this.Activatedroute.queryParamMap\r\n            .subscribe(params => { \r\n              this.pageNo = +params.get('pageNum')||0;\r\n              console.log('Query params ',this.pageNo) \r\n          });\r\n   }\r\n \r\n   nextPage() {\r\n      this.router.navigate(&#91;'product'], { queryParams: { pageNum: this.pageNo + 1 }} );\r\n   }\r\n  \r\n \r\n}</code></pre>\n\n\n\n<h2>product.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1>Product Page&lt;/h1>  &lt;p>Current Page No &lt;strong> {{pageNo}} &lt;/strong>&lt;/p> &lt;p>snapshot Page No  &lt;strong> {{ snapshotPageNo }} &lt;/strong>&lt;/p> &lt;button (click)=\"nextPage()\">Next Page&lt;/button> </code></pre>\n\n\n\n<p>First, we have injected both&nbsp;<code>ActivatedRoute</code>&nbsp;and&nbsp;<code>Router</code>&nbsp;Service in the constructor of the&nbsp;<code>ProductComponent</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>constructor(private Activatedroute:ActivatedRoute,            private router:Router){}  </code></pre>\n\n\n\n<p>Next, in the&nbsp;ngOnInit lifecycle hook, we use the&nbsp;<code>Activatedroute.snapshot</code>&nbsp;method to retrieve the&nbsp;<code>pageNum</code>&nbsp;and update the&nbsp;<code>snapshotPageNo</code>&nbsp;variable.</p>\n\n\n\n<p>We also subscribe to the&nbsp;<code>queryParams</code>&nbsp;property. We are updating our local variable&nbsp;<code>pageNo</code>&nbsp;with page number obtained from the&nbsp;<code>Queryparams</code></p>\n\n\n\n<p>In our template, we display both&nbsp;<code>snapshotPageNo</code>&nbsp;<code>pageNo</code>&nbsp;variable.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ngOnInit() {\r\n    \r\n  \r\n    this.snapshotPageNo = this.Activatedroute.snapshot.queryParams&#91;'pageNum'] || 0;\r\n     \r\n    this.Activatedroute.queryParams\r\n        .subscribe(params => { \r\n            this.pageNum = +params&#91;'pageNum']||0;\r\n           console.log('Query params ',this.pageNum) \r\n    });\r\n} </code></pre>\n\n\n\n<p>We also have&nbsp;<code>nextPage</code>&nbsp;method.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> nextPage() {      this._router.navigate(&#91;'./'], { queryParams: { pageNum: this.pageNum + 1 }, relativeTo: this._Activatedroute }   );   }</code></pre>\n\n\n\n<p>Here we are using the&nbsp;<code>router.navigate</code>&nbsp;method to navigate to the next page. This actually does not change route as we are already in the page. The angular router does not re create the component, but since we have subscribed to the Query parameters, we will be notified of the change in page Number. The&nbsp;<code>pageNum</code>&nbsp;variable is updated to the new value, while the&nbsp;<code>snapshotPageNo</code>&nbsp;does not change</p>\n\n\n\n<h3>Other Components</h3>\n\n\n\n<h2>app.module.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { HttpModule } from '@angular/http';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\n \r\nimport { appRoutes } from './app.routes';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,ProductComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<h2>app.routes.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\n \r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n];\r\n </code></pre>\n\n\n\n<h2>home.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}</code></pre>\n\n\n\n<h2>contact.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import {Component} from '@angular/core';\r\n \r\n@Component({\r\n     template: `&lt;h1>Contact Us&lt;/h1>\r\n                &lt;p>TekTutorialsHub &lt;/p>\r\n                `\r\n})\r\n \r\nexport class ContactComponent {\r\n}</code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>What are query parameters Query parameters are optional parameters that you pass to a route. The query parameters are added to the end of the URL Separated by Question Mark For Example where&nbsp;page=2&nbsp;is the query parameter The above URL is an example of paginated product list, where URL indicates that second page of the Product [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3679" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3679"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3679/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3854,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3679/revisions/3854"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3679"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3679"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3679"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3683,
    "date": "2020-12-07T11:22:02",
    "date_gmt": "2020-12-07T11:22:02",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3683" },
    "modified": "2020-12-07T11:22:02",
    "modified_gmt": "2020-12-07T11:22:02",
    "slug": "navigating-between-angular-routes",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/navigating-between-angular-routes/",
    "title": { "rendered": "Navigating between Angular routes" },
    "content": {
      "rendered": "\n<h2>Navigating between Angular routes</h2>\n\n\n\n<p>You can navigate between routes in Angular 2 in two ways</p>\n\n\n\n<ol><li>Using RouterLink Directive</li><li>Via Code</li></ol>\n\n\n\n<h3>RouterLink directive</h3>\n\n\n\n<p>We looked at how to navigate using the RouterLink directive in the previous tutorials.</p>\n\n\n\n<p>The RouterLink is a directive, which you can use to bind any clickable HTML element to a Route. When the user clicks on the HTML element the router will navigate to the associated Route.</p>\n\n\n\n<p>For Example</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li> </code></pre>\n\n\n\n<p>For Example</p>\n\n\n\n<p>Will map to URL “/product” and renders the associated ProductComponent</p>\n\n\n\n<h3>Navigating Using Code</h3>\n\n\n\n<p>You can also navigate imperatively by using the code. This is done using the router service, which provides navigate and navigatebyUrl methods via which you can perform route changes.</p>\n\n\n\n<h4>router.navigate</h4>\n\n\n\n<p>Use this method, if you want to Navigate to a route using the link parameters array. The first argument to the navigate method is link parameters array, which is similar to what we provide while defining the routerlink directive</p>\n\n\n\n<p><em><strong>Navigate Method always uses the absolute path unless you provide a starting point.</strong></em></p>\n\n\n\n<p>navigate.navigateByUrl</p>\n\n\n\n<p>Use this method if you want to navigate to a URL by using the absolute path. The first argument is a string containing the complete URL.</p>\n\n\n\n<p><em><strong>NavigateByUrl Method always uses the absolute path</strong></em></p>\n\n\n\n<p>To use both these methods, we need to inject router service into our component as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>constructor(private _router:Router){} </code></pre>\n\n\n\n<p>To use both these methods, we need to inject router service into our component as shown below</p>\n\n\n\n<p>And then invoke</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\t this._router.navigate(&#91;'product'] </code></pre>\n\n\n\n<p>And then invoke</p>\n\n\n\n<p>Or</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this._router.navigateByUrl('product') </code></pre>\n\n\n\n<p>Or</p>\n\n\n\n<p>To navigate to the desired route.</p>\n\n\n\n<h3>Link Parameters array</h3>\n\n\n\n<p>LINK Parameters array is an array of strings, which you must specify as argument to either to routerlink directive or navigate method for navigation to work</p>\n\n\n\n<p>We need to specify the path of the route and route parameters that go into the route URL.</p>\n\n\n\n<p>The following example resolves to the URL path ‘/product/detail/1’</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;li>&lt;a &#91;routerLink]=\"&#91;'product/detail/1']\">Product 1 Overview&lt;/a>&lt;/li> </code></pre>\n\n\n\n<p>The following example resolves to the URL path ‘/product/detail/1’</p>\n\n\n\n<p>or</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\t this._router.navigate(&#91;'product/detail/1']) </code></pre>\n\n\n\n<p>or</p>\n\n\n\n<h2>Relative and Absolute Paths in Routes</h2>\n\n\n\n<p>The Angular routes resemble directory-like tree structure.</p>\n\n\n\n<p>Hence, We can use directory like syntaxes like add / (root node) , ./ (current node) or ../ (Parent node) in the link parameters array</p>\n\n\n\n<p>The First segment of the link parameters array can be prepended with “<strong>/</strong>“, “<strong>./</strong>“, or “<strong>../</strong>”</p>\n\n\n\n<p>If the First segment of the route starts with “<strong>/</strong>“, then the path is considered to be Absolute path</p>\n\n\n\n<p>If the First segment begins with “<strong>./”</strong>&nbsp;or it does not begin with a slash, then the path is considered to be the&nbsp;relative path.</p>\n\n\n\n<p>And if the First segment begins with “.<strong>&nbsp;./</strong>“, then the path is relative to the parent route. (one level up)</p>\n\n\n\n<h3>router.navigate method and relative path</h3>\n\n\n\n<p>As mentioned earlier navigate method always uses the absolute path. To make Navigate method work with a relative path, we must let know the router where are we in the route tree.</p>\n\n\n\n<p>This done by setting the relativeTo Property to the ActivatedRoute as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\t this._router.navigate(&#91;'detail'], { queryParams: { pageNum: this.pageNum + 1 }, relativeTo: this._Activatedroute } ); </code></pre>\n\n\n\n<p>This done by setting the relativeTo Property to the ActivatedRoute as shown below</p>\n\n\n\n<h3>RouterLink directive and relative path</h3>\n\n\n\n<p>If you were using a RouterLink to navigate instead of the Router service, you’d use the same link parameters array, but you wouldn’t provide the object with the relativeTo property. The ActivatedRoute is implicit in a RouterLink directive.</p>\n\n\n\n<h3>Absolute Path Vs Relative Path Which one to Use?</h3>\n\n\n\n<p>It is recommended to use the Relative path. Using absolute path breaks our code if the parent URL structure changes. The relative path will not change even if the parent path changes</p>\n\n\n\n<p>To go to the parent route</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;li>&lt;a &#91;routerLink]=\"&#91;'../']\">Back&lt;/a>&lt;/li> </code></pre>\n\n\n\n<p>To go to the parent route</p>\n\n\n\n<p>To go to the Sibling route</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\t &lt;li>&lt;a &#91;routerLink]=\"&#91;'../&lt;sibling>']\">Goto sibling&lt;/a>&lt;/li> </code></pre>\n\n\n\n<p>To go to the Sibling route</p>\n\n\n\n<p>To go to the child route</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'../Detail'], { relativeTo: this.activatedRoute }); </code></pre>\n\n\n\n<p>To go to the child route</p>\n\n\n\n<h2>NavigationExtras</h2>\n\n\n\n<p>We can provide the extra options to both router.navigate() or router.navigatebyURL() method.</p>\n\n\n\n<p><strong>relativeTo:&nbsp;</strong>ActivatedRoute</p>\n\n\n\n<p>Enables relative navigation from the current ActivatedRoute. This is applicable only to&nbsp;router.navigate() method.</p>\n\n\n\n<p>Example:</p>\n\n\n\n<p>The following Navigates to the Detail route from child route</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'../Detail'], { relativeTo: this.activatedRoute }); </code></pre>\n\n\n\n<p>The following Navigates to the Detail route from child route</p>\n\n\n\n<p><strong>queryParams:</strong>&nbsp;Params</p>\n\n\n\n<p>Sets query parameters to the URL. You can refer to the tutorial How to pass query parameters to Angular route</p>\n\n\n\n<p>Example:</p>\n\n\n\n<p>The following code constructs the URL as “/product?page=2”.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>this.router.navigate(&#91;'/products'], { queryParams: { page: 1 } }); </code></pre>\n\n\n\n<p>The following code constructs the URL as “/product?page=2”.</p>\n\n\n\n<p><strong>fragment:</strong>&nbsp;string<br>Sets the hash fragment for the URL.</p>\n\n\n\n<p>Example:</p>\n\n\n\n<p>The following code constructs the URL as “/home#top”</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'/home'], { fragment: 'top' }); </code></pre>\n\n\n\n<p><strong>preserveQueryParams:</strong>&nbsp;boolean<br>Passes the query parameters of the current route to the next&nbsp;route</p>\n\n\n\n<p>Example:</p>\n\n\n\n<p>If you are on the route “Product?Page=2”, then the clicking on the following will pass the query parameters to the “view” route as “view?Page=2”</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'/view'], { preserveQueryParams: true }); </code></pre>\n\n\n\n<p><strong>queryParamsHandling:</strong>&nbsp;QueryParamsHandling</p>\n\n\n\n<p>The query parameters of the current route are merged with that of the new route if you set queryParamsHandling=”merge”.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'/view'], { queryParams: { page: 2 },preserveQueryParams: true, queryParamsHandling: \"merge\" });</code></pre>\n\n\n\n<p><strong>preserveFragment:</strong> boolean<br>Passes the fragment of the current route to the next navigation. Similar to the preserveQueryParams</p>\n\n\n\n<pre class=\"wp-block-code\"><code>this.router.navigate(&#91;'/view'], { preserveFragment: true }); </code></pre>\n\n\n\n<p><strong>skipLocationChange:</strong>&nbsp;boolean<br>You can change the route, without changing the URL in the browser. &nbsp;This Navigates to a new URL without pushing a new state into history.</p>\n\n\n\n<p>Example:</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'/view'], { skipLocationChange: true }); </code></pre>\n\n\n\n<p><strong>replaceUrl:</strong>&nbsp;boolean<br>The current route is removed from the browser history while navigating to the new route. It replaces the current state in history with the new state.</p>\n\n\n\n<p>Example:</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.navigate(&#91;'/view'], { replaceUrl: true }); </code></pre>\n\n\n\n<h2>RouterLink</h2>\n\n\n\n<p>You can provide the extra options to the RouterLink directive, similar to the NavigationExtras. The following options are supported</p>\n\n\n\n<p><strong>QueryParams: Params</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;queryParams]=\"{ page:2}\" }>Page 2&lt;/a> </code></pre>\n\n\n\n<p><strong>preserveQueryParams:</strong>boolean</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'product']\" { preserveQueryParams: \"true\" }\">Page 2&lt;/a> </code></pre>\n\n\n\n<p><strong>queryParamsHandling : QueryParamsHandling</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'product']\" { queryParams: { page: 2 }, queryParamsHandling: \"merge\" }\">Page 2&lt;/a> </code></pre>\n\n\n\n<p><strong>Fragment: string</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'product']\" { fragment: 'top' }\">Page 2&lt;/a> </code></pre>\n\n\n\n<p><strong>PreserveFragment: boolean</strong></p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><td>123</td><td>&nbsp;&lt;a [routerLink]=&#8221;[&#8216;product&#8217;]&#8221; { preserveFragment: <strong>true</strong> }&#8221;&gt;Page 2&lt;/a&gt;&nbsp;</td></tr></tbody></table></figure>\n\n\n\n<p><strong>SkipLocationChange: boolean</strong>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'product']\" { skipLocationChange: true\">Page 2&lt;/a> </code></pre>\n\n\n\n<p><strong>ReplaceUrl: boolean</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a &#91;routerLink]=\"&#91;'product']\" { replaceUrl: true\">Page 2&lt;/a></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Navigating between Angular routes You can navigate between routes in Angular 2 in two ways Using RouterLink Directive Via Code RouterLink directive We looked at how to navigate using the RouterLink directive in the previous tutorials. The RouterLink is a directive, which you can use to bind any clickable HTML element to a Route. When [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3683" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3683"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3683/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3684,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3683/revisions/3684"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3683"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3683"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3683"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3688,
    "date": "2020-12-07T11:33:50",
    "date_gmt": "2020-12-07T11:33:50",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3688" },
    "modified": "2020-12-09T07:05:49",
    "modified_gmt": "2020-12-09T07:05:49",
    "slug": "angular-guards-tutorial",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-guards-tutorial/",
    "title": { "rendered": "Angular Guards Tutorial" },
    "content": {
      "rendered": "\n<h2>Angular Route Guards</h2>\n\n\n\n<p>We use the Angular Guards to control, whether the user can navigate to or away from the current route.</p>\n\n\n\n<h2>Why Guards</h2>\n\n\n\n<p>We looked at how to configure our routes and navigate to the different parts of our application in our&nbsp;Angular Router Tutorial.&nbsp;Allowing the user to navigate all parts of the application is not a good idea. We need to restrict the user until the user performs specific actions like login. Angular provides the&nbsp;<strong>Route Guards</strong>&nbsp;for this purpose.</p>\n\n\n\n<p>One of the common scenario, where we use Route guards is authentication. We want our App to stop the unauthorized user from accessing the protected route. We achieve this by using the&nbsp;<strong>CanActivate guard</strong>, which angular invokes when the user tries to navigate into the protected route. Then we hook into the&nbsp;<strong>CanActivate guard</strong>&nbsp;and use the authentication service to check whether the user is authorized to use the route and if not we can redirect the user to the login page.</p>\n\n\n\n<h2>Uses of&nbsp; Angular Route Guards</h2>\n\n\n\n<ul><li>To Confirm the navigational operation</li><li>Asking whether to save before moving away from a view</li><li>Allow access to certain parts of the application to specific users</li><li>Validating the route parameters before navigating to the route</li><li>Fetching some data before you display the component.</li></ul>\n\n\n\n<h2>Types of Route Guards</h2>\n\n\n\n<p>The Angular Router supports Five different guards, which you can use to protect the route</p>\n\n\n\n<ol><li>CanActivate</li><li>CanDeactivate</li><li>Resolve</li><li>CanLoad</li><li>CanActivateChild</li></ol>\n\n\n\n<h3>CanActivate</h3>\n\n\n\n<p>This guard decides if a route can be activated (or component gets used). This guard is useful in the circumstance where the user is not authorized to navigate to the target component. Or the user might not be logged into the system</p>\n\n\n\n<p>Read:&nbsp;Angular CanActivate Guard Example</p>\n\n\n\n<h3>CanDeactivate</h3>\n\n\n\n<p>This Guard decides if the user can leave the component (navigate away from the current route). This route is useful in where the user might have some pending changes, which was not saved. The CanDeactivate route allows us to ask user confirmation before leaving the component. &nbsp;You might ask the user if it’s OK to discard pending changes rather than save them.</p>\n\n\n\n<p>Read:&nbsp;Angular CanDeactivate Guard Example</p>\n\n\n\n<h3>Resolve</h3>\n\n\n\n<p>This guard delays the activation of the route until some tasks are complete. You can use the guard to pre-fetch the data from the backend API, before activating the route</p>\n\n\n\n<h3>CanLoad</h3>\n\n\n\n<p>The&nbsp;<code>CanLoad</code>&nbsp;Guard prevents the loading of the&nbsp;Lazy Loaded Module. We generally use this guard when we do not want to unauthorized user to be able to even see the source code of the module.</p>\n\n\n\n<p>This guard works similar to&nbsp;<code>CanActivate</code>&nbsp;guard with one difference. The&nbsp;<code>CanActivate</code>&nbsp;guard prevents a particular&nbsp;<code>route</code>&nbsp;being accessed. The&nbsp;<code>CanLoad</code>&nbsp;prevents entire lazy loaded module from being downloaded, Hence protecting all the&nbsp;<code>routes</code>&nbsp;within that module.</p>\n\n\n\n<p>Read:&nbsp;Angular CanLoad Guard Example</p>\n\n\n\n<h3>CanActivateChild</h3>\n\n\n\n<p>This guard determines whether a child route can be activated. This&nbsp;guard is very similar to&nbsp;CanActivateGuard. We apply this guard to the parent route. The Angular invokes this guard whenever the user tries to navigate to any of its child route. This allows us to check some condition and decide whether to proceed with the navigation or cancel it.</p>\n\n\n\n<p>Read:&nbsp;Angular CanActivateChild Guard Example</p>\n\n\n\n<h2>How to Build Angular Route Guards</h2>\n\n\n\n<p>Building the Guards are very easy.</p>\n\n\n\n<ol><li>Build the Guard as Service.</li><li>Implement the Guard Method in the Service</li><li>Register the Guard Service in the Root Module</li><li>Update the Routes to use the guards</li></ol>\n\n\n\n<h3>1. Build the Guard as Service</h3>\n\n\n\n<p>Building the Guard Service is as simple as building any other&nbsp;Angular Service. You need to import the corresponding guard from the Angular Router Library using the Import statement. For Example to use&nbsp;<code>CanActivate</code>&nbsp;Guard import the&nbsp;<code>CanActivate</code>&nbsp;in the import&nbsp;&nbsp;the&nbsp;<code>CanActivate</code>&nbsp;in the import statement</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { CanActivate } from '@angular/router'; </code></pre>\n\n\n\n<p>Next, create the Guard class which implement the selected guard Interface as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> @Injectable()export class ProductGuardService implements CanActivate {} </code></pre>\n\n\n\n<p>You can also inject other services into the Guards using the&nbsp;Dependency Injection</p>\n\n\n\n<h3>2. Implement the Guard Method</h3>\n\n\n\n<p>The next step is to create the Guard Method. The name of the Guard method is same as the Guard it implements. For Example to implement the&nbsp;<code>CanActivate</code>&nbsp;guard, create a method&nbsp;<code>CanActivate</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\ncanActivate(): boolean {    \r\n    // Check weather the route can be activated;    \r\n    return true;     \r\n    // or false if you want to cancel the navigation; \r\n}</code></pre>\n\n\n\n<h4>Return value from the Guard</h4>\n\n\n\n<p>The guard method must return either a True or a False value.</p>\n\n\n\n<p>If it returns true, the navigation process continues. if it returns false, the navigation process stops and the user stays put.</p>\n\n\n\n<p>The above method returns a True value. The Guard can also return an Observable or a Promise which eventually returns a True or false. The Angular will keep the user waiting until the guard returns true or false.</p>\n\n\n\n<p>The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.</p>\n\n\n\n<h3>3. Register the Guard as Service in Module</h3>\n\n\n\n<p>As mentioned earlier, guards are nothing but services. We need to register them with the Providers array of the&nbsp;Angular Module&nbsp;as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>providers: &#91;ProductService,ProductGuardService] </code></pre>\n\n\n\n<p>The&nbsp;Angular router&nbsp;requires the Guards and all other services that guard depends on available during the navigation. Hence the guards must be provided at the module level. This allows the router to access the guards using the&nbsp;Dependency Injection.</p>\n\n\n\n<h3>4. Update the Routes</h3>\n\n\n\n<p>Finally, we need to add the guards to the routes array as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'product', component: ProductComponent, canActivate : &#91;ProductGuardService] } </code></pre>\n\n\n\n<p>The above code adds the&nbsp;<code>canActivate</code>&nbsp;guard (ProductGuardService) to the &nbsp;Product route.</p>\n\n\n\n<p>When the user navigates to the Product route the Angular calls the&nbsp;<code>canActivate</code>&nbsp;method from the&nbsp;<code>ProductGuardService</code>. If the method returns true then the&nbsp;<code>ProductComponent</code>&nbsp;is rendered.</p>\n\n\n\n<p>You can add more than one guard as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n{ path: 'product', \r\n  component: ProductComponent, \r\n  canActivate : &#91;ProductGuardService, AnotherProductGuardService ] \r\n}</code></pre>\n\n\n\n<p>The syntax for adding other guards are also similar</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\n{ path: 'product', component,        \r\n    canActivate : any&#91;],        \r\n    canActivateChild: any&#91;],       \r\n    canDeactivate: any&#91;],       \r\n    canLoad: any&#91;],       \r\n    resolve: any&#91;] \r\n}</code></pre>\n\n\n\n<h4>Order of execution of route guards</h4>\n\n\n\n<p>A route can have multiple guards and you can have guards at every level of a routing hierarchy.</p>\n\n\n\n<p><code>CanDeactivate()</code>&nbsp;and&nbsp;<code>CanActivateChild()</code>&nbsp;guards are always checked first. The checking starts from the deepest child route to the top.</p>\n\n\n\n<p><code>CanActivate()</code>&nbsp;guard is checked next and checking starts from the top to the deepest child route.</p>\n\n\n\n<p><code>CanLoad()</code>&nbsp;is invoked next, &nbsp;If the feature module is to be loaded asynchronously.</p>\n\n\n\n<p><code>Resolve()</code>&nbsp;Guard is invoked last.</p>\n\n\n\n<p>The Angular Router cancels the navigation If any of the guards return false.</p>\n\n\n\n<h2>Angular Guards Example</h2>\n\n\n\n<p>Let us update the App, we built in the previous tutorials on Angular Routers, and use the<code>CanActivate</code>&nbsp;Guard to prevent the user from activating the&nbsp;<code>ProductComponent</code></p>\n\n\n\n<p>The source code for this tutorial is available on&nbsp;GitHub</p>\n\n\n\n<h3>Guard Service</h3>\n\n\n\n<p>We create Guard classes are service. Create a file named product-guard.service.ts in the src/app folder and add the following code</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Injectable } from '@angular/core';\r\nimport { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\n \r\n@Injectable()\r\nexport class ProductGuardService implements CanActivate {\r\n \r\n  constructor(private _router:Router ) {      \r\n  }      \r\n \r\n  canActivate(route: ActivatedRouteSnapshot,\r\n              state: RouterStateSnapshot): boolean {\r\n      console.log(\"canActivate\");      //return true    \r\n     //remove comments to return true              \r\n     alert('You are not allowed to view this page. You are redirected to Home Page'); \r\n     this._router.navigate(&#91;\"home\"]);             \r\n     return false;     \r\n} }</code></pre>\n\n\n\n<p>First, we need to import the Router, CanActivate, ActivatedRouteSnapshot &amp; RouterStateSnapshot library from the angular/core package</p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router'; </code></pre>\n\n\n\n<p>Define the ProductGuardService which implements the CanActivate Interface</p>\n\n\n\n<pre class=\"wp-block-code\"><code>export class ProductGuardService implements CanActivate { </code></pre>\n\n\n\n<p>Finally, define the&nbsp;<code>canActivate</code>&nbsp;method</p>\n\n\n\n<p>The&nbsp;<code>canActivate</code>&nbsp;method accepts two arguments. The first argument is an&nbsp;<code>ActivatedRouteSnapshot</code>&nbsp;object, which describes the route that is being navigated to using the properties. The second argument is a&nbsp;<code>RouterStateSnapshot</code>&nbsp;object, which describes the current route through a single property called URL.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\ncanActivate(route: ActivatedRouteSnapshot, \r\n           state: RouterStateSnapshot): boolean {    \r\n \r\n    console.log(\"canActivate\");     //return true \r\n    //remove comments to return true   \r\n    alert('You are not allowed to view this page. You are redirected to Home Page');    \r\n    //this._router.navigate(&#91;\"home\"]); //navigate to some other route;    \r\n    return false;\r\n}</code></pre>\n\n\n\n<p>Import the Guard in the Root Module</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { HttpModule } from '@angular/http';\r\nimport { RouterModule } from '@angular/router';\r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component';\r\nimport { ContactComponent} from './contact.component';\r\nimport { ProductComponent} from './product.component';\r\nimport { ErrorComponent} from './error.component';\r\nimport { ProductDetailComponent} from './product-detail.component';\r\nimport { ProductService } from './product.service';\r\nimport { ProductGuardService } from './product-guard.service';\r\nimport { appRoutes } from './app.routes';\r\n \r\n@NgModule({\r\n  declarations: &#91; AppComponent,HomeComponent,ContactComponent, \r\n                 ProductComponent,ErrorComponent, \r\n                 ProductDetailComponent],     \r\n  imports:      &#91; BrowserModule, FormsModule,HttpModule,                \r\n                 RouterModule.forRoot(appRoutes)],     \r\n  providers:    &#91; ProductService,ProductGuardService ], \r\n  bootstrap:    &#91; AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<p>First Import the Guard Service as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { ProductGuardService } from './product-guard.service';</code></pre>\n\n\n\n<p>Next, Register it using the&nbsp;<code>Providers</code>&nbsp;metadata, so that router can use it. Remember that Guards must be provided at the angular module level</p>\n\n\n\n<pre class=\"wp-block-code\"><code>providers: &#91;ProductService,ProductGuardService], </code></pre>\n\n\n\n<h3>Update the Routes</h3>\n\n\n\n<p>Finally, Update the&nbsp;<code>app.routes</code>&nbsp;class</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Routes } from '@angular/router'; \r\nimport { HomeComponent} from './home.component';\r\nimport { ContactComponent} from './contact.component';\r\nimport { ProductComponent} from './product.component';\r\nimport { ErrorComponent} from './error.component';\r\nimport { ProductDetailComponent} from './product-detail.component';\r\nimport { ProductGuardService } from './product-guard.service';\r\n \r\nexport const appRoutes: Routes = &#91;     \r\n  { path: 'home', component: HomeComponent },     \r\n  { path: 'contact', component: ContactComponent },     \r\n  { path: 'product', component: ProductComponent, canActivate :&#91;ProductGuardService] },     \r\n  { path: 'product/:id', component: ProductDetailComponent },     \r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },     \r\n  { path: '**', component: ErrorComponent }\r\n];</code></pre>\n\n\n\n<p>The only change we have done is to attach the&nbsp;<code>ProductGuardService</code>&nbsp;to the&nbsp;<code>CanActivate</code>&nbsp;guard</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: 'product', \r\n  component: ProductComponent, \r\n  canActivate : &#91;ProductGuardService] },</code></pre>\n\n\n\n<p>Test the Guard&nbsp;Run the app and you will see the alert message “You are not allowed to view this page. You are redirected to Home Page”</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Angular Route Guards We use the Angular Guards to control, whether the user can navigate to or away from the current route. Why Guards We looked at how to configure our routes and navigate to the different parts of our application in our&nbsp;Angular Router Tutorial.&nbsp;Allowing the user to navigate all parts of the application is [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3688" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3688"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3688/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3855,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3688/revisions/3855"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3688"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3688"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3688"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3690,
    "date": "2020-12-07T11:59:22",
    "date_gmt": "2020-12-07T11:59:22",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3690" },
    "modified": "2020-12-09T07:08:43",
    "modified_gmt": "2020-12-09T07:08:43",
    "slug": "angular-canactivate-guard-example",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-canactivate-guard-example/",
    "title": { "rendered": "Angular CanActivate Guard Example" },
    "content": {
      "rendered": "\n<h2>What is CanActivate Guard</h2>\n\n\n\n<p>The Angular CanActivate guard decides, if a&nbsp;<code>route</code>&nbsp;can be activated ( or component gets rendered). We use this guard, when we want to check on some condition, before activating the component or showing it to the user. This allows us to cancel the navigation.</p>\n\n\n\n<h3>Use cases for the CanActivate Guard</h3>\n\n\n\n<ul><li>Checking if a user has logged in</li><li>Checking if a user has permission</li></ul>\n\n\n\n<p>One of the use case of this guard is to check if the user has logged in to the system. If user has not logged in, then the guard can redirect him to login page.</p>\n\n\n\n<h2>How to use CanActivate Guard</h2>\n\n\n\n<p>First, we need to create a&nbsp;Angular Service.</p>\n\n\n\n<p>The service must import &amp; implement the&nbsp;<code>CanActivate</code>&nbsp;Interface. This Interface is defined in the&nbsp;<code>@angular/router</code>&nbsp;module. The Interface has one method i.e.&nbsp;<code>canActivate</code>. We need to implement it in our Service. The details of the&nbsp;<code>CanActivate</code>&nbsp;interface is as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>interface CanActivate {\r\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree> | Promise&lt;boolean | UrlTree> | boolean | UrlTree\r\n}\r\n </code></pre>\n\n\n\n<p>The method gets the instance of the&nbsp;<code>ActivatedRouteSnapshot</code>&nbsp;&amp;&nbsp;<code>RouterStateSnapshot</code>. We can use this to get access to the route parameter, query parameter etc.</p>\n\n\n\n<p>The guard must return true/false or a&nbsp;UrlTree&nbsp;. The return value can be in the form of observable or a promise or a simple&nbsp;<code>boolean</code>&nbsp;value.</p>\n\n\n\n<p>A route can have more than one&nbsp;<code>canActivate</code>&nbsp;guard.</p>\n\n\n\n<p>If&nbsp;<strong>all guards</strong>&nbsp;returns&nbsp;<code>true</code>, navigation to the route will continue.</p>\n\n\n\n<p>If&nbsp;<strong>any one of the guard</strong>&nbsp;returns&nbsp;<code>false</code>, navigation will be cancelled.</p>\n\n\n\n<p>If<strong>&nbsp;any one of the guard</strong>&nbsp;returns a&nbsp;<code>UrlTree</code>, current navigation will be cancelled and a new navigation will be kicked off to the&nbsp;<code>UrlTree</code>&nbsp;returned from the guard.</p>\n\n\n\n<p>The example of&nbsp;<code>canActivate</code>&nbsp;guard is as follows</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\n \r\n \r\n@Injectable()\r\nexport class AuthGuardService implements CanActivate {\r\n \r\n    constructor(private _router:Router ) {\r\n    }\r\n \r\n    canActivate(route: ActivatedRouteSnapshot,\r\n                state: RouterStateSnapshot): boolean {\r\n \r\n        //check some condition  \r\n        if (someCondition)  {\r\n            alert('You are not allowed to view this page');\r\n            //redirect to login/home page etc\r\n            //return false to cancel the navigation\r\n            return false;\r\n        } \r\n        return true;\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<p>Update the route definition with the&nbsp;<code>canActivate</code>&nbsp;guard as shown below. You can apply more than one guard to a route and a route can have more than one guard</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'product', component: ProductComponent, canActivate : &#91;AuthGuardService] }, </code></pre>\n\n\n\n<h2>CanActivate guard Example</h2>\n\n\n\n<p>In our example application, we will create three components. The&nbsp;<code>HomeComponent</code>&nbsp;&amp;&nbsp;<code>ContactComponent</code>&nbsp;are not protected and can be accessed any user. The user must log in into the system to access the&nbsp;<code>ProductComponent</code>..We also need a&nbsp;<code>LoginComponent</code>&nbsp;to handle the user login.</p>\n\n\n\n<h3>LoginComponent</h3>\n\n\n\n<p>The following is the code for&nbsp;<code>LoginComponent</code>&nbsp;and associated&nbsp;<code>AuthService</code></p>\n\n\n\n<h2>login.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component, OnInit } from '@angular/core';\r\nimport { FormControl, FormGroup } from '@angular/forms';\r\nimport { Router, ActivatedRoute } from '@angular/router';\r\nimport { AuthService } from './auth.service';\r\n \r\n@Component({\r\n   templateUrl: './login.component.html',\r\n   styles: &#91;``]\r\n})\r\nexport class LoginComponent implements OnInit { \r\n \r\n    invalidCredentialMsg: string;\r\n    username:string;\r\n    password:string;\r\n    retUrl:string=\"home\";\r\n \r\n    constructor(private authService: AuthService, \r\n                private router: Router, \r\n                private activatedRoute:ActivatedRoute) {\r\n    }\r\n \r\n    ngOnInit() {\r\n        this.activatedRoute.queryParamMap\r\n                .subscribe(params => {\r\n            this.retUrl = params.get('retUrl'); \r\n            console.log( 'LoginComponent/ngOnInit '+ this.retUrl);\r\n        });\r\n    }\r\n \r\n    onFormSubmit(loginForm) {\r\n       this.authService.login(loginForm.value.username, loginForm.value.password).subscribe(data => {\r\n           console.log( 'return to '+ this.retUrl);\r\n           if (this.retUrl!=null) {\r\n                this.router.navigate( &#91;this.retUrl]);\r\n           } else {\r\n                this.router.navigate( &#91;'home']);\r\n           }\r\n       });\r\n    }\r\n} </code></pre>\n\n\n\n<h2>login.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;h3>Login Form&lt;/h3>\r\n \r\n&lt;div>\r\n &lt;form #loginForm=\"ngForm\" (ngSubmit)=\"onFormSubmit(loginForm)\">\r\n   &lt;p>User Name: &lt;input type='text'  name='username' ngModel>&lt;/p>\r\n   &lt;p>Password: &lt;input type=\"password\"  name=\"password\" ngModel>&lt;/p>\r\n   &lt;p>&lt;button type=\"submit\">Submit&lt;/button>&lt;/p> \r\n &lt;/form>\r\n&lt;/div> </code></pre>\n\n\n\n<h2>auth.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport 'rxjs/add/observable/of';\r\nimport 'rxjs/add/operator/map';\r\nimport { of } from 'rxjs';\r\n \r\n@Injectable()\r\nexport class AuthService { \r\n \r\n    private isloggedIn: boolean;\r\n    private userName:string;\r\n \r\n    constructor() {\r\n        this.isloggedIn=false;\r\n    }\r\n \r\n    login(username: string, password:string) {\r\n \r\n        //Assuming users are provided the correct credentials.\r\n        //In real app you will query the database to verify.\r\n        this.isloggedIn=true;\r\n        this.userName=username;\r\n        return of(this.isloggedIn);\r\n    }\r\n \r\n    isUserLoggedIn(): boolean {\r\n        return this.isloggedIn;\r\n    }\r\n \r\n    isAdminUser():boolean {\r\n        if (this.userName=='Admin') {\r\n            return true; \r\n        }\r\n        return false;\r\n    }\r\n    \r\n    logoutUser(): void{\r\n        this.isloggedIn = false;\r\n    }\r\n \r\n} </code></pre>\n\n\n\n<p>The&nbsp;<code>AuthService</code>&nbsp;checks whether the user is allowed to login. It has the method to&nbsp;<code>login</code>&nbsp;&amp;&nbsp;<code>logout</code>&nbsp;the users. Our implementation of the&nbsp;<code>login</code>&nbsp;method does not check for anything. It just marks the user as logged in.</p>\n\n\n\n<h3>ProductComponent</h3>\n\n\n\n<p>The&nbsp;<code>ProductComponent</code>&nbsp;is our protected component. Only the logged in users can access this. This component displays the list of Products, which it gets from the&nbsp;<code>ProductService</code>.</p>\n\n\n\n<h2>product.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Component, OnInit } from '@angular/core';\r\nimport { ProductService } from './product.service';\r\nimport { Product } from './Product';\r\n \r\n \r\n@Component({\r\n  templateUrl: \"product.component.html\",\r\n})\r\nexport class ProductComponent\r\n{\r\n \r\n   products:Product&#91;];\r\n   constructor(private productService: ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n \r\n      this.productService.getProducts()\r\n        .subscribe(data => {\r\n          this.products=data;\r\n        })\r\n   }\r\n  \r\n}</code></pre>\n\n\n\n<h2>product.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1>Product List&lt;/h1>\r\n   &lt;p> This is a protected component &lt;/p>\r\n \r\n   &lt;div class='table-responsive'>\r\n   &lt;table class='table'>\r\n       &lt;thead>\r\n           &lt;tr>\r\n               &lt;th>Name&lt;/th>\r\n               &lt;th>Price&lt;/th>\r\n           &lt;/tr>\r\n       &lt;/thead>\r\n       &lt;tbody>\r\n           &lt;tr *ngFor=\"let product of products;\">\r\n               &lt;td>&lt;a>{{product.name}} &lt;/a> &lt;/td>\r\n               &lt;td>{{product.price}}&lt;/td>\r\n           &lt;/tr>\r\n       &lt;/tbody>\r\n     &lt;/table>\r\n  &lt;/div></code></pre>\n\n\n\n<h2>product.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import {Product} from './Product'\r\nimport { of, Observable, throwError} from 'rxjs';\r\nimport { delay, map } from 'rxjs/internal/operators';\r\n \r\nexport class ProductService{\r\n \r\n    products: Product&#91;];\r\n    \r\n    public constructor() {\r\n        this.products=&#91;\r\n            new Product(1,'Memory Card',500),\r\n            new Product(2,'Pen Drive',750),\r\n            new Product(3,'Power Bank',100),\r\n            new Product(4,'Computer',100),\r\n            new Product(5,'Laptop',100),\r\n            new Product(6,'Printer',100),\r\n        ]\r\n    }\r\n \r\n    public getProducts(): Observable&lt;Product&#91;]> {\r\n        return of(this.products) ;\r\n    }\r\n \r\n    public getProduct(id): Observable&lt;Product> {\r\n        var Product= this.products.find(i => i.productID==id)\r\n        return of(Product) ;\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<h2>product.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>export class Product { \r\n \r\n    constructor(productID:number,    name: string ,   price:number) {\r\n        this.productID=productID;\r\n        this.name=name;\r\n        this.price=price;\r\n    }\r\n \r\n    productID:number ;\r\n    name: string ;\r\n    price:number;\r\n \r\n}\r\n </code></pre>\n\n\n\n<h3>Other Component</h3>\n\n\n\n<h2>app.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { Component } from '@angular/core';\r\nimport { AuthService } from './auth.service';\r\nimport { Router } from '@angular/router';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html'\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Route Guards Demo';\r\n \r\n  constructor (private authService:AuthService, \r\n               private router:Router) {\r\n  }\r\n \r\n  logout() {\r\n    this.authService.logoutUser();\r\n    this.router.navigate(&#91;'home']);\r\n  }\r\n \r\n}</code></pre>\n\n\n\n<h2>app.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n&lt;div class=\"container\">\r\n \r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n    &lt;ul class=\"nav navbar-nav\">\r\n \r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'login']\">Login&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"\" (click)=\"logout()\">Log out&lt;/a>&lt;/li>\r\n        \r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n \r\n &lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;/div>\r\n </code></pre>\n\n\n\n<h2>home.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}</code></pre>\n\n\n\n<h2>contact.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n     template: `&lt;h1>Contact Us&lt;/h1>\r\n                &lt;p>TekTutorialsHub &lt;/p>\r\n                `\r\n})\r\nexport class ContactComponent {\r\n}</code></pre>\n\n\n\n<h3>CanActivate Guard</h3>\n\n\n\n<p>Finally, we build a&nbsp;<code>CanActivate</code>&nbsp;guard, which will check whether the users are logged in or not. If users are not logged in, then they are redirected to the login page.</p>\n\n\n\n<h2>auth-guard.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot, UrlTree } from '@angular/router';\r\nimport { AuthService } from './auth.service';\r\n \r\n \r\n@Injectable()\r\nexport class AuthGuardService implements CanActivate {\r\n \r\n    constructor(private router:Router, private authService: AuthService ) {\r\n \r\n    }\r\n \r\n    canActivate(route: ActivatedRouteSnapshot,\r\n                state: RouterStateSnapshot): boolean|UrlTree {\r\n \r\n        if (!this.authService.isUserLoggedIn()) {\r\n            alert('You are not allowed to view this page. You are redirected to login Page');\r\n            \r\n            this.router.navigate(&#91;\"login\"],{ queryParams: { retUrl: route.url} });\r\n            return false;\r\n \r\n            //var urlTree = this.router.createUrlTree(&#91;'login']);\r\n            //return urlTree;\r\n        } \r\n \r\n        return true;\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<p>First, we import the&nbsp;<code>CanActivate</code>&nbsp;from the&nbsp;<code>@angular/router</code>&nbsp;module.</p>\n\n\n\n<p>The&nbsp;<code>AuthGuardService</code>&nbsp;implements the&nbsp;<code>CanActivate</code>&nbsp;interface</p>\n\n\n\n<p>Inject the&nbsp;<code>AuthServce</code>&nbsp;in the constructor of the Guard</p>\n\n\n\n<p>In the&nbsp;<code>CanActivate</code>&nbsp;method, we will redirect the user the login page, if the user is not logged in. To cancel the navigation ,we must either return&nbsp;<code>false</code>&nbsp;or&nbsp;<code>urlTree</code>&nbsp;as shown in the example above.</p>\n\n\n\n<p>Next, we will update the route definition and use the guard in all the routes, which we want to protect</p>\n\n\n\n<h2>app.routes.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\n \r\nimport { AuthGuardService } from './auth-guard.service';\r\nimport { LoginComponent } from './login.component';\r\n \r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'login', component:LoginComponent},\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent, canActivate : &#91;AuthGuardService] },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n];</code></pre>\n\n\n\n<p>Finally, register the service in the&nbsp;<code>app.module</code>.</p>\n\n\n\n<h2>app.module.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { HttpModule } from '@angular/http';\r\nimport { FormsModule }    from '@angular/forms';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\n \r\nimport { AuthGuardService } from './auth-guard.service';\r\n \r\nimport { appRoutes } from './app.routes';\r\nimport { AuthService } from './auth.service';\r\nimport { LoginComponent } from './login.component';\r\nimport { ProductService } from './product.service';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,ProductComponent,LoginComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;AuthGuardService,AuthService, ProductService],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }\r\n </code></pre>\n\n\n\n<p>Run the app. You can access the Product page only if you login as shown in the image below.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/05/Angular-CanActivateRoute-Example.gif\" alt=\"Angular CanActivate guard Example\" class=\"wp-image-12120\"/></figure>\n\n\n\n<p></p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>What is CanActivate Guard The Angular CanActivate guard decides, if a&nbsp;route&nbsp;can be activated ( or component gets rendered). We use this guard, when we want to check on some condition, before activating the component or showing it to the user. This allows us to cancel the navigation. Use cases for the CanActivate Guard Checking if [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3690" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3690"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3690/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3856,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3690/revisions/3856"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3690"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3690"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3690"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3693,
    "date": "2020-12-08T05:36:29",
    "date_gmt": "2020-12-08T05:36:29",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3693" },
    "modified": "2020-12-09T07:12:34",
    "modified_gmt": "2020-12-09T07:12:34",
    "slug": "angular-canactivatechild-example",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-canactivatechild-example/",
    "title": { "rendered": "Angular CanActivateChild Example" },
    "content": {
      "rendered": "\n<h2>What is CanActivateChild Guard</h2>\n\n\n\n<p>The&nbsp;<code>CanActivatechild</code>&nbsp;guard is very similar to&nbsp;<code>CanActivateGuard</code>. We apply this guard to the parent route. The Angular invokes this guard whenever the user tris to navigate to any of its child route. This allows us check some condition and decide whether to proceed with the navigation or cancel it.</p>\n\n\n\n<h2>Difference between CanActivate &amp; CanActivateChild</h2>\n\n\n\n<p>Consider the following routes.</p>\n\n\n\n<p>The&nbsp;<code>ProductComponent</code>&nbsp;displays the list of product. We have attached the&nbsp;<code>canActivate</code>&nbsp;guard to the product route. The&nbsp;<code>canActivate</code>&nbsp;guard blocks the access to the route, if the user is not logged in. This guard protect both the&nbsp;<code>product</code>&nbsp;route and all its children.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n{ path: 'product', component: ProductComponent, canActivate : &#91;AuthGuardService],\r\n      children: &#91;\r\n      {  path: 'view/:id', component: ProductViewComponent  },\r\n      {  path: 'edit/:id', component: ProductEditComponent  },\r\n      {  path: 'add', component: ProductAddComponent }\r\n      ]  \r\n  },\r\n </code></pre>\n\n\n\n<p>Now, consider the case where we want all users to view the&nbsp;<code>ProductComponent</code>, but only the Admin user can view any of its child routes</p>\n\n\n\n<p>We can create another guard&nbsp;<code>ProductGuardService</code>&nbsp;which implements the&nbsp;<code>canActivate</code>&nbsp;guard and attach it to each of those child routes as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n{ path: 'product', component: ProductComponent, canActivate : &#91;AuthGuardService],\r\n      children: &#91;\r\n      {  path: 'view/:id', component: ProductViewComponent, canActivate : &#91;ProductGuardService]  },\r\n      {  path: 'edit/:id', component: ProductEditComponent, canActivate : &#91;ProductGuardService]  },\r\n      {  path: 'add', component: ProductAddComponent, canActivate : &#91;ProductGuardService] }\r\n      ]  \r\n  },</code></pre>\n\n\n\n<p>Another way is to use the&nbsp;<code>CanActivateChild</code>&nbsp;guard and attach it to the product route as shown below. When Angular sees a&nbsp;<code>canActivateChild</code>&nbsp;guard attached to the parent route, it invokes it every time the user tries to navigates to the child route. Hence instead of attaching Guard service every child, you can attach it to the parent route.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: 'product', component: ProductComponent, canActivate : &#91;AuthGuardService], \r\ncanActivateChild : &#91;AdminGuardService],\r\n      children: &#91;\r\n      {  path: 'view/:id', component: ProductViewComponent  },\r\n      {  path: 'edit/:id', component: ProductEditComponent  },\r\n      {  path: 'add', component: ProductAddComponent }\r\n      ]  \r\n  },</code></pre>\n\n\n\n<h2>How to Create CanActivateChild Guard</h2>\n\n\n\n<p>Just like all other&nbsp;Angular Guards, we need to create an&nbsp;Angular Service. The service must import &amp; implement the&nbsp;<code>CanActivateChild</code>&nbsp;Interface. The Interface is defined in the&nbsp;<code>@angular/router module</code>. The Interface has one method i.e.&nbsp;<code>canActivateChild</code>. The details of the&nbsp;<code>CanActivateChild</code>&nbsp;interface are as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> interface CanActivateChild {\r\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree> | Promise&lt;boolean | UrlTree> | boolean | UrlTree\r\n}\r\n </code></pre>\n\n\n\n<p>The method gets the instance of the&nbsp;<code>ActivatedRouteSnapshot</code>&nbsp;&amp;&nbsp;<code>RouterStateSnapshot</code>. We can use this to get access to the route parameter, query parameter, etc.</p>\n\n\n\n<p>The guard must return true/false or a&nbsp;UrlTree&nbsp;. It can return these value either as a observable or a promise or as a simple Boolean value.</p>\n\n\n\n<p>If all guards return&nbsp;<code>true</code>, navigation will continue.</p>\n\n\n\n<p>If any guard returns&nbsp;<code>false</code>, navigation will be cancelled.</p>\n\n\n\n<p>If any guard returns a&nbsp;<code>UrlTree</code>, current navigation will be cancelled and a new navigation will be kicked off to the&nbsp;<code>UrlTree</code>&nbsp;returned from the guard.</p>\n\n\n\n<p>The example&nbsp;<code>canActivateChild</code>&nbsp;guard is as follows</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\n \r\n \r\n@Injectable()\r\nexport class AuthGuardService implements CanActivateChild {\r\n \r\n    constructor(private _router:Router ) {\r\n    }\r\n \r\n    canActivate(route: ActivatedRouteSnapshot,\r\n                state: RouterStateSnapshot): boolean {\r\n \r\n        //check some condition  \r\n        if (someCondition)  {\r\n            alert('You are not allowed to view this page');\r\n            //redirect to login/home page etc\r\n            //return false to cancel the navigation\r\n            return false;\r\n        } \r\n        return true;\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<h2 id=\"mce_20\">Angular CanActivateChild Example</h2>\n\n\n\n<p>In our example application, the&nbsp;<code>HomeComponent</code>&nbsp;&amp;&nbsp;<code>ContactComponent</code>&nbsp;are not protected and can be accessed any user.</p>\n\n\n\n<p>The user must log in into the system to access the&nbsp;<code>ProductComponent</code>..</p>\n\n\n\n<p>The ProdudctEditComponent, ProductViewComponets are child components of the ProductComponent</p>\n\n\n\n<p>We also need a&nbsp;<code>LoginComponent</code>&nbsp;to handle the user login.</p>\n\n\n\n<h2>login.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\nimport { FormControl, FormGroup } from '@angular/forms';\r\nimport { Router, ActivatedRoute } from '@angular/router';\r\nimport { AuthService } from './auth.service';\r\n \r\n@Component({\r\n   templateUrl: './login.component.html',\r\n   styles: &#91;``]\r\n})\r\nexport class LoginComponent implements OnInit { \r\n \r\n    invalidCredentialMsg: string;\r\n    username:string;\r\n    password:string;\r\n    retUrl:string=\"home\";\r\n \r\n    constructor(private authService: AuthService, \r\n                private router: Router, \r\n                private activatedRoute:ActivatedRoute) {\r\n    }\r\n \r\n    ngOnInit() {\r\n        this.activatedRoute.queryParamMap\r\n                .subscribe(params => {\r\n            this.retUrl = params.get('retUrl'); \r\n            console.log( 'LoginComponent/ngOnInit '+ this.retUrl);\r\n        });\r\n    }\r\n \r\n    onFormSubmit(loginForm) {\r\n       this.authService.login(loginForm.value.username, loginForm.value.password).subscribe(data => {\r\n           console.log( 'return to '+ this.retUrl);\r\n           if (this.retUrl!=null) {\r\n                this.router.navigate( &#91;this.retUrl]);\r\n           } else {\r\n                this.router.navigate( &#91;'home']);\r\n           }\r\n       });\r\n    }\r\n} \r\n </code></pre>\n\n\n\n<h2>login.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;h3>Login Form&lt;/h3>\r\n \r\n&lt;div>\r\n &lt;form #loginForm=\"ngForm\" (ngSubmit)=\"onFormSubmit(loginForm)\">\r\n   &lt;p>User Name: &lt;input type='text'  name='username' ngModel>&lt;/p>\r\n   &lt;p>Password: &lt;input type=\"password\"  name=\"password\" ngModel>&lt;/p>\r\n   &lt;p>&lt;button type=\"submit\">Submit&lt;/button>&lt;/p> \r\n &lt;/form>\r\n&lt;/div> </code></pre>\n\n\n\n<h2>auth.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\nimport { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport 'rxjs/add/observable/of';\r\nimport 'rxjs/add/operator/map';\r\nimport { of } from 'rxjs';\r\n \r\n \r\n@Injectable()\r\nexport class AuthService { \r\n \r\n    private isloggedIn: boolean;\r\n    private userName:string;\r\n \r\n    constructor() {\r\n        this.isloggedIn=false;\r\n    }\r\n \r\n    login(username: string, password:string) {\r\n \r\n        //Assuming users are provided the correct credentials.\r\n        //In real app you will query the database to verify.\r\n        this.isloggedIn=true;\r\n        this.userName=username;\r\n        return of(this.isloggedIn);\r\n    }\r\n \r\n    isUserLoggedIn(): boolean {\r\n        return this.isloggedIn;\r\n    }\r\n \r\n    isAdminUser():boolean {\r\n        if (this.userName=='Admin') {\r\n            return true; \r\n        }\r\n        return false;\r\n    }\r\n    \r\n    logoutUser(): void{\r\n        this.isloggedIn = false;\r\n    }\r\n \r\n} </code></pre>\n\n\n\n<p>The&nbsp;<code>AuthService</code>&nbsp;checks whether the user is allowed to login. It has the method to&nbsp;<code>login</code>&nbsp;&amp;&nbsp;<code>logout</code>&nbsp;the users. Our implementation of the&nbsp;<code>login</code>&nbsp;method does not check for anything. It just marks the user as logged in.&nbsp;<code>isAdminUser()</code>&nbsp;method returns true if the user is logged in with the user name “Admin”.</p>\n\n\n\n<h3>Product Component</h3>\n\n\n\n<p>The&nbsp;<code>ProductComponent</code>&nbsp;is our protected component. Only the logged in users can access this. This component displays the list of Products, which it gets from the&nbsp;<code>ProductService</code>.</p>\n\n\n\n<h2>product.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Component, OnInit } from '@angular/core';\r\nimport { ProductService } from './product.service';\r\nimport { Product } from './Product';\r\n \r\n \r\n@Component({\r\n  templateUrl: \"product.component.html\",\r\n})\r\nexport class ProductComponent\r\n{\r\n \r\n   products:Product&#91;];\r\n   constructor(private productService: ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n \r\n      this.productService.getProducts()\r\n        .subscribe(data => {\r\n          this.products=data;\r\n        })\r\n   }\r\n  \r\n}</code></pre>\n\n\n\n<h2>product.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;h1>Product List&lt;/h1>\r\n   &lt;p> This is a protected component &lt;/p>\r\n \r\n   &lt;div class='table-responsive'>\r\n   &lt;table class='table'>\r\n       &lt;thead>\r\n           &lt;tr>\r\n               &lt;th>Name&lt;/th>\r\n               &lt;th>Price&lt;/th>\r\n               &lt;th>&lt;/th>\r\n               &lt;th>&lt;/th>\r\n           &lt;/tr>\r\n       &lt;/thead>\r\n       &lt;tbody>\r\n           &lt;tr *ngFor=\"let product of products;\">\r\n               &lt;td>&lt;a &#91;routerLink]=\"&#91;'/product/view',product.productID]\">{{product.name}}&lt;/a>&lt;/td>\r\n               &lt;td>{{product.price}}&lt;/td>\r\n               &lt;td>&lt;a &#91;routerLink]=\"&#91;'/product/view',product.productID]\">View&lt;/a>&lt;/td>\r\n               &lt;td>&lt;a &#91;routerLink]=\"&#91;'/product/edit',product.productID]\">Edit&lt;/a>&lt;/td>\r\n           &lt;/tr>\r\n       &lt;/tbody>\r\n     &lt;/table>\r\n  &lt;/div>\r\n \r\n  &lt;router-outlet>&lt;/router-outlet></code></pre>\n\n\n\n<h2>product.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import {Product} from './Product'import { of, Observable, thrimport {Product} from './Product'\r\nimport { of, Observable, throwError} from 'rxjs';\r\nimport { delay, map } from 'rxjs/internal/operators';\r\n \r\nexport class ProductService{\r\n \r\n    products: Product&#91;];\r\n    \r\n    public constructor() {\r\n        this.products=&#91;\r\n            new Product(1,'Memory Card',500),\r\n            new Product(2,'Pen Drive',750),\r\n            new Product(3,'Power Bank',100),\r\n            new Product(4,'Computer',100),\r\n            new Product(5,'Laptop',100),\r\n            new Product(6,'Printer',100),\r\n        ]\r\n    }\r\n \r\n    public getProducts(): Observable&lt;Product&#91;]> {\r\n        return of(this.products) ;\r\n    }\r\n \r\n    public getProduct(id): Observable&lt;Product> {\r\n        var Product= this.products.find(i => i.productID==id)\r\n        return of(Product);\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<h2>product.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> export class Product { \r\n \r\n    constructor(productID:number,    name: string ,   price:number) {\r\n        this.productID=productID;\r\n        this.name=name;\r\n        this.price=price;\r\n    }\r\n \r\n    productID:number ;\r\n    name: string ;\r\n    price:number;\r\n \r\n}\r\n </code></pre>\n\n\n\n<p>We have Product add, edit &amp; view components.</p>\n\n\n\n<h2>product-add.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\nimport { Product } from './Product';\r\nimport { ProductService } from './product.service';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n \r\n \r\n@Component({\r\n  template: `&lt;h1>Add Product&lt;/h1>`,\r\n})\r\nexport class ProductAddComponent\r\n{\r\n \r\n  product:Product;\r\n \r\n  constructor(private productService: ProductService, \r\n              private route:ActivatedRoute ){\r\n  }\r\n \r\n \r\n  ngOnInit() {\r\n  }\r\n  \r\n}</code></pre>\n\n\n\n<h2>product-edit.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Component, OnInit } from '@angular/core';\r\nimport { Product } from './Product';\r\nimport { ProductService } from './product.service';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n \r\n@Component({\r\n  template: `&lt;h1>Edit Product&lt;/h1>`,\r\n})\r\nexport class ProductEditComponent\r\n{\r\n \r\n    product:Product\r\n \r\n    constructor(private productService: ProductService, \r\n                private route:ActivatedRoute ){\r\n    }\r\n \r\n \r\n    ngOnInit() {\r\n \r\n    let id=this.route.snapshot.params&#91;'id'];\r\n \r\n    this.productService.getProduct(id)\r\n        .subscribe(data => {\r\n            this.product=data;\r\n        })\r\n    }\r\n}</code></pre>\n\n\n\n<h2>product-view.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component, OnInit } from '@angular/core';\r\nimport { Product } from './Product';\r\nimport { ProductService } from './product.service';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n \r\n@Component({\r\n  template: `&lt;h1>View Product&lt;/h1>`,\r\n})\r\nexport class ProductViewComponent\r\n{\r\n \r\n    product:Product\r\n \r\n    constructor(private productService: ProductService, \r\n                private route:ActivatedRoute ){\r\n    }\r\n \r\n \r\n    ngOnInit() {\r\n \r\n        \r\n        let id=this.route.snapshot.params&#91;'id'];\r\n \r\n        this.productService.getProduct(id)\r\n            .subscribe(data => {\r\n                this.product=data;\r\n            })\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<h3>Other Components</h3>\n\n\n\n<h2>app.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\nimport { AuthService } from './auth.service';\r\nimport { Router } from '@angular/router';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html'\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Route Guards Demo';\r\n \r\n  constructor (private authService:AuthService, \r\n               private router:Router) {\r\n  }\r\n \r\n  logout() {\r\n    this.authService.logoutUser();\r\n    this.router.navigate(&#91;'home']);\r\n  }\r\n \r\n}\r\n </code></pre>\n\n\n\n<h2>app.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n&lt;div class=\"container\">\r\n \r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n    &lt;ul class=\"nav navbar-nav\">\r\n \r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\">Product&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'login']\">Login&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"\" (click)=\"logout()\">Log out&lt;/a>&lt;/li>\r\n        \r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n \r\n &lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;/div></code></pre>\n\n\n\n<h2>home.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}\r\n </code></pre>\n\n\n\n<h2>contact.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n     template: `&lt;h1>Contact Us&lt;/h1>\r\n                &lt;p>TekTutorialsHub &lt;/p>\r\n                `\r\n})\r\nexport class ContactComponent {\r\n}\r\n </code></pre>\n\n\n\n<h2>CanActivateChild Guard</h2>\n\n\n\n<p>Next, we will build&nbsp;<code>CanActivate</code>&nbsp;guard, which will check whether the users are logged in or not. The users are redirected to the login page, if they are not logged in.</p>\n\n\n\n<p>Also,&nbsp;<code>CanActivateChild</code>&nbsp;guard, which checks whether the user is&nbsp;<code>Admin User</code>. Only the&nbsp;<code>Admin Users</code>&nbsp;are allowed to navigate to the&nbsp;<code>ProductEditComponent</code>&nbsp;&amp;&nbsp;<code>ProductViewComponent</code>.</p>\n\n\n\n<h2>auth-guard.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { Injectable } from '@angular/core';\r\nimport { Router, CanActivate, ActivatedRouteSnapshot,RouterStateSnapshot, UrlTree, CanActivateChild } from '@angular/router';\r\nimport { AuthService } from './auth.service';\r\n \r\n \r\n@Injectable()\r\nexport class AuthGuardService implements CanActivate , CanActivateChild {\r\n \r\n    constructor(private router:Router, private authService: AuthService ) {\r\n \r\n    }\r\n \r\n    canActivate(route: ActivatedRouteSnapshot,\r\n                state: RouterStateSnapshot): boolean|UrlTree {\r\n \r\n        console.log('canActivate on '+route.url);\r\n \r\n        if (!this.authService.isUserLoggedIn()) {\r\n            alert('You are not allowed to view this page. You are redirected to login Page');\r\n            this.router.navigate(&#91;\"login\"],{ queryParams: { retUrl: route.url } });\r\n            return false;\r\n \r\n            //var urlTree = this.router.createUrlTree(&#91;'login']);\r\n            //return urlTree;\r\n        } \r\n \r\n        return true;\r\n    }\r\n \r\n    canActivateChild(route: ActivatedRouteSnapshot,\r\n                    state: RouterStateSnapshot): boolean|UrlTree {\r\n \r\n \r\n        \r\n        if (!this.authService.isAdminUser()) {\r\n            alert('You are not allowed to view this page');\r\n            return false;\r\n        }\r\n \r\n \r\n        return true;\r\n}\r\n \r\n}</code></pre>\n\n\n\n<p>First, we import the&nbsp;<code>CanActivate</code>&nbsp;and&nbsp;<code>CanActivateChild</code>&nbsp;from the&nbsp;<code>@angular/router</code>&nbsp;module.</p>\n\n\n\n<p>The&nbsp;<code>AuthGuardService</code>&nbsp;implements both&nbsp;<code>CanActivate</code>&nbsp;&amp;&nbsp;<code>CanActivateChild</code>&nbsp;interface</p>\n\n\n\n<p>Inject the&nbsp;<code>AuthServce</code>&nbsp;in the constructor of the Guard</p>\n\n\n\n<p>In the&nbsp;<code>CanActivate</code>&nbsp;method, we will redirect the user the login page, if the user is not logged in. To cancel the navigation ,we must either return&nbsp;<code>false</code>&nbsp;or&nbsp;<code>urlTree</code>&nbsp;as shown in the example above.</p>\n\n\n\n<p>While in&nbsp;<code>CanActivateChild</code>&nbsp;method, we just check if the user is Admin, the we will return true else return false</p>\n\n\n\n<p>Next, we will update the route definition and use the guard in all the routes, which we want to protect</p>\n\n\n\n<h2>app.routes.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent } from './product.component'\r\n \r\nimport { AuthGuardService } from './auth-guard.service';\r\nimport { LoginComponent } from './login.component';\r\nimport { ProductViewComponent } from './product-view.component';\r\nimport { ProductAddComponent } from './product-add.component';\r\nimport { ProductEditComponent } from './product-edit.component';\r\n \r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'login', component:LoginComponent},\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product', component: ProductComponent, canActivate : &#91;AuthGuardService] ,\r\n      canActivateChild : &#91;AuthGuardService],\r\n      children: &#91;\r\n      {  path: 'view/:id', component: ProductViewComponent  },\r\n      {  path: 'edit/:id', component: ProductEditComponent  },\r\n      {  path: 'add', component: ProductAddComponent }\r\n      ]  \r\n  },\r\n \r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n];\r\n \r\n </code></pre>\n\n\n\n<h2>app.module.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { HttpModule } from '@angular/http';\r\nimport { FormsModule }    from '@angular/forms';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\nimport { ProductComponent} from './product.component'\r\n \r\nimport { AuthGuardService } from './auth-guard.service';\r\n \r\nimport { appRoutes } from './app.routes';\r\nimport { AuthService } from './auth.service';\r\nimport { LoginComponent } from './login.component';\r\nimport { ProductAddComponent } from './product-add.component';\r\nimport { ProductViewComponent } from './product-view.component';\r\nimport { ProductEditComponent } from './product-edit.component';\r\nimport { ProductService } from './product.service';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,ProductComponent,LoginComponent, ProductAddComponent, ProductViewComponent, ProductEditComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;AuthGuardService,AuthService,ProductService],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<p>We apply both the guards on the product route. The&nbsp;<code>canActivate</code>&nbsp;guards protects the product route and&nbsp;<code>canActivateChild</code>&nbsp;protects all it child routes.</p>\n\n\n\n<p>Run the app. You can access the Product page only if you login as shown in the image below.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/05/Angular-CanActivateChild-Guard-Example.gif\" alt=\"Angular CanActivateChilld Guard Example\" class=\"wp-image-12181\"/></figure>\n\n\n\n<p></p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>What is CanActivateChild Guard The&nbsp;CanActivatechild&nbsp;guard is very similar to&nbsp;CanActivateGuard. We apply this guard to the parent route. The Angular invokes this guard whenever the user tris to navigate to any of its child route. This allows us check some condition and decide whether to proceed with the navigation or cancel it. Difference between CanActivate &amp; [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3693" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3693"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3693/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3857,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3693/revisions/3857"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3693"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3693"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3693"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3696,
    "date": "2020-12-08T05:41:52",
    "date_gmt": "2020-12-08T05:41:52",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3696" },
    "modified": "2020-12-09T07:16:38",
    "modified_gmt": "2020-12-09T07:16:38",
    "slug": "angular-candeactivate-guard",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-candeactivate-guard/",
    "title": { "rendered": "Angular CanDeactivate Guard" },
    "content": {
      "rendered": "\n<h2 id=\"0-what-is-candeactivate-guard\">What is CanDeactivate Guard</h2>\n\n\n\n<p>The Angular CanDeactivate guard is called, whenever we navigate away from the route before the current component gets deactivated.</p>\n\n\n\n<p>The best use case for&nbsp;<code>CanDectivate</code>&nbsp;guard is the data entry component. The user may have filled the data entry and tries to leave that component without saving his work. The&nbsp;<code>CanDeactivate</code>&nbsp;guard gives us a chance to warn the user that he has not saved his work and give him a chance to cancel the navigation.</p>\n\n\n\n<h2 id=\"1-how-to-use-candeactivate-guard\">How to use CanDeactivate Guard</h2>\n\n\n\n<p>First, we need to create an&nbsp;Angular Service.</p>\n\n\n\n<p>The service must import &amp; implement the&nbsp;<code>CanDeactivate</code>&nbsp;Interface. This Interface is defined in the&nbsp;<code>@angular/router</code>&nbsp;module. The Interface has one method i.e.&nbsp;<code>canDeactivate</code>. We need to implement it in our Service. The details of the&nbsp;<code>CanDeactivate</code>&nbsp;interface is as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>interface CanDeactivate&lt;T> {\r\n  canDeactivate(component: T, \r\n                currentRoute: ActivatedRouteSnapshot, \r\n                currentState: RouterStateSnapshot, \r\n                nextState?: RouterStateSnapshot): Observable&lt;boolean | UrlTree> | Promise&lt;boolean | UrlTree> | boolean | UrlTree\r\n}</code></pre>\n\n\n\n<p>The method gets the instance of the component being deactivated as the first argument.</p>\n\n\n\n<p>The method also gets the instance of the&nbsp;<code>ActivatedRouteSnapshot</code>, the current state of the&nbsp;&nbsp;<code>RouterStateSnapshot</code>, next state of the&nbsp;<code>RouterStateSnapshot</code>. We can use this to get access to the route parameter, query parameter, etc.</p>\n\n\n\n<p>The guard must return&nbsp;<strong>true/false</strong>&nbsp;or a&nbsp;UrlTree&nbsp;. The return value can be in the form of&nbsp;<strong>observable</strong>&nbsp;or a&nbsp;<strong>promise</strong>&nbsp;or a simple&nbsp;<code>boolean</code>&nbsp;value.</p>\n\n\n\n<p>A route can have more than one&nbsp;<code>canDeactivate</code>&nbsp;guard.</p>\n\n\n\n<p>If&nbsp;<strong>all guards</strong>&nbsp;return&nbsp;<code>true</code>, the component will get deactivated and you will navigate to the next route.</p>\n\n\n\n<p>If&nbsp;<strong>anyone of the guard&nbsp;returns&nbsp;false, navigation will be canceled</strong>&nbsp;and you will stay in the same route/component.</p>\n\n\n\n<p>If<strong>&nbsp;any one of the guards</strong>&nbsp;returns a&nbsp;<code>UrlTree</code>, current navigation will be canceled and new navigation will be kicked off to the&nbsp;<code>UrlTree</code>&nbsp;returned from the guard. The current component will get deactivated.</p>\n\n\n\n<p>The example of&nbsp;<code>canDeactivate</code>&nbsp;the guard is as follows</p>\n\n\n\n<h2 id=\"2-candeactivate-example\">CanDeactivate Example</h2>\n\n\n\n<p>First create a component, with a method&nbsp;<code>canExit</code>, which returns a boolean. In the&nbsp;<code>canExit</code>&nbsp;method, you can check if there are any unsaved data, etc. If Yes, then ask for confirmation whether the user wants to leave or not. Return true to exit the component else return false to stay in the same component.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\nimport { Component } from '@angular/core';\r\n \r\n@Component({\r\n  templateUrl: \"register.component.html\",\r\n})\r\nexport class RegisterComponent    \r\n \r\n   //Check if there any unsaved data etc. If yes then as for confirmation \r\n  canExit() : boolean {\r\n \r\n  if (confirm(\"Do you wish to Please confirm\")) {\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  \r\n}</code></pre>\n\n\n\n<p>Next, create a guard service, which implements the&nbsp;<code>CanDeactivate</code>&nbsp;Interface.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Injectable } from '@angular/core';\r\nimport { CanDeactivate } from '@angular/router/src/utils/preactivation';\r\nimport { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\r\nimport { Observable } from 'rxjs';\r\nimport { RegisterComponent } from './register.component';\r\n \r\n@Injectable()\r\nexport class DeactivateGuard implements CanDeactivate \r\n{\r\n    component: Object;\r\n    route: ActivatedRouteSnapshot;\r\n \r\n   constructor(){\r\n   }\r\n \r\n   canDeactivate(component:RegisterComponent,\r\n                route: ActivatedRouteSnapshot, \r\n                state: RouterStateSnapshot,\r\n                nextState: RouterStateSnapshot) : Observable&lt;boolean> | Promise&lt;boolean> | boolean {\r\n        \r\n        return component.canExit();\r\n \r\n  }\r\n  \r\n}</code></pre>\n\n\n\n<p>Update the route definition with the&nbsp;<code>canDeactivate</code>&nbsp;guard as shown below. You can apply more than one guard to a route and a route can have more than one guard</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{ path: 'register', component: RegisterComponent, canDeactivate:&#91;DeactivateGuard] }, </code></pre>\n\n\n\n<p>The guard created in the above example is specific to&nbsp;<code>RegisterComponent</code>. We can create a general-purpose&nbsp;<code>DeactivateGuard</code>&nbsp;Service and use it everywhere, by making use of the interface</p>\n\n\n\n<h3 id=\"3-general-purpose-deactivateguard-service\">General Purpose DeactivateGuard Service</h3>\n\n\n\n<p>First Define an Interface&nbsp;<code>IDeactivateComponent</code>&nbsp;as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code> export interface IDeactivateComponent {\r\n    canExit: () => Observable&lt;boolean> | Promise&lt;boolean> | boolean;\r\n}\r\n </code></pre>\n\n\n\n<p>Next, Open the component, where you wish to implement the Deactivate Guard. In our case it is&nbsp;<code>RegisterComponent</code>. Make the component implement the&nbsp;<code>IDeactivateComponent</code>&nbsp;as shown below. Implement the&nbsp;<code>canExit</code>&nbsp;method</p>\n\n\n\n<pre class=\"wp-block-code\"><code> import { Component } from '@angular/core';\r\nimport { IDeactivateComponent } from './decativate.guard';\r\n \r\n \r\n@Component({\r\n  templateUrl: \"register.component.html\",\r\n})\r\nexport class RegisterComponent implements IDeactivateComponent\r\n{\r\n \r\n   //Check if there any unsaved data etc. If yes then as for confirmation \r\n  canExit() : boolean {\r\n \r\n  if (confirm(\"Do you wish to Please confirm\")) {\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  \r\n}</code></pre>\n\n\n\n<p>Now, in the guard service, use the&nbsp;<code>IDeactivateComponent</code>&nbsp;interface instead of the actual component.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\n@Injectable()\r\nexport class DeactivateGuard implements CanDeactivate \r\n{\r\n    component: Object;\r\n    route: ActivatedRouteSnapshot;\r\n \r\n   constructor(){\r\n   }\r\n \r\n   canDeactivate(component:IDeactivateComponent,\r\n                route: ActivatedRouteSnapshot, \r\n                state: RouterStateSnapshot,\r\n                nextState: RouterStateSnapshot) : Observable&lt;boolean> | Promise&lt;boolean> | boolean {\r\n        \r\n        return component.canExit ? component.canExit() : true;\r\n  }\r\n \r\n}</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/08/Angular-CanDeactivate-Guard-Example.gif\" alt=\"\" class=\"wp-image-12286\"/></figure>\n\n\n\n<h2 id=\"4-complete-source-code\">Complete Source Code</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\t&lt;div class=\"container\">\r\n \r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n    &lt;ul class=\"nav navbar-nav\">\r\n \r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'register']\">Register&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n        \r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n \r\n &lt;router-outlet>&lt;/router-outlet>\r\n \r\n&lt;/div></code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n \r\nimport { Component } from '@angular/core';\r\nimport { Router } from '@angular/router';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html'\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Route Guards Demo';\r\n \r\n  constructor (private router:Router) {\r\n  }\r\n \r\n \r\n}\r\n \n </code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { HttpModule } from '@angular/http';\r\nimport { FormsModule }    from '@angular/forms';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\n \r\n \r\n \r\nimport { appRoutes } from './app.routes';\r\n \r\nimport { RegisterComponent } from './register.component';\r\nimport { DeactivateGuard } from './decativate.guard';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,RegisterComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;DeactivateGuard],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Routes } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\n \r\n \r\nimport { RegisterComponent } from './register.component';\r\nimport { DeactivateGuard } from './decativate.guard';\r\n \r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'register', component: RegisterComponent, canDeactivate:&#91;DeactivateGuard] },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n];\r\n \r\n </code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Injectable } from '@angular/core';\r\nimport { CanDeactivate } from '@angular/router/src/utils/preactivation';\r\nimport { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\r\nimport { Observable } from 'rxjs';\r\nimport { RegisterComponent } from './register.component';\r\n \r\nexport interface IDeactivateComponent {\r\n    canExit: () => Observable&lt;boolean> | Promise&lt;boolean> | boolean;\r\n}\r\n \r\n@Injectable()\r\nexport class DeactivateGuard implements CanDeactivate \r\n{\r\n    component: Object;\r\n    route: ActivatedRouteSnapshot;\r\n \r\n   constructor(){\r\n   }\r\n \r\n   canDeactivate(component:IDeactivateComponent,\r\n                route: ActivatedRouteSnapshot, \r\n                state: RouterStateSnapshot,\r\n                nextState: RouterStateSnapshot) : Observable&lt;boolean> | Promise&lt;boolean> | boolean {\r\n        \r\n        return component.canExit ? component.canExit() : true;\r\n  }\r\n \r\n  \r\n}\r\n </code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n     template: `&lt;h1>Contact Us&lt;/h1>\r\n                &lt;p>TekTutorialsHub &lt;/p>\r\n                `\r\n})\r\nexport class ContactComponent {\r\n}</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\nimport { IDeactivateComponent } from './decativate.guard';\r\n \r\n \r\n@Component({\r\n  template: `&lt;h1>Register User&lt;/h1>\r\n          &lt;p> &lt;/p>`,\r\n})\r\nexport class RegisterComponent    implements IDeactivateComponent\r\n{\r\n \r\n   //Check if there any unsaved data etc. If yes then as for confirmation \r\n  canExit() : boolean {\r\n \r\n  if (confirm(\"Do you wish to Please confirm\")) {\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  \r\n}</code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>What is CanDeactivate Guard The Angular CanDeactivate guard is called, whenever we navigate away from the route before the current component gets deactivated. The best use case for&nbsp;CanDectivate&nbsp;guard is the data entry component. The user may have filled the data entry and tries to leave that component without saving his work. The&nbsp;CanDeactivate&nbsp;guard gives us a [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3696" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3696"
        }
      ],
      "version-history": [
        {
          "count": 3,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3696/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3858,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3696/revisions/3858"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3696"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3696"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3696"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3700,
    "date": "2020-12-08T05:49:47",
    "date_gmt": "2020-12-08T05:49:47",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3700" },
    "modified": "2020-12-09T07:21:49",
    "modified_gmt": "2020-12-09T07:21:49",
    "slug": "angular-resolve-guard",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-resolve-guard/",
    "title": { "rendered": "Angular Resolve Guard" },
    "content": {
      "rendered": "\n<h2>Angular Resolve Guard</h2>\n\n\n\n<p>The Angular renders the&nbsp;Angular Component, when we navigate to a route. The component will then sends an&nbsp;HTTP request&nbsp;to back end server to fetch data so as to display it to the user. We generally do this in&nbsp;ngOnInit Life cycle hook</p>\n\n\n\n<p>The Problem with the above approach is that, the use will see a empty component. The component shows the data after the arrival of the data. The one way is solve this problem is to show some loading indicator</p>\n\n\n\n<p>The another way to solve this is to make use the Resolve Guard. The Resolve Guard pre fetches the data before the navigating to the route. Hence the component is rendered along with the data.</p>\n\n\n\n<h2>How to Use Resolve Guard</h2>\n\n\n\n<p>First, we need to create a&nbsp;Angular Service, which implements the&nbsp;<code>Resolve</code>&nbsp;Interface</p>\n\n\n\n<p>The service must implement the&nbsp;<code>resolve</code>&nbsp;method. A resolve method must return either a&nbsp;<code>Observable&lt;any&gt;</code>,&nbsp;<code>Promise&lt;any&gt;</code>&nbsp;or just data. The interface signature of the&nbsp;<code>Resolve</code>&nbsp;interface is as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\ninterface Resolve&lt;T> {\r\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;T> | Promise&lt;T> | T\r\n}</code></pre>\n\n\n\n<p>Inside the&nbsp;<code>Resolve</code>&nbsp;method, we will get the access to the&nbsp;<code>ActivatedRouteSnapshot</code>&nbsp;&amp;&nbsp;<code>RouterStateSnapshot</code>, which can be used to get the values of router parameter, query parameters etc.</p>\n\n\n\n<p>The following is the simple example of a Angular Resolver.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Injectable } from '@angular/core';\r\nimport { Resolve, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\nimport { ProductService } from './product.service';\r\nimport { Observable, of } from 'rxjs';\r\n \r\n@Injectable()\r\nexport class ProductListResolveService implements Resolve&lt;any>{\r\n \r\n    constructor(private _router:Router , private \r\n     productService:ProductService ) {\r\n    }\r\n \r\n    resolve(route: ActivatedRouteSnapshot,\r\n            state: RouterStateSnapshot): Observable&lt;any> {\r\n        \r\n        return this.productService.getProducts();\r\n    }\r\n}</code></pre>\n\n\n\n<p>First, we import the&nbsp;<code>Resolve</code>&nbsp;from the&nbsp;<code>@angular/router</code>&nbsp;module.</p>\n\n\n\n<p>We can make use of&nbsp;Angular Dependency Injection&nbsp;to inject the required services in the constructor.</p>\n\n\n\n<p>The&nbsp;<code>resolve</code>&nbsp;method must return either an&nbsp;<code>Observable&lt;any&gt;</code>, &nbsp;<code>Promise&lt;any&gt;</code>&nbsp;or just&nbsp;<strong>data</strong>. In the example above, we are invoking the&nbsp;<code>getProducts</code>&nbsp;method of method of the&nbsp;<code>productService</code>, which returns an observable.</p>\n\n\n\n<p>The router does not create the instance of the resolver. The job falls on the&nbsp;Angular dependency injection. Hence, we need it to register it in the&nbsp;Providers&nbsp;array of root module.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> providers: &#91;ProductListResolveGuardService] </code></pre>\n\n\n\n<p>Once the resolver is created, we need to update the route definition and add&nbsp;<code>resolve</code>&nbsp;property as shown in below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'product', component: ProductComponent, resolve: {products: ProductListResolveService}  }, </code></pre>\n\n\n\n<p>The&nbsp;<code>resolve</code>&nbsp;property is a JavaScript object of key value pair of&nbsp;<strong>resolvers</strong>. The&nbsp;<strong>key</strong>&nbsp;is user defined variable. The&nbsp;<strong>value</strong>&nbsp;must be a resolver service.</p>\n\n\n\n<p>In the example above&nbsp;<code>products</code>&nbsp;is the key and&nbsp;<code>ProductListResolveService</code>&nbsp;is the resolver. The return value of the&nbsp;<code>ProductListResolveService</code>&nbsp;is assigned to the key i.e&nbsp;<code>products</code>&nbsp;and made available to the component via&nbsp;<strong>route data</strong></p>\n\n\n\n<p>When the user navigates to the route&nbsp;<code>product</code>, the angular looks for the&nbsp;<code>resolve</code>&nbsp;property of the route.&nbsp;<strong>For each key value pair of resolvers</strong>, the angular calls the&nbsp;<code>resolve</code>&nbsp;method. If the return value of the resolver is a&nbsp;<code>observable</code>&nbsp;or a&nbsp;<code>promise</code>, the router will wait for that to complete. The returned value is assigned to the key&nbsp;<code>products</code>&nbsp;and added to the route data collection.</p>\n\n\n\n<p>The component can just read the&nbsp;<strong>products</strong>&nbsp;from the route data from the&nbsp;<code>ActivatedRoute</code>&nbsp;as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  \r\n   constructor(private route: ActivatedRoute){\r\n   }\r\n \r\n  ngOnInit() {\r\n      this.products=this.route.snapshot.data&#91;'products'];\r\n   }</code></pre>\n\n\n\n<p>Remember Resolve runs after all other guards are executed</p>\n\n\n\n<h3>Cancelling Navigation</h3>\n\n\n\n<p>If you return null from the resolver, the router will cancel the navigation</p>\n\n\n\n<p>If the error is generated, then the router will cancel the navigation.</p>\n\n\n\n<h3>Multiple Resolvers</h3>\n\n\n\n<p>You can define more than one resolver</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'product', component: ProductComponent,     resolve: {products: ProductListResolveService, , data:SomeOtherResolverService}  } </code></pre>\n\n\n\n<h2>Resolve Guard Example</h2>\n\n\n\n<p>Let us build a simple app to demonstrate the use of&nbsp;<code>Resolve</code>&nbsp;guard.</p>\n\n\n\n<h3>Product Service</h3>\n\n\n\n<p>The following is the simple&nbsp;<code>ProductService</code>, which retrieves the hard coded products.</p>\n\n\n\n<h2>product.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> import {Product} from './Product'\r\nimport { of, Observable, throwError} from 'rxjs';\r\nimport { delay, map } from 'rxjs/internal/operators';\r\n \r\nexport class ProductService{\r\n \r\n    products: Product&#91;];\r\n    \r\n    public constructor() {\r\n        this.products=&#91;\r\n            new Product(1,'Memory Card',500),\r\n            new Product(2,'Pen Drive',750),\r\n            new Product(3,'Power Bank',100),\r\n            new Product(4,'Computer',100),\r\n            new Product(5,'Laptop',100),\r\n            new Product(6,'Printer',100),\r\n        ]\r\n    }\r\n \r\n    //Return Products List with a delay \r\n    public getProducts(): Observable&lt;Product&#91;]> {\r\n        return of(this.products).pipe(delay(1500)) ;\r\n    }\r\n \r\n    // Returning Error\r\n    // This wil stop the route from getting Activated\r\n    //public getProducts(): Observable&lt;Product&#91;]> {\r\n    //    return of(this.products).pipe(delay(1500), map( data => {\r\n    //        throw throwError(\"errors occurred\") ;        \r\n    //    })) \r\n    //}\r\n \r\n    public getProduct(id): Observable&lt;Product> {\r\n        var Product= this.products.find(i => i.productID==id)\r\n        return of(Product).pipe(delay(1500)) ;\r\n    }\r\n}</code></pre>\n\n\n\n<h2>product.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nexport class Product { \r\n    constructor(productID:number,    name: string ,   price:number) \r\n   {\r\n        this.productID=productID;\r\n        this.name=name;\r\n        this.price=price;\r\n    }\r\n \r\n    productID:number ;\r\n    name: string ;\r\n    price:number;\r\n \r\n}</code></pre>\n\n\n\n<p>The&nbsp;<code>getProducts()</code>&nbsp;method returns the Observable of&nbsp;<code>products</code>&nbsp;using the RxJS operator&nbsp;<code>of</code>. We have included a&nbsp;<code>delay</code>&nbsp;of 1500 ms.</p>\n\n\n\n<p>Similarly, the&nbsp;<code>getProduct(id)</code>&nbsp;returns the observable of&nbsp;<code>Product</code>&nbsp;after a delay of 1500 ms.</p>\n\n\n\n<h3>Product Component without resolver</h3>\n\n\n\n<p>Next, let us build a two components to display the list of Products. The first component&nbsp;<code>Product1Component</code>&nbsp;does not use resolver. The second component&nbsp;<code>Product1Component</code>&nbsp;makes use of the resolver.</p>\n\n\n\n<p>This component, subscribes to the&nbsp;<code>getProducts()</code>&nbsp;method of the&nbsp;<code>ProductService</code>&nbsp;to get the list of Products</p>\n\n\n\n<h2>product1.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n@Component({\r\n  templateUrl: './product1.component.html',\r\n})\r\n \r\nexport class Product1Component\r\n{\r\n   public products:Product&#91;];\r\n   \r\n   constructor(private route: ActivatedRoute,private productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n       this.productService.getProducts().subscribe(data => {\r\n         this.products=data;\r\n      });\r\n   }\r\n \r\n}</code></pre>\n\n\n\n<h3>Resolve Guard</h3>\n\n\n\n<p>The&nbsp;<code>ProductListResolverService</code>&nbsp;service implements the&nbsp;<code>Resolve</code>&nbsp;Interface. It just returns the&nbsp;<code>productService.getProducts()</code>.</p>\n\n\n\n<h2>product.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Resolve, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\nimport { ProductService } from './product.service';\r\nimport { Observable, of } from 'rxjs';\r\nimport { Product } from './Product';\r\n \r\n \r\n@Injectable()\r\nexport class ProductListResolverService implements Resolve&lt;Product>{\r\n \r\n    constructor(private productService:ProductService ) {\r\n    }\r\n \r\n    resolve(route: ActivatedRouteSnapshot,\r\n            state: RouterStateSnapshot): Observable&lt;any> {\r\n \r\n        console.log(\"ProductListResover is called\");\r\n        return this.productService.getProducts();\r\n    }\r\n \r\n}</code></pre>\n\n\n\n<h3>Product Component with resolver</h3>\n\n\n\n<p>The following is the&nbsp;<code>Product2Component</code>&nbsp;does not use the&nbsp;<code>ProductService</code>, but gets the product list from the Route data.</p>\n\n\n\n<h2>product-list-resolver.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n@Component({\r\n  templateUrl: './product2.component.html',\r\n})\r\n \r\nexport class Product2Component\r\n{\r\n \r\n   public products:Product&#91;];\r\n   \r\n   constructor(private route: ActivatedRoute,private productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n      this.products=this.route.snapshot.data&#91;'products'];\r\n   }\r\n  \r\n}</code></pre>\n\n\n\n<p>In the&nbsp;<code>app.routing.module</code>, we need to add the&nbsp;<code>resolve</code>&nbsp;guard in the&nbsp;<code>route</code>&nbsp;definition</p>\n\n\n\n<pre class=\"wp-block-code\"><code> export const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product1', component: Product1Component },\r\n  { path: 'product2', component: Product2Component, resolve: {products: ProductListResolverService}  }\r\n]</code></pre>\n\n\n\n<p>The register the&nbsp;<code>ProductListResolverService</code>&nbsp;in Providers array in&nbsp;<code>AppModule</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>providers: &#91;ProductService,ProductListResolverService], </code></pre>\n\n\n\n<p>Finally, run the app</p>\n\n\n\n<p>As you click on the&nbsp;<strong>Product1</strong>&nbsp;link, you will see that the component gets loaded, but the data appears after a delay.</p>\n\n\n\n<p>While you click on&nbsp;<strong>Product2</strong>&nbsp;the component itself appears after some delay. That is because it waits for the resolver to finish. The Component renders along with the data.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/02/Angular-Resolve-Guard-Example.gif\" alt=\"\" class=\"wp-image-11869\"/></figure>\n\n\n\n<h3>ProductDetail Component</h3>\n\n\n\n<p>We can continue and create Product2DetailComponent and create a resolver, which if product not found redirects us to the Product2Component.</p>\n\n\n\n<h2>product-resolver.service.ts.</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Router, Resolve, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\nimport { ProductService } from './product.service';\r\nimport { Observable, of } from 'rxjs';\r\nimport { catchError, map } from 'rxjs/internal/operators';\r\nimport { Product } from './Product';\r\n \r\n \r\n@Injectable()\r\nexport class ProductResolverService implements Resolve&lt;any>{\r\n \r\n    constructor(private router:Router , private productService:ProductService ) {\r\n    }\r\n \r\n    resolve(route: ActivatedRouteSnapshot,\r\n           state: RouterStateSnapshot): any {\r\n \r\n    let id = route.paramMap.get('id');\r\n    console.log(\"ProductResolverService  called with \"+id);\r\n    return this.productService.getProduct(id)\r\n        .pipe(map( data => {\r\n            if (data) {\r\n                console.log(data);\r\n                return data;\r\n            } else {\r\n                console.log('redirecting');\r\n                this.router.navigate(&#91;'/product2']);\r\n                return null\r\n            }\r\n        }))\r\n    }\r\n}</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component } from '@angular/core';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\nimport { Product } from './product';\r\n \r\n@Component({\r\n  templateUrl: './product2-detail.component.html',\r\n})\r\n \r\nexport class Product2DetailComponent\r\n{\r\n   product:Product;\r\n  \r\n   constructor(private _Activatedroute:ActivatedRoute){\r\n      this.product=this._Activatedroute.snapshot.data&#91;'product'];\r\n   }\r\n \r\n}</code></pre>\n\n\n\n<h2>product2-detail.component.ts</h2>\n\n\n\n<p>In the resolver service, we check to see if the product exists, if not we redirect the use the product list page and return null.</p>\n\n\n\n<h2>Complete Example</h2>\n\n\n\n<h2>app.module.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule, ErrorHandler } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { HttpModule } from '@angular/http';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\n \r\nimport { ProductService } from './product.service';\r\nimport { ProductListResolverService } from './product-list-resolver.service';\r\nimport { ProductResolverService } from './product-resolver.service';\r\n \r\nimport { AppRoutingModule } from './app-routing.module';\r\n \r\nimport { Product1Component } from './product1.component';\r\nimport { Product1DetailComponent} from './product1-detail.component'\r\n \r\nimport { Product2Component } from './product2.component';\r\n \r\nimport { Product2DetailComponent } from './product2-detail.component';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,HomeComponent,ContactComponent,Product1Component, Product2Component,Product1DetailComponent, Product2DetailComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule,\r\n    AppRoutingModule\r\n  ],\r\n  providers: &#91;ProductService,ProductListResolverService,ProductResolverService,],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<h2>app.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: &#91;'./app.component.css']\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Route Guards Demo';\r\n}</code></pre>\n\n\n\n<h2>app.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n&lt;div class=\"container\">\r\n&lt;nav class=\"navbar navbar-default\">\r\n  &lt;div class=\"container-fluid\">\r\n    &lt;div class=\"navbar-header\">\r\n      &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n    &lt;/div>\r\n    &lt;ul class=\"nav navbar-nav\">\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\">Home&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'product1']\">Product1&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'product2']\">Product2&lt;/a>&lt;/li>\r\n        &lt;li>&lt;a &#91;routerLink]=\"&#91;'contact']\">Contact us&lt;/a>&lt;/li>\r\n    &lt;/ul>\r\n  &lt;/div>\r\n&lt;/nav>\r\n &lt;router-outlet>&lt;/router-outlet>\r\n&lt;/div></code></pre>\n\n\n\n<h2>app.routing.module.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { NgModule} from '@angular/core';\r\nimport { Routes,RouterModule } from '@angular/router';\r\n \r\nimport { HomeComponent} from './home.component'\r\nimport { ContactComponent} from './contact.component'\r\n \r\nimport { Product1Component} from './product1.component'\r\nimport { Product2Component} from './product2.component'\r\n \r\nimport { Product1DetailComponent} from './product1-detail.component'\r\nimport { ProductListResolverService } from './product-list-resolver.service';\r\nimport { Product2DetailComponent } from './product2-detail.component';\r\nimport { ProductResolverService } from './product-resolver.service';\r\n \r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'contact', component: ContactComponent },\r\n  { path: 'product1', component: Product1Component },\r\n  { path: 'product2', component: Product2Component, resolve: {products: ProductListResolverService}  },\r\n  { path: 'product1/:id', component: Product1DetailComponent },\r\n  { path: 'product2/:id', component: Product2DetailComponent, resolve:{product:ProductResolverService} },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\r\n];\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n  ],\r\n  imports: &#91;\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;],\r\n  bootstrap: &#91;]\r\n})\r\nexport class AppRoutingModule { }</code></pre>\n\n\n\n<h2>contact.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import {Component} from '@angular/core';\r\n \r\n@Component({\r\n     template: `&lt;h1>Contact Us&lt;/h1>\r\n                &lt;p>TekTutorialsHub &lt;/p>\r\n                `\r\n})\r\nexport class ContactComponent {\r\n}</code></pre>\n\n\n\n<h2>home.components.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import {Component} from '@angular/core';\r\n \r\n@Component({\r\n    template: `&lt;h1>Welcome!&lt;/h1>\r\n              &lt;p>This is Home Component &lt;/p>\r\n             `\r\n})\r\n \r\nexport class HomeComponent {\r\n}</code></pre>\n\n\n\n<h2>product.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>export class Product { \r\n \r\n    constructor(productID:number,    name: string ,   price:number) \r\n    {\r\n        this.productID=productID;\r\n        this.name=name;\r\n        this.price=price;\r\n    }\r\n \r\n    productID:number ;\r\n    name: string ;\r\n    price:number;\r\n \r\n}</code></pre>\n\n\n\n<h2>product.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import {Product} from './Product'\r\nimport { of, Observable, throwError} from 'rxjs';\r\nimport { delay, map } from 'rxjs/internal/operators';\r\n \r\nexport class ProductService{\r\n \r\n    products: Product&#91;];\r\n    \r\n    public constructor() {\r\n        this.products=&#91;\r\n            new Product(1,'Memory Card',500),\r\n            new Product(2,'Pen Drive',750),\r\n            new Product(3,'Power Bank',100),\r\n            new Product(4,'Computer',100),\r\n            new Product(5,'Laptop',100),\r\n            new Product(6,'Printer',100),\r\n        ]\r\n    }\r\n \r\n    //Return Products List with a delay \r\n    public getProducts(): Observable&lt;Product&#91;]> {\r\n        return of(this.products).pipe(delay(1500)) ;\r\n    }\r\n \r\n \r\n    // Returning Error\r\n    // This wil stop the route from getting Activated\r\n    //public getProducts(): Observable&lt;any> {\r\n    //    return of(this.products).pipe(delay(3000), map( data => {\r\n    //        throw throwError(\"errors occurred\") ;        \r\n    //    })) \r\n    //}\r\n \r\n    public getProduct(id): Observable&lt;Product> {\r\n        var Product= this.products.find(i => i.productID==id)\r\n        return of(Product).pipe(delay(1500)) ;\r\n    }\r\n}\r\n </code></pre>\n\n\n\n<h2>product-list-resolver.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Router, Resolve, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\nimport { ProductService } from './product.service';\r\nimport { Observable, of } from 'rxjs';\r\n \r\n@Injectable()\r\nexport class ProductListResolverService implements Resolve&lt;any>{\r\n \r\n    constructor(private productService:ProductService ) {\r\n    }\r\n \r\n    resolve(route: ActivatedRouteSnapshot,\r\n            state: RouterStateSnapshot): Observable&lt;any> {\r\n        console.log(\"ProductListResover is called\");\r\n        return this.productService.getProducts();\r\n    }\r\n}</code></pre>\n\n\n\n<h2>product-resolver.service.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from '@angular/core';\r\nimport { Router, Resolve, ActivatedRouteSnapshot,RouterStateSnapshot } from '@angular/router';\r\nimport { ProductService } from './product.service';\r\nimport { Observable, of } from 'rxjs';\r\nimport { catchError, map } from 'rxjs/internal/operators';\r\nimport { Product } from './Product';\r\n \r\n@Injectable()\r\nexport class ProductResolverService implements Resolve&lt;any>{\r\n \r\n    constructor(private router:Router , private productService:ProductService ) {\r\n    }\r\n \r\n    resolve1(route: ActivatedRouteSnapshot,\r\n            state: RouterStateSnapshot): Observable&lt;any> {\r\n \r\n        console.log(\"ProductResolverService  called\");\r\n        let id = route.paramMap.get('id');\r\n        return this.productService.getProduct(id);\r\n    }\r\n \r\n    resolve(route: ActivatedRouteSnapshot,\r\n           state: RouterStateSnapshot): any {\r\n \r\n    let id = route.paramMap.get('id');\r\n    console.log(\"ProductResolverService  called with \"+id);\r\n    return this.productService.getProduct(id)\r\n        .pipe(map( data => {\r\n            if (data) {\r\n                console.log(data);\r\n                return data;\r\n            } else {\r\n                console.log('redirecting');\r\n                this.router.navigate(&#91;'/product2']);\r\n                return null\r\n            }\r\n        }))\r\n}\r\n}</code></pre>\n\n\n\n<h2>product1.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component, OnInit } from '@angular/core';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n@Component({\r\n  templateUrl: './product1.component.html',\r\n})\r\n \r\nexport class Product1Component\r\n{\r\n \r\n   public products:Product&#91;];\r\n   \r\n   constructor(private route: ActivatedRoute,private productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n      console.log('ngOnInit');\r\n \r\n      this.productService.getProducts().subscribe(data => {\r\n         this.products=data;\r\n      });\r\n   }\r\n}</code></pre>\n\n\n\n<h2>product1.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1> Without Resolve&lt;/h1>\r\n&lt;div class='table-responsive'>\r\n    &lt;table class='table'>\r\n        &lt;thead>\r\n            &lt;tr>\r\n                &lt;th>Name&lt;/th>\r\n                &lt;th>Price&lt;/th>\r\n            &lt;/tr>\r\n        &lt;/thead>\r\n        &lt;tbody>\r\n            &lt;tr *ngFor=\"let product of products;\">\r\n                &lt;td>&lt;a &#91;routerLink]=\"&#91;'/product1',product.productID]\">{{product.name}} &lt;/a> &lt;/td>\r\n                &lt;td>{{product.price}}&lt;/td>\r\n            &lt;/tr>\r\n        &lt;/tbody>\r\n    &lt;/table>\r\n&lt;/div></code></pre>\n\n\n\n<h2>product1-detail.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component } from '@angular/core';\r\nimport { Router,ActivatedRoute } from '@angular/router';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\n \r\n@Component({\r\n  templateUrl: './product1-detail.component.html',\r\n})\r\n \r\nexport class Product1DetailComponent\r\n{\r\n   product:Product;\r\n \r\n   constructor(private _Activatedroute:ActivatedRoute,\r\n               private _router:Router,\r\n               private _productService:ProductService){\r\n \r\n      let id=this._Activatedroute.snapshot.params&#91;'id'];\r\n      console.log(id);\r\n      this._productService.getProduct(id)\r\n         .subscribe( data => { \r\n            this.product=data \r\n            console.log(this.product);\r\n         })\r\n   }\r\n}</code></pre>\n\n\n\n<h2>product1-detail.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1>Product Details Page &#91;Without resolve]&lt;/h1>\r\n \r\nProduct : {{ product?.name}}  &lt;br>\r\nPrice : {{product?.price}}</code></pre>\n\n\n\n<h2>product2.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { Component, OnInit } from '@angular/core';\r\n \r\nimport { ProductService } from './product.service';\r\nimport { Product } from './product';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n@Component({\r\n  templateUrl: './product2.component.html',\r\n})\r\nexport class Product2Component\r\n{\r\n   public products:Product&#91;];\r\n   \r\n   constructor(private route: ActivatedRoute,private productService:ProductService){\r\n   }\r\n \r\n   ngOnInit() {\r\n      this.products=this.route.snapshot.data&#91;'products'];\r\n   }\r\n  \r\n}</code></pre>\n\n\n\n<h2>product2.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1> With Resolve&lt;/h1>\r\n&lt;div class='table-responsive'>\r\n    &lt;table class='table'>\r\n        &lt;thead>\r\n            &lt;tr>\r\n                &lt;th>Name&lt;/th>\r\n                &lt;th>Price&lt;/th>\r\n            &lt;/tr>\r\n        &lt;/thead>\r\n        &lt;tbody>\r\n            &lt;tr *ngFor=\"let product of products;\">\r\n                &lt;td>&lt;a &#91;routerLink]=\"&#91;'/product2',product.productID]\">{{product.name}} &lt;/a> &lt;/td>\r\n                &lt;td>{{product.price}}&lt;/td>\r\n            &lt;/tr>\r\n        &lt;/tbody>\r\n    &lt;/table>\r\n&lt;/div></code></pre>\n\n\n\n<h2>product2-detail.component.ts</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\nimport { Product } from './product';\r\n \r\n@Component({\r\n  templateUrl: './product2-detail.component.html',\r\n})\r\nexport class Product2DetailComponent\r\n{\r\n   product:Product;\r\n   constructor(private _Activatedroute:ActivatedRoute){\r\n      this.product=this._Activatedroute.snapshot.data&#91;'product'];\r\n   }\r\n}</code></pre>\n\n\n\n<h2>product2-detail.component.html</h2>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n&lt;h1>Product Details Page &#91;With resolve]&lt;/h1>\r\n \r\nProduct : {{ product?.name}}  &lt;br>\r\nPrice : {{product?.price}}\r\n </code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Angular Resolve Guard The Angular renders the&nbsp;Angular Component, when we navigate to a route. The component will then sends an&nbsp;HTTP request&nbsp;to back end server to fetch data so as to display it to the user. We generally do this in&nbsp;ngOnInit Life cycle hook The Problem with the above approach is that, the use will see [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3700" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3700"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3700/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3859,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3700/revisions/3859"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3700"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3700"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3700"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3703,
    "date": "2020-12-08T05:54:51",
    "date_gmt": "2020-12-08T05:54:51",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3703" },
    "modified": "2020-12-09T07:23:41",
    "modified_gmt": "2020-12-09T07:23:41",
    "slug": "angular-pass-data-to-route-dynamic-static",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-pass-data-to-route-dynamic-static/",
    "title": { "rendered": "Angular Pass Data to Route: Dynamic/Static" },
    "content": {
      "rendered": "\n<h2>Various ways of passing data to route</h2>\n\n\n\n<p>The Angular can pass data to Route in several ways.</p>\n\n\n\n<ol><li>Using URL or&nbsp;Route Parameter</li><li>The&nbsp;Optional Parameter or Query Strings</li><li>Using URL Fragment</li><li>Static data using the data property</li><li>Dynamic data using state object</li></ol>\n\n\n\n<h1>Passing static data to a route</h1>\n\n\n\n<p>We can configure the static data at the time of defining the route. This is done by using the&nbsp;<strong>Angular route data property</strong>&nbsp;of the&nbsp;route. The route data property can contain an array of arbitrary string key-value pairs. You can use the static data to store items such as page titles, breadcrumb text, and other read-only, static data</p>\n\n\n\n<p>For Example, consider the following route with the data property set</p>\n\n\n\n<pre class=\"wp-block-code\"><code> { path: 'static', component: StaticComponent, data :{ id:'1', name:\"Angular\"}}, </code></pre>\n\n\n\n<p>For Example, consider the following route with the data property set</p>\n\n\n\n<p>The&nbsp;Angular Router&nbsp;will pass the&nbsp;<code>{ id:'1', name:\"Angular\"}</code>&nbsp;when the&nbsp;<code>StaticComponent</code>&nbsp;is rendered. The data value will be located in the data property of the&nbsp;<code>ActivatedRoute</code>&nbsp;service</p>\n\n\n\n<p>We can then read the data by subscribing to the&nbsp;<code>activatedroute.data</code>&nbsp;property as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ngOnInit() {\r\n      this.activatedroute.data.subscribe(data => {\r\n          this.product=data;\r\n      })\r\n}</code></pre>\n\n\n\n<p>We can then read the data by subscribing to the&nbsp;<code>activatedroute.data</code>&nbsp;property as shown below</p>\n\n\n\n<h1>Passing Dynamic data to a Route</h1>\n\n\n\n<p>The option to pass the dynamic data or a user-defined object was added in the&nbsp;<strong>Angular Version 7.2</strong>&nbsp;using the state object. The state object is stored in&nbsp;History API</p>\n\n\n\n<h2>Providing the State value</h2>\n\n\n\n<p>The state can be provided in two ways</p>\n\n\n\n<h3>Using routerLink directive</h3>\n\n\n\n<pre class=\"wp-block-code\"><code> &lt;a &#91;routerLink]=\"&#91;'dynamic']\" &#91;state]=\"{ id:1 , name:'Angular'}\">Dynamic Data&lt;/a> </code></pre>\n\n\n\n<h3>Using navigateByUrl</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>this.router.navigateByUrl('/dynamic', { state: { id:1 , name:'Angular' } }); </code></pre>\n\n\n\n<p>The Router will add a&nbsp;<code>navigationId</code>&nbsp;property to the state object. Hence you cannot use a scalar value.</p>\n\n\n\n<h2>Accessing the state value</h2>\n\n\n\n<p>The state can be accessed by using the&nbsp;<code>getCurrentNavigation</code>&nbsp;method of the router (works only in the constructor)</p>\n\n\n\n<pre class=\"wp-block-code\"><code> this.router.getCurrentNavigation().extras.state </code></pre>\n\n\n\n<p>The state can be accessed by using the&nbsp;<code>getCurrentNavigation</code>&nbsp;method of the router (works only in the constructor)</p>\n\n\n\n<p>Or use the&nbsp;<code>history.state</code>&nbsp;in the&nbsp;ngOnInit.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> console.log(history.state) </code></pre>\n\n\n\n<p>or use the&nbsp;<code>getState</code>&nbsp;method of the Location Service. This method is available Angular 8+</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Location } from '@angular/common';\r\n \r\nexport class SomeComponent\r\n{\r\n  products:Product&#91;];\r\n \r\n  constructor(private location:Location){\r\n  }\r\n \r\n  ngOnInit() {\r\n    console.log(this.location.getState());\r\n  }\r\n}</code></pre>\n\n\n\n<h2>Passing Data to the Routes Example</h2>\n\n\n\n<p>Let us build a simple project to demonstrate how to pass data to the route</p>\n\n\n\n<h3>Passing static data example</h3>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Component, OnInit} from '@angular/core';\r\nimport { ActivatedRoute } from '@angular/router';\r\n \r\n@Component({\r\n     template: `&lt;h1>Passing Static Data Demo&lt;/h1>\r\n         {{product  | json}}`\r\n})\r\nexport class StaticComponent implements OnInit {\r\n \r\n     product:any;\r\n     constructor(private activatedroute:ActivatedRoute) {\r\n     }\r\n \r\n     ngOnInit() {\r\n          this.activatedroute.data.subscribe(data => {\r\n               this.product=data;\r\n           })\r\n     }\r\n}</code></pre>\n\n\n\n<p>The static component gets the static data configured in the route. It subscribes the&nbsp;<code>activatedroute.data</code>&nbsp;property to get the product data as shown above.</p>\n\n\n\n<h3>Passing dynamic data (or object) example</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>import {Component, OnInit, ChangeDetectorRef} from '@angular/core';\r\nimport { ActivatedRoute, Router, NavigationStart } from '@angular/router';\r\nimport { map, filter} from 'rxjs/operators';\r\nimport { Observable} from 'rxjs/observable';\r\n \r\n@Component({\r\n     template: `&lt;H1>Passing Dynamic Data Demo&lt;/H1>\r\n \r\n     {{ product | json }}`\r\n})\r\nexport class DynamicComponent implements OnInit {\r\n \r\n     product;\r\n \r\n     constructor(private router:Router, private activatedRoute:ActivatedRoute) {\r\n          console.log(this.router.getCurrentNavigation().extras.state);\r\n     }\r\n \r\n     ngOnInit() {\r\n          //console.log(history.state);\r\n          this.product=history.state;\r\n     }\r\n \r\n}</code></pre>\n\n\n\n<h3>Passing dynamic data (or object) example</h3>\n\n\n\n<p>The Dynamic Component gets dynamic data. We use the&nbsp;<code>history.state</code>&nbsp;to access the product data. Alternatively, we can use the&nbsp;<code>this.router.getCurrentNavigation().extras.state</code>&nbsp;to achieve the same. Please remember&nbsp;<code>getCurrentNavigation</code>&nbsp;only works in the constructor. It will return null if used elsewhere.</p>\n\n\n\n<p><strong>home.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\nimport { ActivatedRoute, Router } from '@angular/router';\r\n \r\n@Component({\r\n  template: `\r\n     &lt;ul>\r\n       &lt;li>&lt;a &#91;routerLink]=\"&#91;'/static']\">Static Data&lt;/a>&lt;/li>\r\n       &lt;li>&lt;a &#91;routerLink]=\"&#91;'/dynamic']\" &#91;state]=product>Dynamic Data&lt;/a>&lt;/li> \r\n    &lt;/ul>\r\n   \r\n    &lt;p>Id :   &lt;input type=\"text\" &#91;(ngModel)]=\"product.id\" > &lt;/p>\r\n    &lt;p>name :&lt;input type=\"text\" &#91;(ngModel)]=\"product.name\" > &lt;/p>\r\n    &lt;button (click)=\"gotoDynamic()\" >Goto Dynamic Component&lt;/button>`\r\n})\r\nexport class HomeComponent {\r\n  \r\n  public product = { id:'1', name:\"Angular\"};\r\n \r\n  constructor(private router : Router) {\r\n  }\r\n \r\n  gotoDynamic() {\r\n    //this.router.navigateByUrl('/dynamic', { state: { id:1 , name:'Angular' } });\r\n    this.router.navigateByUrl('/dynamic', { state: this.product });\r\n  }\r\n}\r\n </code></pre>\n\n\n\n<p><strong>home.component.ts</strong></p>\n\n\n\n<p>In&nbsp;<code>HomeComponent</code>, we have used&nbsp;<code>routerLink</code>&nbsp;&amp;&nbsp;<code>navigateByUrl</code>&nbsp;to pass the data to the dynamic component. You can also use the form fields to change the data, before passing it to the dynamic route.</p>\n\n\n\n<p><strong>app.routes.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Routes } from '@angular/router';\r\n \r\nimport { StaticComponent} from './static.component'\r\nimport { DynamicComponent } from './dynamic.component';\r\nimport { HomeComponent } from './home.component';\r\n \r\nexport const appRoutes: Routes = &#91;\r\n  { path: 'home', component: HomeComponent },\r\n  { path: 'static', component: StaticComponent, data :{ id:'1', name:\"Angular\"}},\r\n  { path: 'dynamic', component: DynamicComponent },\r\n  { path: '', redirectTo: 'home', pathMatch: 'full' }\r\n];\r\n </code></pre>\n\n\n\n<p><strong>app.routes.ts</strong></p>\n\n\n\n<p>Here the static data is set for&nbsp;<code>StaticComponent</code>&nbsp;using the&nbsp;<code>data</code>&nbsp;property.</p>\n\n\n\n<p><strong>app.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  template: `&lt;div class=\"container\">\r\n \r\n  &lt;nav class=\"navbar navbar-default\">\r\n    &lt;div class=\"container-fluid\">\r\n      &lt;div class=\"navbar-header\">\r\n        &lt;a class=\"navbar-brand\" &#91;routerLink]=\"&#91;'/']\">&lt;strong> {{title}} &lt;/strong>&lt;/a>\r\n      &lt;/div>\r\n    &lt;/div>\r\n  &lt;/nav>\r\n  \r\n  &lt;router-outlet>&lt;/router-outlet>\r\n  \r\n  &lt;/div>`\r\n})\r\nexport class AppComponent {\r\n  title = 'Routing Module - Passing Dynamic / Static data route';\r\n}</code></pre>\n\n\n\n<p><strong>app.module.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { HttpModule } from '@angular/http';\r\n \r\nimport { RouterModule } from '@angular/router';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport { StaticComponent} from './static.component'\r\n \r\n \r\nimport { appRoutes } from './app.routes';\r\nimport { DynamicComponent } from './dynamic.component';\r\nimport { HomeComponent } from './home.component';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent,StaticComponent,DynamicComponent,HomeComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    FormsModule,\r\n    HttpModule,\r\n    RouterModule.forRoot(appRoutes)\r\n  ],\r\n  providers: &#91;],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }\r\n </code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/05/Angular-Pass-data-to-route.gif\" alt=\"Angular pass data to route\" class=\"wp-image-12237\"/></figure>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Various ways of passing data to route The Angular can pass data to Route in several ways. Using URL or&nbsp;Route Parameter The&nbsp;Optional Parameter or Query Strings Using URL Fragment Static data using the data property Dynamic data using state object Passing static data to a route We can configure the static data at the time [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3703" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3703"
        }
      ],
      "version-history": [
        {
          "count": 3,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3703/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3860,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3703/revisions/3860"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3703"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3703"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3703"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3708,
    "date": "2020-12-08T05:57:24",
    "date_gmt": "2020-12-08T05:57:24",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3708" },
    "modified": "2020-12-09T07:26:00",
    "modified_gmt": "2020-12-09T07:26:00",
    "slug": "routerlinkactive-in-angular",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/routerlinkactive-in-angular/",
    "title": { "rendered": "RouterLinkActive in Angular" },
    "content": {
      "rendered": "\n<h2>RouterLinkActive</h2>\n\n\n\n<p>The&nbsp;<code>RouterLinkActive</code>&nbsp;Directive is applied along with the&nbsp;<code>RouterLink</code>&nbsp;directive. The right-hand side of&nbsp;<code>RouterLinkActive</code>&nbsp;contains a&nbsp;<strong>Template expression</strong>. The template expression must contain a space-delimited string of CSS classes, which will be applied to the element when the route is active.</p>\n\n\n\n<p>For Example, consider the following examples</p>\n\n\n\n<pre class=\"wp-block-code\"><code>li>&lt;a &#91;routerLink]=\"&#91;'home']\" routerLinkActive=\"active\">Home&lt;/a>&lt;/li>\r\n \r\n&lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;routerLinkActive]=\"&#91;'active']\">Product&lt;/a>&lt;/li>\r\n </code></pre>\n\n\n\n<p>With the CSS Rule defined as the global styles.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> .active {  background-color: yellow;} </code></pre>\n\n\n\n<p>When the user navigates to any of the above&nbsp;routes, the Angular router adds the “active” class to the activated element. And when the user navigates away the class will be removed.</p>\n\n\n\n<p>The Angular does this by watching the URL. Whenever the Url matches with the URL of the&nbsp;<code>routerLink</code>&nbsp;directive, it applies the classes defined in the&nbsp;<code>RouterLinkActive</code>&nbsp;directive. When it does not match it will be removed from the element.</p>\n\n\n\n<p>Using this we can apply different background or foreground color to our navigation links.</p>\n\n\n\n<h2>Multiple classes</h2>\n\n\n\n<p>You can add multiple classes to the routerLinkActive directive as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a routerLink=\"/user/bob\" &#91;routerLinkActive]=\"&#91;'class1', 'class2']\">Bob&lt;/a>\r\n \r\n&lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\" routerLinkActive=\"active  home\">Home&lt;/a>&lt;/li>\r\n&lt;li>&lt;a &#91;routerLink]=\"&#91;'product']\" &#91;routerLinkActive]=\"&#91;'active','home']\">Product&lt;/a>&lt;/li></code></pre>\n\n\n\n<h2>Child Routes</h2>\n\n\n\n<p>When the child route is active, then all the parent routes are also marked as active and&nbsp;<code>routerLinkActive</code>&nbsp;is applied to URL tree cascading all the way to the top.</p>\n\n\n\n<p>For Example</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a routerLink=\"/product\" routerLinkActive=\"class1 class2\">Product&lt;/a>\r\n&lt;a routerLink=\"/product/PC\" routerLinkActive=\"class1 class2\">PC&lt;/a>\r\n&lt;a routerLink=\"/product/mobile\" routerLinkActive=\"class1 class2\">Mobile&lt;/a></code></pre>\n\n\n\n<p>In the above example. When the URL is either&nbsp;<code>/product/PC</code>&nbsp;or&nbsp;<code>/product/mobile</code>, the&nbsp;<code>RouterLinkactive</code>&nbsp;class (i.e. class1 class2) is added to the&nbsp;<code>/product</code>&nbsp;element also as it is the parent of these child routes.</p>\n\n\n\n<h2>Exact matching</h2>\n\n\n\n<p>You can stop that from happening by, passing the&nbsp;<code>exact: true</code>&nbsp;to the&nbsp;<code>RouterLinkactive</code>&nbsp;using the&nbsp;<code>routerLinkActiveOptions</code>&nbsp;as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;a routerLink=\"/product\" routerLinkActive=\"class1 class1\" &#91;routerLinkActiveOptions]=\"{exact:\r\ntrue}\">Product&lt;/a>\r\n&lt;a routerLink=\"/product/PC\" routerLinkActive=\"class1 class2\">PC&lt;/a>\r\n&lt;a routerLink=\"/product/mobile\" routerLinkActive=\"class1 class2\">Mobile&lt;/a></code></pre>\n\n\n\n<p>This will make the&nbsp;<code>RouterLinkactive</code>&nbsp;to be applied only if the route URL matches exactly to the current URL</p>\n\n\n\n<h2>Matching</h2>\n\n\n\n<p>The&nbsp;<code>routerActiveLink</code>&nbsp;follows the following criteria before returning&nbsp;<strong>true</strong></p>\n\n\n\n<h3>without exact: true</h3>\n\n\n\n<ul><li>A subset of the&nbsp;queryParams&nbsp;is matched.</li><li>The URL is a subtree of the URL tree.</li><li>Matrix params are ignored</li></ul>\n\n\n\n<h3>with exact: true</h3>\n\n\n\n<ul><li>A&nbsp;queryParams&nbsp;must match exactly</li><li>The URL must match exactly</li><li>Matrix params are ignored</li></ul>\n\n\n\n<h2>Adding classes to ancestors</h2>\n\n\n\n<p>You can apply the&nbsp;<code>RouterLinkActive</code>&nbsp;directive to an ancestor of a&nbsp;<code>RouterLink</code>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n&lt;div routerLinkActive=\"active\" &#91;routerLinkActiveOptions]=\"{exact: true}\">\r\n  &lt;a routerLink=\"/product/pc\">Jim&lt;/a>\r\n  &lt;a routerLink=\"/product/mobile\">Bob&lt;/a>\r\n&lt;/div>\r\n </code></pre>\n\n\n\n<p>This will set the active class on the&nbsp;<code>div</code>&nbsp;tag if the URL is either&nbsp;<code>/product/pc</code>&nbsp;or&nbsp;<code>product/mobile</code></p>\n\n\n\n<h2>Bind to Component Property</h2>\n\n\n\n<p>You can also bind&nbsp;<code>RouterLinkActive</code>&nbsp;to a component property which returns a string of classes using template expression.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;li>&lt;a &#91;routerLink]=\"&#91;'home']\" routerLinkActive=\"{{getClass()}}\">Home&lt;/a>&lt;/li></code></pre>\n\n\n\n<p>In component class</p>\n\n\n\n<pre class=\"wp-block-code\"><code> getClass() {  return \"active\"}</code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>RouterLinkActive The&nbsp;RouterLinkActive&nbsp;Directive is applied along with the&nbsp;RouterLink&nbsp;directive. The right-hand side of&nbsp;RouterLinkActive&nbsp;contains a&nbsp;Template expression. The template expression must contain a space-delimited string of CSS classes, which will be applied to the element when the route is active. For Example, consider the following examples With the CSS Rule defined as the global styles. When the user navigates [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [134],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3708" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3708"
        }
      ],
      "version-history": [
        {
          "count": 2,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3708/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3861,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3708/revisions/3861"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3708"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3708"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3708"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  }
]
