[
  {
    "id": 4596,
    "date": "2021-02-25T11:23:09",
    "date_gmt": "2021-02-25T11:23:09",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4596"
    },
    "modified": "2021-02-25T11:23:09",
    "modified_gmt": "2021-02-25T11:23:09",
    "slug": "component-binding",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/component-binding/",
    "title": {
      "rendered": "Component binding"
    },
    "content": {
      "rendered": "\n<p>In the example app, the&nbsp;<code>BannerComponent</code>&nbsp;presents static title text in the HTML template.</p>\n\n\n\n<p>After a few changes, the&nbsp;<code>BannerComponent</code>&nbsp;presents a dynamic title by binding to the component&#8217;s&nbsp;<code>title</code>&nbsp;property like this.app/banner/banner.component.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  selector: 'app-banner',\n  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',\n  styles: &#91;'h1 { color: green; font-size: 350%}']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}</code></code></pre>\n\n\n\n<p>As minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>In the example app, the&nbsp;BannerComponent&nbsp;presents static title text in the HTML template. After a few changes, the&nbsp;BannerComponent&nbsp;presents a dynamic title by binding to the component&#8217;s&nbsp;title&nbsp;property like this.app/banner/banner.component.ts As minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should.</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4596"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4596"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4596/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4597,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4596/revisions/4597"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4596"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4596"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4596"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4595,
    "date": "2021-02-25T11:23:26",
    "date_gmt": "2021-02-25T11:23:26",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4595"
    },
    "modified": "2021-02-25T11:23:26",
    "modified_gmt": "2021-02-25T11:23:26",
    "slug": "query-for-the",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/query-for-the/",
    "title": {
      "rendered": "Query for the <h1>"
    },
    "content": {
      "rendered": "\n<p>You&#8217;ll write a sequence of tests that inspect the value of the&nbsp;<code>&lt;h1&gt;</code>&nbsp;element that wraps the&nbsp;<em>title</em>&nbsp;property interpolation binding.</p>\n\n\n\n<p>You update the&nbsp;<code>beforeEach</code>&nbsp;to find that element with a standard HTML&nbsp;<code>querySelector</code>&nbsp;and assign it to the&nbsp;<code>h1</code>&nbsp;variable.app/banner/banner.component.spec.ts (setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>let component: BannerComponent;\nlet fixture: <a href=\"https://angular.io/api/core/testing/ComponentFixture\">ComponentFixture</a>&lt;BannerComponent&gt;;\nlet h1: HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: &#91; BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>You&#8217;ll write a sequence of tests that inspect the value of the&nbsp;&lt;h1&gt;&nbsp;element that wraps the&nbsp;title&nbsp;property interpolation binding. You update the&nbsp;beforeEach&nbsp;to find that element with a standard HTML&nbsp;querySelector&nbsp;and assign it to the&nbsp;h1&nbsp;variable.app/banner/banner.component.spec.ts (setup)</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4595"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4595"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4595/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4598,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4595/revisions/4598"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4595"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4595"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4595"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4594,
    "date": "2021-02-25T11:23:47",
    "date_gmt": "2021-02-25T11:23:47",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4594"
    },
    "modified": "2021-02-25T11:23:47",
    "modified_gmt": "2021-02-25T11:23:47",
    "slug": "createcomponent-does-not-bind-data",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/createcomponent-does-not-bind-data/",
    "title": {
      "rendered": "createComponent() does not bind data"
    },
    "content": {
      "rendered": "\n<p>For your first test you&#8217;d like to see that the screen displays the default&nbsp;<code>title</code>. Your instinct is to write a test that immediately inspects the&nbsp;<code>&lt;h1&gt;</code>&nbsp;like this:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display original title', () =&gt; {\n  expect(h1.textContent).toContain(component.title);\n});</code></code></pre>\n\n\n\n<p><em>That test fails</em>&nbsp;with the message:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>expected '' to contain 'Test Tour of Heroes'.</code></code></pre>\n\n\n\n<p>Binding happens when Angular performs&nbsp;<strong>change detection</strong>.</p>\n\n\n\n<p>In production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke or an asynchronous activity (e.g., AJAX) completes.</p>\n\n\n\n<p>The&nbsp;<code>TestBed.createComponent</code>&nbsp;does&nbsp;<em>not</em>&nbsp;trigger change detection; a fact confirmed in the revised test:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('no title in the DOM after createComponent()', () =&gt; {\n  expect(h1.textContent).toEqual('');\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>For your first test you&#8217;d like to see that the screen displays the default&nbsp;title. Your instinct is to write a test that immediately inspects the&nbsp;&lt;h1&gt;&nbsp;like this: That test fails&nbsp;with the message: Binding happens when Angular performs&nbsp;change detection. In production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4594"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4594"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4594/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4599,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4594/revisions/4599"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4594"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4594"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4594"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4589,
    "date": "2021-02-25T11:24:13",
    "date_gmt": "2021-02-25T11:24:13",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4589"
    },
    "modified": "2021-02-25T11:24:13",
    "modified_gmt": "2021-02-25T11:24:13",
    "slug": "detectchanges",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/detectchanges/",
    "title": {
      "rendered": "detectChanges()"
    },
    "content": {
      "rendered": "\n<p>You must tell the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;to perform data binding by calling&nbsp;<code>fixture.detectChanges()</code>. Only then does the&nbsp;<code>&lt;h1&gt;</code>&nbsp;have the expected title.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display original title after detectChanges()', () =&gt; {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});</code></code></pre>\n\n\n\n<p>Delayed change detection is intentional and useful. It gives the tester an opportunity to inspect and change the state of the component&nbsp;<em>before Angular initiates data binding and calls&nbsp;<a href=\"https://angular.io/guide/lifecycle-hooks\">lifecycle hooks</a></em>.</p>\n\n\n\n<p>Here&#8217;s another test that changes the component&#8217;s&nbsp;<code>title</code>&nbsp;property&nbsp;<em>before</em>&nbsp;calling&nbsp;<code>fixture.detectChanges()</code>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display a different test title', () =&gt; {\n  component.title = 'Test <a href=\"https://angular.io/api/platform-browser/Title\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"https://angular.io/api/platform-browser/Title\">Title</a>');\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>You must tell the&nbsp;TestBed&nbsp;to perform data binding by calling&nbsp;fixture.detectChanges(). Only then does the&nbsp;&lt;h1&gt;&nbsp;have the expected title. Delayed change detection is intentional and useful. It gives the tester an opportunity to inspect and change the state of the component&nbsp;before Angular initiates data binding and calls&nbsp;lifecycle hooks. Here&#8217;s another test that changes the component&#8217;s&nbsp;title&nbsp;property&nbsp;before&nbsp;calling&nbsp;fixture.detectChanges().</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4589"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4589"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4589/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4600,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4589/revisions/4600"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4589"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4589"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4589"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4591,
    "date": "2021-02-25T11:24:43",
    "date_gmt": "2021-02-25T11:24:43",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4591"
    },
    "modified": "2021-02-25T11:24:43",
    "modified_gmt": "2021-02-25T11:24:43",
    "slug": "automatic-change-detection",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/automatic-change-detection/",
    "title": {
      "rendered": "Automatic change detection"
    },
    "content": {
      "rendered": "\n<p>The&nbsp;<code>BannerComponent</code>&nbsp;tests frequently call&nbsp;<code>detectChanges</code>. Some testers prefer that the Angular test environment run change detection automatically.</p>\n\n\n\n<p>That&#8217;s possible by configuring the\u00a0<code>TestBed</code>\u00a0with the\u00a0<code>ComponentFixtureAutoDetect</code>\u00a0provider. First import it from the testing utility library:app/banner/banner.component.detect-changes.spec.ts (import)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>import { <a href=\"https://angular.io/api/core/testing/ComponentFixtureAutoDetect\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';</code></code></pre>\n\n\n\n<p>Then add it to the&nbsp;<code>providers</code>&nbsp;array of the testing module configuration:app/banner/banner.component.detect-changes.spec.ts (AutoDetect)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>TestBed.configureTestingModule({\n  declarations: &#91; BannerComponent ],\n  providers: &#91;\n    { provide: <a href=\"https://angular.io/api/core/testing/ComponentFixtureAutoDetect\">ComponentFixtureAutoDetect</a>, useValue: true }\n  ]\n});</code></code></pre>\n\n\n\n<p>Here are three tests that illustrate how automatic change detection works.app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display original title', () =&gt; {\n  // Hooray! No `fixture.detectChanges()` needed\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () =&gt; {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"https://angular.io/api/platform-browser/Title\">Title</a>';\n  // Displayed title is old because Angular didn't hear the change :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () =&gt; {\n  comp.title = 'Test <a href=\"https://angular.io/api/platform-browser/Title\">Title</a>';\n  fixture.detectChanges(); // detect changes explicitly\n  expect(h1.textContent).toContain(comp.title);\n});</code></code></pre>\n\n\n\n<p>The first test shows the benefit of automatic change detection.</p>\n\n\n\n<p>The second and third test reveal an important limitation. The Angular testing environment does&nbsp;<em>not</em>&nbsp;know that the test changed the component&#8217;s&nbsp;<code>title</code>. The&nbsp;<code><a href=\"https://angular.io/api/core/testing/ComponentFixtureAutoDetect\">ComponentFixtureAutoDetect</a></code>&nbsp;service responds to&nbsp;<em>asynchronous activities</em>&nbsp;such as promise resolution, timers, and DOM events. But a direct, synchronous update of the component property is invisible. The test must call&nbsp;<code>fixture.detectChanges()</code>&nbsp;manually to trigger another cycle of change detection.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The&nbsp;BannerComponent&nbsp;tests frequently call&nbsp;detectChanges. Some testers prefer that the Angular test environment run change detection automatically. That&#8217;s possible by configuring the\u00a0TestBed\u00a0with the\u00a0ComponentFixtureAutoDetect\u00a0provider. First import it from the testing utility library:app/banner/banner.component.detect-changes.spec.ts (import) Then add it to the&nbsp;providers&nbsp;array of the testing module configuration:app/banner/banner.component.detect-changes.spec.ts (AutoDetect) Here are three tests that illustrate how automatic change detection works.app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests) The [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4591"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4591"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4591/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4601,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4591/revisions/4601"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4591"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4591"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4591"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4590,
    "date": "2021-02-25T11:25:00",
    "date_gmt": "2021-02-25T11:25:00",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4590"
    },
    "modified": "2021-02-25T11:25:00",
    "modified_gmt": "2021-02-25T11:25:00",
    "slug": "change-an-input-value-with-dispatchevent",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/change-an-input-value-with-dispatchevent/",
    "title": {
      "rendered": "Change an input value with dispatchEvent()"
    },
    "content": {
      "rendered": "\n<p>To simulate user input, you can find the input element and set its&nbsp;<code>value</code>&nbsp;property.</p>\n\n\n\n<p>You will call&nbsp;<code>fixture.detectChanges()</code>&nbsp;to trigger Angular&#8217;s change detection. But there is an essential, intermediate step.</p>\n\n\n\n<p>Angular doesn&#8217;t know that you set the input element&#8217;s&nbsp;<code>value</code>&nbsp;property. It won&#8217;t read that property until you raise the element&#8217;s&nbsp;<code>input</code>&nbsp;event by calling&nbsp;<code>dispatchEvent()</code>.&nbsp;<em>Then</em>&nbsp;you call&nbsp;<code>detectChanges()</code>.</p>\n\n\n\n<p>The following example demonstrates the proper sequence.app/hero/hero-detail.component.spec.ts (pipe test)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should convert hero name to <a href=\"https://angular.io/api/platform-browser/Title\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  // In older browsers, such as IE, you might need a CustomEvent instead. See\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  nameInput.dispatchEvent(new <a href=\"https://angular.io/api/router/Event\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>To simulate user input, you can find the input element and set its&nbsp;value&nbsp;property. You will call&nbsp;fixture.detectChanges()&nbsp;to trigger Angular&#8217;s change detection. But there is an essential, intermediate step. Angular doesn&#8217;t know that you set the input element&#8217;s&nbsp;value&nbsp;property. It won&#8217;t read that property until you raise the element&#8217;s&nbsp;input&nbsp;event by calling&nbsp;dispatchEvent().&nbsp;Then&nbsp;you call&nbsp;detectChanges(). The following example demonstrates the proper [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4590"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4590"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4590/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4602,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4590/revisions/4602"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4590"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4590"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4590"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4586,
    "date": "2021-02-25T11:25:31",
    "date_gmt": "2021-02-25T11:25:31",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4586"
    },
    "modified": "2021-02-25T11:25:31",
    "modified_gmt": "2021-02-25T11:25:31",
    "slug": "component-with-external-files",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/component-with-external-files/",
    "title": {
      "rendered": "Component with external files"
    },
    "content": {
      "rendered": "\n<p>The\u00a0<code>BannerComponent</code>\u00a0above is defined with an\u00a0<em>inline template</em>\u00a0and\u00a0<em>inline css</em>, specified in the\u00a0<code>@Component.template</code>\u00a0and\u00a0<code>@Component.styles</code>\u00a0properties respectively.</p>\n\n\n\n<p>Many components specify\u00a0<em>external templates</em>\u00a0and\u00a0<em>external css</em>\u00a0with the\u00a0<code>@Component.templateUrl</code>\u00a0and\u00a0<code>@Component.styleUrls</code>\u00a0properties respectively, as the following variant of\u00a0<code>BannerComponent</code>\u00a0does.app/banner/banner-external.component.ts (metadata)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  &#91;'./banner-external.component.css']\n})</code></code></pre>\n\n\n\n<p>This syntax tells the Angular compiler to read the external files during component compilation.</p>\n\n\n\n<p>That&#8217;s not a problem when you run the CLI&nbsp;<code>ng test</code>&nbsp;command because it&nbsp;<em>compiles the app before running the tests</em>.</p>\n\n\n\n<p>However, if you run the tests in a&nbsp;<strong>non-CLI environment</strong>, tests of this component may fail. For example, if you run the&nbsp;<code>BannerComponent</code>&nbsp;tests in a web coding environment such as&nbsp;<a href=\"https://plnkr.co/\">plunker</a>, you&#8217;ll see a message like this one:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Error: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.</code></pre>\n\n\n\n<p>You get this test failure message when the runtime environment compiles the source code&nbsp;<em>during the tests themselves</em>.</p>\n\n\n\n<p>To correct the problem, call&nbsp;<code>compileComponents()</code>&nbsp;as explained&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#compile-components\">below</a>.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The\u00a0BannerComponent\u00a0above is defined with an\u00a0inline template\u00a0and\u00a0inline css, specified in the\u00a0@Component.template\u00a0and\u00a0@Component.styles\u00a0properties respectively. Many components specify\u00a0external templates\u00a0and\u00a0external css\u00a0with the\u00a0@Component.templateUrl\u00a0and\u00a0@Component.styleUrls\u00a0properties respectively, as the following variant of\u00a0BannerComponent\u00a0does.app/banner/banner-external.component.ts (metadata) This syntax tells the Angular compiler to read the external files during component compilation. That&#8217;s not a problem when you run the CLI&nbsp;ng test&nbsp;command because it&nbsp;compiles the app before running the [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4586"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4586"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4586/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4603,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4586/revisions/4603"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4586"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4586"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4586"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4587,
    "date": "2021-02-25T11:25:51",
    "date_gmt": "2021-02-25T11:25:51",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4587"
    },
    "modified": "2021-02-25T11:25:51",
    "modified_gmt": "2021-02-25T11:25:51",
    "slug": "component-with-a-dependency",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/component-with-a-dependency/",
    "title": {
      "rendered": "Component with a dependency"
    },
    "content": {
      "rendered": "\n<p>Components often have service dependencies.</p>\n\n\n\n<p>The&nbsp;<code>WelcomeComponent</code>&nbsp;displays a welcome message to the logged in user. It knows who the user is based on a property of the injected&nbsp;<code>UserService</code>:app/welcome/welcome.component.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>import { <a href=\"https://angular.io/api/core/Component\">Component</a>, <a href=\"https://angular.io/api/core/OnInit\">OnInit</a> } from '@angular/core';\nimport { UserService } from '../model/user.service';\n\n@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  selector: 'app-welcome',\n  template: '&lt;h3 class=\"welcome\"&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;'\n})\nexport class WelcomeComponent implements <a href=\"https://angular.io/api/core/OnInit\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}</code></code></pre>\n\n\n\n<p>The&nbsp;<code>WelcomeComponent</code>&nbsp;has decision logic that interacts with the service, logic that makes this component worth testing. Here&#8217;s the testing module configuration for the spec file:app/welcome/welcome.component.spec.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>TestBed.configureTestingModule({\n   declarations: &#91; WelcomeComponent ],\n// providers: &#91; UserService ],  // NO! Don't provide the real service!\n                                // Provide a test-double instead\n   providers: &#91; { provide: UserService, useValue: userServiceStub } ],\n});</code></code></pre>\n\n\n\n<p>This time, in addition to declaring the&nbsp;<em>component-under-test</em>, the configuration adds a&nbsp;<code>UserService</code>&nbsp;provider to the&nbsp;<code>providers</code>&nbsp;list. But not the real&nbsp;<code>UserService</code>.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Components often have service dependencies. The&nbsp;WelcomeComponent&nbsp;displays a welcome message to the logged in user. It knows who the user is based on a property of the injected&nbsp;UserService:app/welcome/welcome.component.ts The&nbsp;WelcomeComponent&nbsp;has decision logic that interacts with the service, logic that makes this component worth testing. Here&#8217;s the testing module configuration for the spec file:app/welcome/welcome.component.spec.ts This time, in addition [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4587"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4587"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4587/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4604,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4587/revisions/4604"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4587"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4587"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4587"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4593,
    "date": "2021-02-25T11:26:16",
    "date_gmt": "2021-02-25T11:26:16",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4593"
    },
    "modified": "2021-02-25T11:26:16",
    "modified_gmt": "2021-02-25T11:26:16",
    "slug": "provide-service-test-doubles",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/provide-service-test-doubles/",
    "title": {
      "rendered": "Provide service test doubles"
    },
    "content": {
      "rendered": "\n<p>A&nbsp;<em>component-under-test</em>&nbsp;doesn&#8217;t have to be injected with real services. In fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks). The purpose of the spec is to test the component, not the service, and real services can be trouble.</p>\n\n\n\n<p>Injecting the real&nbsp;<code>UserService</code>&nbsp;could be a nightmare. The real service might ask the user for login credentials and attempt to reach an authentication server. These behaviors can be hard to intercept. It is far easier and safer to create and register a test double in place of the real&nbsp;<code>UserService</code>.</p>\n\n\n\n<p>This particular test suite supplies a minimal mock of the&nbsp;<code>UserService</code>&nbsp;that satisfies the needs of the&nbsp;<code>WelcomeComponent</code>&nbsp;and its tests:app/welcome/welcome.component.spec.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>let userServiceStub: Partial&lt;UserService&gt;;\n\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>A&nbsp;component-under-test&nbsp;doesn&#8217;t have to be injected with real services. In fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks). The purpose of the spec is to test the component, not the service, and real services can be trouble. Injecting the real&nbsp;UserService&nbsp;could be a nightmare. The real service might ask the [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4593"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4593"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4593/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4605,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4593/revisions/4605"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4593"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4593"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4593"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4588,
    "date": "2021-02-25T11:26:41",
    "date_gmt": "2021-02-25T11:26:41",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4588"
    },
    "modified": "2021-02-25T11:26:41",
    "modified_gmt": "2021-02-25T11:26:41",
    "slug": "get-injected-services",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/get-injected-services/",
    "title": {
      "rendered": "Get injected services"
    },
    "content": {
      "rendered": "\n<p>The tests need access to the (stub)&nbsp;<code>UserService</code>&nbsp;injected into the&nbsp;<code>WelcomeComponent</code>.</p>\n\n\n\n<p>Angular has a hierarchical injection system. There can be injectors at multiple levels, from the root injector created by the\u00a0<code>TestBed</code>\u00a0down through the component tree.</p>\n\n\n\n<p>The safest way to get the injected service, the way that&nbsp;<strong><em>always works</em></strong>, is to&nbsp;<strong>get it from the injector of the&nbsp;<em>component-under-test</em></strong>. The component injector is a property of the fixture&#8217;s&nbsp;<code><a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a></code>.WelcomeComponent&#8217;s injector</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The tests need access to the (stub)&nbsp;UserService&nbsp;injected into the&nbsp;WelcomeComponent. Angular has a hierarchical injection system. There can be injectors at multiple levels, from the root injector created by the\u00a0TestBed\u00a0down through the component tree. The safest way to get the injected service, the way that&nbsp;always works, is to&nbsp;get it from the injector of the&nbsp;component-under-test. The component [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4588"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4588"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4588/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4606,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4588/revisions/4606"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4588"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4588"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4588"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4592,
    "date": "2021-02-25T11:27:00",
    "date_gmt": "2021-02-25T11:27:00",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4592"
    },
    "modified": "2021-02-25T11:27:00",
    "modified_gmt": "2021-02-25T11:27:00",
    "slug": "testbed-inject",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/testbed-inject/",
    "title": {
      "rendered": "TestBed.inject()"
    },
    "content": {
      "rendered": "\n<p>You&nbsp;<em>may</em>&nbsp;also be able to get the service from the root injector via&nbsp;<code>TestBed.inject()</code>. This is easier to remember and less verbose. But it only works when Angular injects the component with the service instance in the test&#8217;s root injector.</p>\n\n\n\n<p>In this test suite, the&nbsp;<em>only</em>&nbsp;provider of&nbsp;<code>UserService</code>&nbsp;is the root testing module, so it is safe to call&nbsp;<code>TestBed.inject()</code>&nbsp;as follows:TestBed injector</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>// UserService from the root injector\nuserService = TestBed.inject(UserService);</code></code></pre>\n\n\n\n<p>For a use case in which&nbsp;<code>TestBed.inject()</code>&nbsp;does not work, see the&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#component-override\"><em>Override component providers</em></a>&nbsp;section that explains when and why you must get the service from the component&#8217;s injector instead.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>You&nbsp;may&nbsp;also be able to get the service from the root injector via&nbsp;TestBed.inject(). This is easier to remember and less verbose. But it only works when Angular injects the component with the service instance in the test&#8217;s root injector. In this test suite, the&nbsp;only&nbsp;provider of&nbsp;UserService&nbsp;is the root testing module, so it is safe to call&nbsp;TestBed.inject()&nbsp;as follows:TestBed [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4592"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4592"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4592/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4607,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4592/revisions/4607"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4592"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4592"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4592"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4585,
    "date": "2021-02-25T11:27:21",
    "date_gmt": "2021-02-25T11:27:21",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4585"
    },
    "modified": "2021-02-25T11:27:21",
    "modified_gmt": "2021-02-25T11:27:21",
    "slug": "final-setup-and-tests",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/final-setup-and-tests/",
    "title": {
      "rendered": "Final setup and tests"
    },
    "content": {
      "rendered": "\n<p>Here&#8217;s the complete&nbsp;<code>beforeEach()</code>, using&nbsp;<code>TestBed.inject()</code>:app/welcome/welcome.component.spec.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>let userServiceStub: Partial&lt;UserService&gt;;\n\nbeforeEach(() =&gt; {\n  // stub UserService for test purposes\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n  TestBed.configureTestingModule({\n     declarations: &#91; WelcomeComponent ],\n     providers: &#91; { provide: UserService, useValue: userServiceStub } ],\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // UserService from the root injector\n  userService = TestBed.inject(UserService);\n\n  //  get the \"welcome\" element by CSS selector (e.g., by class name)\n  el = fixture.nativeElement.querySelector('.welcome');\n});</code></code></pre>\n\n\n\n<p>And here are some tests:app/welcome/welcome.component.spec.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should welcome the user', () =&gt; {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).toContain('Welcome', '\"Welcome ...\"');\n  expect(content).toContain('Test User', 'expected name');\n});\n\nit('should welcome \"Bubba\"', () =&gt; {\n  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () =&gt; {\n  userService.isLoggedIn = false; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).not.toContain('Welcome', 'not welcomed');\n  expect(content).toMatch(/log in/i, '\"log in\"');\n});</code></code></pre>\n\n\n\n<p>The first is a sanity test; it confirms that the stubbed&nbsp;<code>UserService</code>&nbsp;is called and working.</p>\n\n\n\n<p>The second parameter to the Jasmine matcher (e.g.,&nbsp;<code>'expected name'</code>) is an optional failure label. If the expectation fails, Jasmine appends this label to the expectation failure message. In a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.</p>\n\n\n\n<p>The remaining tests confirm the logic of the component when the service returns different values. The second test validates the effect of changing the user name. The third test checks that the component displays the proper message when there is no logged-in user.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Here&#8217;s the complete&nbsp;beforeEach(), using&nbsp;TestBed.inject():app/welcome/welcome.component.spec.ts And here are some tests:app/welcome/welcome.component.spec.ts The first is a sanity test; it confirms that the stubbed&nbsp;UserService&nbsp;is called and working. The second parameter to the Jasmine matcher (e.g.,&nbsp;&#8216;expected name&#8217;) is an optional failure label. If the expectation fails, Jasmine appends this label to the expectation failure message. In a spec with multiple [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4585"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4585"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4585/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4608,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4585/revisions/4608"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4585"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4585"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4585"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4584,
    "date": "2021-02-25T11:27:42",
    "date_gmt": "2021-02-25T11:27:42",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4584"
    },
    "modified": "2021-02-25T11:27:42",
    "modified_gmt": "2021-02-25T11:27:42",
    "slug": "component-with-async-service",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/component-with-async-service/",
    "title": {
      "rendered": "Component with async service"
    },
    "content": {
      "rendered": "\n<p>In this sample, the&nbsp;<code>AboutComponent</code>&nbsp;template hosts a&nbsp;<code>TwainComponent</code>. The&nbsp;<code>TwainComponent</code>&nbsp;displays Mark Twain quotes.app/twain/twain.component.ts (template)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>template: `\n  &lt;p class=\"twain\"&gt;&lt;i&gt;{{quote | <a href=\"https://angular.io/api/common/AsyncPipe\">async</a>}}&lt;/i&gt;&lt;/p&gt;\n  &lt;button (click)=\"getQuote()\"&gt;Next quote&lt;/button&gt;\n  &lt;p class=\"error\" *<a href=\"https://angular.io/api/common/NgIf\">ngIf</a>=\"errorMessage\"&gt;{{ errorMessage }}&lt;/p&gt;`,</code></code></pre>\n\n\n\n<p>Note that the value of the component&#8217;s&nbsp;<code>quote</code>&nbsp;property passes through an&nbsp;<code><a href=\"https://angular.io/api/common/AsyncPipe\">AsyncPipe</a></code>. That means the property returns either a&nbsp;<code>Promise</code>&nbsp;or an&nbsp;<code>Observable</code>.</p>\n\n\n\n<p>In this example, the&nbsp;<code>TwainComponent.getQuote()</code>&nbsp;method tells you that the&nbsp;<code>quote</code>&nbsp;property returns an&nbsp;<code>Observable</code>.app/twain/twain.component.ts (getQuote)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>getQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError( (err: any) =&gt; {\n      // Wait a turn because errorMessage already set once this turn\n      setTimeout(() =&gt; this.errorMessage = err.message || err.toString());\n      return of('...'); // reset message to placeholder\n    })\n  );</code></code></pre>\n\n\n\n<p>The&nbsp;<code>TwainComponent</code>&nbsp;gets quotes from an injected&nbsp;<code>TwainService</code>. The component starts the returned&nbsp;<code>Observable</code>&nbsp;with a placeholder value (<code>'...'</code>), before the service can return its first quote.</p>\n\n\n\n<p>The&nbsp;<code>catchError</code>&nbsp;intercepts service errors, prepares an error message, and returns the placeholder value on the success channel. It must wait a tick to set the&nbsp;<code>errorMessage</code>&nbsp;in order to avoid updating that message twice in the same change detection cycle.</p>\n\n\n\n<p>These are all features you&#8217;ll want to test.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>In this sample, the&nbsp;AboutComponent&nbsp;template hosts a&nbsp;TwainComponent. The&nbsp;TwainComponent&nbsp;displays Mark Twain quotes.app/twain/twain.component.ts (template) Note that the value of the component&#8217;s&nbsp;quote&nbsp;property passes through an&nbsp;AsyncPipe. That means the property returns either a&nbsp;Promise&nbsp;or an&nbsp;Observable. In this example, the&nbsp;TwainComponent.getQuote()&nbsp;method tells you that the&nbsp;quote&nbsp;property returns an&nbsp;Observable.app/twain/twain.component.ts (getQuote) The&nbsp;TwainComponent&nbsp;gets quotes from an injected&nbsp;TwainService. The component starts the returned&nbsp;Observable&nbsp;with a placeholder value (&#8216;&#8230;&#8217;), before [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4584"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4584"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4584/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4609,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4584/revisions/4609"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4584"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4584"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4584"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4619,
    "date": "2021-02-25T11:30:17",
    "date_gmt": "2021-02-25T11:30:17",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4619"
    },
    "modified": "2021-02-25T11:30:17",
    "modified_gmt": "2021-02-25T11:30:17",
    "slug": "marble-error-testing",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/marble-error-testing/",
    "title": {
      "rendered": "Marble error testing"
    },
    "content": {
      "rendered": "\n<p>Here&#8217;s the marble testing version of the&nbsp;<code>getQuote()</code>&nbsp;error test.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display error when TwainService fails', <a href=\"https://angular.io/api/core/testing/fakeAsync\">fakeAsync</a>(() =&gt; {\n  // observable error after delay\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // <a href=\"https://angular.io/api/core/testing/flush\">flush</a> the observables\n  <a href=\"https://angular.io/api/core/testing/tick\">tick</a>();                     // component shows error after a setTimeout()\n  fixture.detectChanges();    // update error message\n\n  expect(errorMessage()).toMatch(/test failure/, 'should display error');\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n}));</code></code></pre>\n\n\n\n<p>It&#8217;s still an async test, calling&nbsp;<code><a href=\"https://angular.io/api/core/testing/fakeAsync\">fakeAsync</a>()</code>&nbsp;and&nbsp;<a href=\"https://angular.io/api/core/testing/tick\">tick()</a>, because the component itself calls&nbsp;<code>setTimeout()</code>&nbsp;when processing errors.</p>\n\n\n\n<p>Look at the marble observable definition.</p>\n\n\n\n<pre class=\"wp-block-preformatted\">content_copy<code>const q$ = cold('---#|', null, new Error('TwainService test failure'));</code></pre>\n\n\n\n<p>This is a&nbsp;<em>cold</em>&nbsp;observable that waits three frames and then emits an error, The hash (<code>#</code>) indicates the timing of the error that is specified in the third argument. The second argument is null because the observable never emits a value.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Here&#8217;s the marble testing version of the&nbsp;getQuote()&nbsp;error test. It&#8217;s still an async test, calling&nbsp;fakeAsync()&nbsp;and&nbsp;tick(), because the component itself calls&nbsp;setTimeout()&nbsp;when processing errors. Look at the marble observable definition. content_copyconst q$ = cold(&#8216;&#8212;#|&#8217;, null, new Error(&#8216;TwainService test failure&#8217;)); This is a&nbsp;cold&nbsp;observable that waits three frames and then emits an error, The hash (#) indicates the timing of [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4619"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4619"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4619/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4621,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4619/revisions/4621"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4619"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4619"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4619"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4615,
    "date": "2021-02-25T11:30:42",
    "date_gmt": "2021-02-25T11:30:42",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4615"
    },
    "modified": "2021-02-25T11:30:42",
    "modified_gmt": "2021-02-25T11:30:42",
    "slug": "learn-about-marble-testing",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/learn-about-marble-testing/",
    "title": {
      "rendered": "Learn about marble testing"
    },
    "content": {
      "rendered": "\n<p>A&nbsp;<em>marble frame</em>&nbsp;is a virtual unit of testing time. Each symbol (<code>-</code>,&nbsp;<code>x</code>,&nbsp;<code>|</code>,&nbsp;<code>#</code>) marks the passing of one frame.</p>\n\n\n\n<p>A\u00a0<em>cold</em>\u00a0observable doesn&#8217;t produce values until you subscribe to it. Most of your application observables are cold. All\u00a0<em>HttpClient</em>\u00a0methods return cold observables.</p>\n\n\n\n<p>A\u00a0<em>hot</em>\u00a0observable is already producing values\u00a0<em>before</em>\u00a0you subscribe to it. The\u00a0<em>Router.events</em>\u00a0observable, which reports router activity, is a\u00a0<em>hot</em>\u00a0observable.</p>\n\n\n\n<p>RxJS marble testing is a rich subject, beyond the scope of this guide. Learn about it on the web, starting with the\u00a0official documentation.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>A&nbsp;marble frame&nbsp;is a virtual unit of testing time. Each symbol (-,&nbsp;x,&nbsp;|,&nbsp;#) marks the passing of one frame. A\u00a0cold\u00a0observable doesn&#8217;t produce values until you subscribe to it. Most of your application observables are cold. All\u00a0HttpClient\u00a0methods return cold observables. A\u00a0hot\u00a0observable is already producing values\u00a0before\u00a0you subscribe to it. The\u00a0Router.events\u00a0observable, which reports router activity, is a\u00a0hot\u00a0observable. RxJS marble testing [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4615"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4615"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4615/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4622,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4615/revisions/4622"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4615"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4615"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4615"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4618,
    "date": "2021-02-25T11:31:10",
    "date_gmt": "2021-02-25T11:31:10",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4618"
    },
    "modified": "2021-02-25T11:31:10",
    "modified_gmt": "2021-02-25T11:31:10",
    "slug": "component-with-inputs-and-outputs",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/component-with-inputs-and-outputs/",
    "title": {
      "rendered": "Component with inputs and outputs"
    },
    "content": {
      "rendered": "\n<p>A component with inputs and outputs typically appears inside the view template of a host component. The host uses a property binding to set the input property and an event binding to listen to events raised by the output property.</p>\n\n\n\n<p>The testing goal is to verify that such bindings work as expected. The tests should set input values and listen for output events.</p>\n\n\n\n<p>The&nbsp;<code>DashboardHeroComponent</code>&nbsp;is a tiny example of a component in this role. It displays an individual hero provided by the&nbsp;<code>DashboardComponent</code>. Clicking that hero tells the&nbsp;<code>DashboardComponent</code>&nbsp;that the user has selected the hero.</p>\n\n\n\n<p>The&nbsp;<code>DashboardHeroComponent</code>&nbsp;is embedded in the&nbsp;<code>DashboardComponent</code>&nbsp;template like this:app/dashboard/dashboard.component.html (excerpt)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>&lt;dashboard-hero *<a href=\"https://angular.io/api/common/NgForOf\">ngFor</a>=\"let hero of heroes\"  class=\"col-1-4\"\n  &#91;hero]=hero  (selected)=\"gotoDetail($event)\" &gt;\n&lt;/dashboard-hero&gt;</code></code></pre>\n\n\n\n<p>The&nbsp;<code>DashboardHeroComponent</code>&nbsp;appears in an&nbsp;<code>*<a href=\"https://angular.io/api/common/NgForOf\">ngFor</a></code>&nbsp;repeater, which sets each component&#8217;s&nbsp;<code>hero</code>&nbsp;input property to the looping value and listens for the component&#8217;s&nbsp;<code>selected</code>&nbsp;event.</p>\n\n\n\n<p>Here&#8217;s the component&#8217;s full definition:app/dashboard/dashboard-hero.component.ts (component)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  selector: 'dashboard-hero',\n  template: `\n    &lt;div (click)=\"click()\" class=\"hero\"&gt;\n      {{hero.name | <a href=\"https://angular.io/api/common/UpperCasePipe\">uppercase</a>}}\n    &lt;/div&gt;`,\n  styleUrls: &#91; './dashboard-hero.component.css' ]\n})\nexport class DashboardHeroComponent {\n  @<a href=\"https://angular.io/api/core/Input\">Input</a>() hero: Hero;\n  @<a href=\"https://angular.io/api/core/Output\">Output</a>() selected = new <a href=\"https://angular.io/api/core/EventEmitter\">EventEmitter</a>&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}</code></code></pre>\n\n\n\n<p>While testing a component this simple has little intrinsic value, it&#8217;s worth knowing how. You can use one of these approaches:</p>\n\n\n\n<ul><li>Test it as used by&nbsp;<code>DashboardComponent</code>.</li><li>Test it as a stand-alone component.</li><li>Test it as used by a substitute for&nbsp;<code>DashboardComponent</code>.</li></ul>\n\n\n\n<p>A quick look at the&nbsp;<code>DashboardComponent</code>&nbsp;constructor discourages the first approach:app/dashboard/dashboard.component.ts (constructor)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>constructor(\n  private router: <a href=\"https://angular.io/api/router/Router\">Router</a>,\n  private heroService: HeroService) {\n}</code></code></pre>\n\n\n\n<p>The&nbsp;<code>DashboardComponent</code>&nbsp;depends on the Angular router and the&nbsp;<code>HeroService</code>. You&#8217;d probably have to replace them both with test doubles, which is a lot of work. The router seems particularly challenging.</p>\n\n\n\n<p>The&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#routing-component\">discussion below</a>&nbsp;covers testing components that require the router.</p>\n\n\n\n<p>The immediate goal is to test the&nbsp;<code>DashboardHeroComponent</code>, not the&nbsp;<code>DashboardComponent</code>, so, try the second and third options.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>A component with inputs and outputs typically appears inside the view template of a host component. The host uses a property binding to set the input property and an event binding to listen to events raised by the output property. The testing goal is to verify that such bindings work as expected. The tests should [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4618"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4618"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4618/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4623,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4618/revisions/4623"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4618"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4618"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4618"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4613,
    "date": "2021-02-25T11:31:34",
    "date_gmt": "2021-02-25T11:31:34",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4613"
    },
    "modified": "2021-02-25T11:31:34",
    "modified_gmt": "2021-02-25T11:31:34",
    "slug": "test-dashboardherocomponent-stand-alone",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/test-dashboardherocomponent-stand-alone/",
    "title": {
      "rendered": "Test DashboardHeroComponent stand-alone"
    },
    "content": {
      "rendered": "\n<p>Here&#8217;s the meat of the spec file setup.app/dashboard/dashboard-hero.component.spec.ts (setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({declarations: &#91;DashboardHeroComponent]})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp = fixture.componentInstance;\n\n// find the hero's <a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a> and element\nheroDe = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// mock the hero supplied by the parent component\nexpectedHero = {id: 42, name: 'Test Name'};\n\n// simulate the parent setting the input property with that hero\ncomp.hero = expectedHero;\n\n// <a href=\"https://angular.io/api/animations/trigger\">trigger</a> initial data binding\nfixture.detectChanges();</code></code></pre>\n\n\n\n<p>Note how the setup code assigns a test hero (<code>expectedHero</code>) to the component&#8217;s&nbsp;<code>hero</code>&nbsp;property, emulating the way the&nbsp;<code>DashboardComponent</code>&nbsp;would set it via the property binding in its repeater.</p>\n\n\n\n<p>The following test verifies that the hero name is propagated to the template via a binding.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display hero name in uppercase', () =&gt; {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});</code></code></pre>\n\n\n\n<p>Because the&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#dashboard-hero-component\">template</a>&nbsp;passes the hero name through the Angular&nbsp;<code><a href=\"https://angular.io/api/common/UpperCasePipe\">UpperCasePipe</a></code>, the test must match the element value with the upper-cased name.</p>\n\n\n\n<p>This small test demonstrates how Angular tests can verify a component&#8217;s visual representation\u2014something not possible with&nbsp;<a href=\"https://angular.io/guide/testing-components-basics#component-class-testing\">component class tests</a>\u2014at low cost and without resorting to much slower and more complicated end-to-end tests.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Here&#8217;s the meat of the spec file setup.app/dashboard/dashboard-hero.component.spec.ts (setup) Note how the setup code assigns a test hero (expectedHero) to the component&#8217;s&nbsp;hero&nbsp;property, emulating the way the&nbsp;DashboardComponent&nbsp;would set it via the property binding in its repeater. The following test verifies that the hero name is propagated to the template via a binding. Because the&nbsp;template&nbsp;passes the hero [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4613"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4613"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4613/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4624,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4613/revisions/4624"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4613"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4613"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4613"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4616,
    "date": "2021-02-25T11:32:12",
    "date_gmt": "2021-02-25T11:32:12",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4616"
    },
    "modified": "2021-02-25T11:32:12",
    "modified_gmt": "2021-02-25T11:32:12",
    "slug": "clicking",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/clicking/",
    "title": {
      "rendered": "Clicking"
    },
    "content": {
      "rendered": "\n<p>Clicking the hero should raise a&nbsp;<code>selected</code>&nbsp;event that the host component (<code>DashboardComponent</code>&nbsp;presumably) can hear:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should raise selected event when clicked (triggerEventHandler)', () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroDe.triggerEventHandler('click', null);\n  expect(selectedHero).toBe(expectedHero);\n});</code></code></pre>\n\n\n\n<p>The component&#8217;s&nbsp;<code>selected</code>&nbsp;property returns an&nbsp;<code><a href=\"https://angular.io/api/core/EventEmitter\">EventEmitter</a></code>, which looks like an RxJS synchronous&nbsp;<code>Observable</code>&nbsp;to consumers. The test subscribes to it&nbsp;<em>explicitly</em>&nbsp;just as the host component does&nbsp;<em>implicitly</em>.</p>\n\n\n\n<p>If the component behaves as expected, clicking the hero&#8217;s element should tell the component&#8217;s&nbsp;<code>selected</code>&nbsp;property to emit the&nbsp;<code>hero</code>&nbsp;object.</p>\n\n\n\n<p>The test detects that event through its subscription to&nbsp;<code>selected</code>.</p>\n\n\n\n<h4 id=\"triggereventhandler\"><em>triggerEventHandler</em></h4>\n\n\n\n<p>The&nbsp;<code>heroDe</code>&nbsp;in the previous test is a&nbsp;<code><a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a></code>&nbsp;that represents the hero&nbsp;<code>&lt;div&gt;</code>.</p>\n\n\n\n<p>It has Angular properties and methods that abstract interaction with the native element. This test calls the&nbsp;<code>DebugElement.triggerEventHandler</code>&nbsp;with the &#8220;click&#8221; event name. The &#8220;click&#8221; event binding responds by calling&nbsp;<code>DashboardHeroComponent.click()</code>.</p>\n\n\n\n<p>The Angular&nbsp;<code>DebugElement.triggerEventHandler</code>&nbsp;can raise&nbsp;<em>any data-bound event</em>&nbsp;by its&nbsp;<em>event name</em>. The second parameter is the event object passed to the handler.</p>\n\n\n\n<p>The test triggered a &#8220;click&#8221; event with a&nbsp;<code>null</code>&nbsp;event object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>heroDe.triggerEventHandler('click', null);</code></code></pre>\n\n\n\n<p>The test assumes (correctly in this case) that the runtime event handler\u2014the component&#8217;s&nbsp;<code>click()</code>&nbsp;method\u2014doesn&#8217;t care about the event object.</p>\n\n\n\n<p>Other handlers are less forgiving. For example, the&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;directive expects an object with a&nbsp;<code>button</code>&nbsp;property that identifies which mouse button (if any) was pressed during the click. The&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;directive throws an error if the event object is missing.</p>\n\n\n\n<h4 id=\"click-the-element\">Click the element</h4>\n\n\n\n<p>The following test alternative calls the native element&#8217;s own&nbsp;<code>click()</code>&nbsp;method, which is perfectly fine for&nbsp;<em>this component</em>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should raise selected event when clicked (element.click)', () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});</code></code></pre>\n\n\n\n<h4 id=\"click-helper\"><em>click()</em>&nbsp;helper</h4>\n\n\n\n<p>Clicking a button, an anchor, or an arbitrary HTML element is a common test task.</p>\n\n\n\n<p>Make that consistent and easy by encapsulating the&nbsp;<em>click-triggering</em>&nbsp;process in a helper such as the&nbsp;<code>click()</code>&nbsp;function below:testing/index.ts (click helper)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>/** Button events to pass to `DebugElement.triggerEventHandler` for <a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a> event handler */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** Simulate element click. Defaults to mouse left-button click event. */\nexport function click(el: <a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a> | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}</code></code></pre>\n\n\n\n<p>The first parameter is the&nbsp;<em>element-to-click</em>. If you wish, you can pass a custom event object as the second parameter. The default is a (partial)&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">left-button mouse event object</a>&nbsp;accepted by many handlers including the&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;directive.</p>\n\n\n\n<p>The&nbsp;<code>click()</code>&nbsp;helper function is&nbsp;<strong>not</strong>&nbsp;one of the Angular testing utilities. It&#8217;s a function defined in&nbsp;<em>this guide&#8217;s sample code</em>. All of the sample tests use it. If you like it, add it to your own collection of helpers.</p>\n\n\n\n<p>Here&#8217;s the previous test, rewritten using the click helper.app/dashboard/dashboard-hero.component.spec.ts (test with click helper)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should raise selected event when clicked (click helper)', () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  click(heroDe);  // click helper with <a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a>\n  click(heroEl);  // click helper with native element\n\n  expect(selectedHero).toBe(expectedHero);\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Clicking the hero should raise a&nbsp;selected&nbsp;event that the host component (DashboardComponent&nbsp;presumably) can hear: The component&#8217;s&nbsp;selected&nbsp;property returns an&nbsp;EventEmitter, which looks like an RxJS synchronous&nbsp;Observable&nbsp;to consumers. The test subscribes to it&nbsp;explicitly&nbsp;just as the host component does&nbsp;implicitly. If the component behaves as expected, clicking the hero&#8217;s element should tell the component&#8217;s&nbsp;selected&nbsp;property to emit the&nbsp;hero&nbsp;object. The test detects that [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4616"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4616"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4616/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4625,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4616/revisions/4625"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4616"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4616"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4616"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4614,
    "date": "2021-02-25T11:32:43",
    "date_gmt": "2021-02-25T11:32:43",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4614"
    },
    "modified": "2021-02-25T11:32:43",
    "modified_gmt": "2021-02-25T11:32:43",
    "slug": "component-inside-a-test-host",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/component-inside-a-test-host/",
    "title": {
      "rendered": "Component inside a test host"
    },
    "content": {
      "rendered": "\n<p>The previous tests played the role of the host&nbsp;<code>DashboardComponent</code>&nbsp;themselves. But does the&nbsp;<code>DashboardHeroComponent</code>&nbsp;work correctly when properly data-bound to a host component?</p>\n\n\n\n<p>You could test with the actual&nbsp;<code>DashboardComponent</code>. But doing so could require a lot of setup, especially when its template features an&nbsp;<code>*<a href=\"https://angular.io/api/common/NgForOf\">ngFor</a></code>&nbsp;repeater, other components, layout HTML, additional bindings, a constructor that injects multiple services, and it starts interacting with those services right away.</p>\n\n\n\n<p>Imagine the effort to disable these distractions, just to prove a point that can be made satisfactorily with a&nbsp;<em>test host</em>&nbsp;like this one:app/dashboard/dashboard-hero.component.spec.ts (test host)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  template: `\n    &lt;dashboard-hero\n      &#91;hero]=\"hero\" (selected)=\"onSelected($event)\"&gt;\n    &lt;/dashboard-hero&gt;`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: 'Test Name'};\n  selectedHero: Hero;\n  onSelected(hero: Hero) {\n    this.selectedHero = hero;\n  }\n}</code></code></pre>\n\n\n\n<p>This test host binds to&nbsp;<code>DashboardHeroComponent</code>&nbsp;as the&nbsp;<code>DashboardComponent</code>&nbsp;would but without the noise of the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>, the&nbsp;<code>HeroService</code>, or the&nbsp;<code>*<a href=\"https://angular.io/api/common/NgForOf\">ngFor</a></code>&nbsp;repeater.</p>\n\n\n\n<p>The test host sets the component&#8217;s&nbsp;<code>hero</code>&nbsp;input property with its test hero. It binds the component&#8217;s&nbsp;<code>selected</code>&nbsp;event with its&nbsp;<code>onSelected</code>&nbsp;handler, which records the emitted hero in its&nbsp;<code>selectedHero</code>&nbsp;property.</p>\n\n\n\n<p>Later, the tests will be able to easily check&nbsp;<code>selectedHero</code>&nbsp;to verify that the&nbsp;<code>DashboardHeroComponent.selected</code>&nbsp;event emitted the expected hero.</p>\n\n\n\n<p>The setup for the&nbsp;<em>test-host</em>&nbsp;tests is similar to the setup for the stand-alone tests:app/dashboard/dashboard-hero.component.spec.ts (test host setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({declarations: &#91;DashboardHeroComponent, TestHostComponent]})\n// create TestHostComponent instead of DashboardHeroComponent\nfixture = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges();  // <a href=\"https://angular.io/api/animations/trigger\">trigger</a> initial data binding</code></code></pre>\n\n\n\n<p>This testing module configuration shows three important differences:</p>\n\n\n\n<ol><li>It&nbsp;<em>declares</em>&nbsp;both the&nbsp;<code>DashboardHeroComponent</code>&nbsp;and the&nbsp;<code>TestHostComponent</code>.</li><li>It&nbsp;<em>creates</em>&nbsp;the&nbsp;<code>TestHostComponent</code>&nbsp;instead of the&nbsp;<code>DashboardHeroComponent</code>.</li><li>The&nbsp;<code>TestHostComponent</code>&nbsp;sets the&nbsp;<code>DashboardHeroComponent.hero</code>&nbsp;with a binding.</li></ol>\n\n\n\n<p>The&nbsp;<code>createComponent</code>&nbsp;returns a&nbsp;<code>fixture</code>&nbsp;that holds an instance of&nbsp;<code>TestHostComponent</code>&nbsp;instead of an instance of&nbsp;<code>DashboardHeroComponent</code>.</p>\n\n\n\n<p>Creating the&nbsp;<code>TestHostComponent</code>&nbsp;has the side-effect of creating a&nbsp;<code>DashboardHeroComponent</code>&nbsp;because the latter appears within the template of the former. The query for the hero element (<code>heroEl</code>) still finds it in the test DOM, albeit at greater depth in the element tree than before.</p>\n\n\n\n<p>The tests themselves are almost identical to the stand-alone version:app/dashboard/dashboard-hero.component.spec.ts (test-host)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display hero name', () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () =&gt; {\n  click(heroEl);\n  // selected hero should be the same data bound hero\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});</code></code></pre>\n\n\n\n<p>Only the selected event test differs. It confirms that the selected&nbsp;<code>DashboardHeroComponent</code>&nbsp;hero really does find its way up through the event binding to the host component.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The previous tests played the role of the host&nbsp;DashboardComponent&nbsp;themselves. But does the&nbsp;DashboardHeroComponent&nbsp;work correctly when properly data-bound to a host component? You could test with the actual&nbsp;DashboardComponent. But doing so could require a lot of setup, especially when its template features an&nbsp;*ngFor&nbsp;repeater, other components, layout HTML, additional bindings, a constructor that injects multiple services, and it [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4614"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4614"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4614/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4626,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4614/revisions/4626"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4614"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4614"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4614"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4612,
    "date": "2021-02-25T11:33:15",
    "date_gmt": "2021-02-25T11:33:15",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4612"
    },
    "modified": "2021-02-25T11:33:15",
    "modified_gmt": "2021-02-25T11:33:15",
    "slug": "routing-component",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/routing-component/",
    "title": {
      "rendered": "Routing component"
    },
    "content": {
      "rendered": "\n<p>A&nbsp;<em>routing component</em>&nbsp;is a component that tells the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;to navigate to another component. The&nbsp;<code>DashboardComponent</code>&nbsp;is a&nbsp;<em>routing component</em>&nbsp;because the user can navigate to the&nbsp;<code>HeroDetailComponent</code>&nbsp;by clicking on one of the&nbsp;<em>hero buttons</em>&nbsp;on the dashboard.</p>\n\n\n\n<p>Routing is pretty complicated. Testing the&nbsp;<code>DashboardComponent</code>&nbsp;seemed daunting in part because it involves the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>, which it injects together with the&nbsp;<code>HeroService</code>.app/dashboard/dashboard.component.ts (constructor)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>constructor(\n  private router: <a href=\"https://angular.io/api/router/Router\">Router</a>,\n  private heroService: HeroService) {\n}</code></code></pre>\n\n\n\n<p>Mocking the&nbsp;<code>HeroService</code>&nbsp;with a spy is a&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#component-with-async-service\">familiar story</a>. But the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;has a complicated API and is entwined with other services and application preconditions. Might it be difficult to mock?</p>\n\n\n\n<p>Fortunately, not in this case because the&nbsp;<code>DashboardComponent</code>&nbsp;isn&#8217;t doing much with the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>app/dashboard/dashboard.component.ts (goToDetail)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>gotoDetail(hero: Hero) {\n  const url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}</code></code></pre>\n\n\n\n<p>This is often the case with&nbsp;<em>routing components</em>. As a rule you test the component, not the router, and care only if the component navigates with the right address under the given conditions.</p>\n\n\n\n<p>Providing a router spy for&nbsp;<em>this component</em>&nbsp;test suite happens to be as easy as providing a&nbsp;<code>HeroService</code>&nbsp;spy.app/dashboard/dashboard.component.spec.ts (spies)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>const routerSpy = jasmine.createSpyObj('<a href=\"https://angular.io/api/router/Router\">Router</a>', &#91;'navigateByUrl']);\nconst heroServiceSpy = jasmine.createSpyObj('HeroService', &#91;'getHeroes']);\n\n<a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({\n      providers: &#91;\n        {provide: HeroService, useValue: heroServiceSpy}, {provide: <a href=\"https://angular.io/api/router/Router\">Router</a>, useValue: routerSpy}\n      ]\n    })</code></code></pre>\n\n\n\n<p>The following test clicks the displayed hero and confirms that&nbsp;<code>Router.navigateByUrl</code>&nbsp;is called with the expected url.app/dashboard/dashboard.component.spec.ts (navigate test)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should tell ROUTER to navigate when hero clicked', () =&gt; {\n  heroClick();  // <a href=\"https://angular.io/api/animations/trigger\">trigger</a> click on first inner &lt;div class=\"hero\"&gt;\n\n  // args passed to router.navigateByUrl() spy\n  const spy = router.navigateByUrl as jasmine.Spy;\n  const navArgs = spy.calls.first().args&#91;0];\n\n  // expecting to navigate to id of the component's first hero\n  const id = comp.heroes&#91;0].id;\n  expect(navArgs).toBe('/heroes/' + id, 'should nav to HeroDetail for first hero');\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>A&nbsp;routing component&nbsp;is a component that tells the&nbsp;Router&nbsp;to navigate to another component. The&nbsp;DashboardComponent&nbsp;is a&nbsp;routing component&nbsp;because the user can navigate to the&nbsp;HeroDetailComponent&nbsp;by clicking on one of the&nbsp;hero buttons&nbsp;on the dashboard. Routing is pretty complicated. Testing the&nbsp;DashboardComponent&nbsp;seemed daunting in part because it involves the&nbsp;Router, which it injects together with the&nbsp;HeroService.app/dashboard/dashboard.component.ts (constructor) Mocking the&nbsp;HeroService&nbsp;with a spy is a&nbsp;familiar story. [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4612"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4612"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4612/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4627,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4612/revisions/4627"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4612"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4612"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4612"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4611,
    "date": "2021-02-25T11:34:11",
    "date_gmt": "2021-02-25T11:34:11",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4611"
    },
    "modified": "2021-02-25T11:34:11",
    "modified_gmt": "2021-02-25T11:34:11",
    "slug": "routed-components",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/routed-components/",
    "title": {
      "rendered": "Routed components"
    },
    "content": {
      "rendered": "\n<p>A&nbsp;<em>routed component</em>&nbsp;is the destination of a&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;navigation. It can be trickier to test, especially when the route to the component&nbsp;<em>includes parameters</em>. The&nbsp;<code>HeroDetailComponent</code>&nbsp;is a&nbsp;<em>routed component</em>&nbsp;that is the destination of such a route.</p>\n\n\n\n<p>When a user clicks a&nbsp;<em>Dashboard</em>&nbsp;hero, the&nbsp;<code>DashboardComponent</code>&nbsp;tells the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;to navigate to&nbsp;<code>heroes/:id</code>. The&nbsp;<code>:id</code>&nbsp;is a route parameter whose value is the&nbsp;<code>id</code>&nbsp;of the hero to edit.</p>\n\n\n\n<p>The&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;matches that URL to a route to the&nbsp;<code>HeroDetailComponent</code>. It creates an&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a></code>&nbsp;object with the routing information and injects it into a new instance of the&nbsp;<code>HeroDetailComponent</code>.</p>\n\n\n\n<p>Here&#8217;s the&nbsp;<code>HeroDetailComponent</code>&nbsp;constructor:app/hero/hero-detail.component.ts (constructor)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>constructor(\n  private heroDetailService: HeroDetailService,\n  private route: <a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a>,\n  private router: <a href=\"https://angular.io/api/router/Router\">Router</a>) {\n}</code></code></pre>\n\n\n\n<p>The&nbsp;<code>HeroDetail</code>&nbsp;component needs the&nbsp;<code>id</code>&nbsp;parameter so it can fetch the corresponding hero via the&nbsp;<code>HeroDetailService</code>. The component has to get the&nbsp;<code>id</code>&nbsp;from the&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute#paramMap\">ActivatedRoute.paramMap</a></code>&nbsp;property which is an&nbsp;<code>Observable</code>.</p>\n\n\n\n<p>It can&#8217;t just reference the&nbsp;<code>id</code>&nbsp;property of the&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute#paramMap\">ActivatedRoute.paramMap</a></code>. The component has to&nbsp;<em>subscribe</em>&nbsp;to the&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute#paramMap\">ActivatedRoute.paramMap</a></code>&nbsp;observable and be prepared for the&nbsp;<code>id</code>&nbsp;to change during its lifetime.app/hero/hero-detail.component.ts (ngOnInit)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>ngOnInit(): void {\n  // get hero when `id` param changes\n  this.route.paramMap.subscribe(pmap =&gt; this.getHero(pmap.get('id')));\n}</code></code></pre>\n\n\n\n<p>The&nbsp;<a href=\"https://angular.io/guide/router-tutorial-toh#activated-route-in-action\">ActivatedRoute in action</a>&nbsp;section of the&nbsp;<a href=\"https://angular.io/guide/router-tutorial-toh\">Router tutorial: tour of heroes</a>&nbsp;guide covers&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute#paramMap\">ActivatedRoute.paramMap</a></code>&nbsp;in more detail.</p>\n\n\n\n<p>Tests can explore how the&nbsp;<code>HeroDetailComponent</code>&nbsp;responds to different&nbsp;<code>id</code>&nbsp;parameter values by manipulating the&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a></code>&nbsp;injected into the component&#8217;s constructor.</p>\n\n\n\n<p>You know how to spy on the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;and a data service.</p>\n\n\n\n<p>You&#8217;ll take a different approach with&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a></code>&nbsp;because</p>\n\n\n\n<ul><li><code>paramMap</code>&nbsp;returns an&nbsp;<code>Observable</code>&nbsp;that can emit more than one value during a test.</li><li>You need the router helper function,&nbsp;<code><a href=\"https://angular.io/api/router/convertToParamMap\">convertToParamMap</a>()</code>, to create a&nbsp;<code><a href=\"https://angular.io/api/router/ParamMap\">ParamMap</a></code>.</li><li>Other&nbsp;<em>routed component</em>&nbsp;tests need a test double for&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a></code>.</li></ul>\n\n\n\n<p>These differences argue for a re-usable stub class.</p>\n\n\n\n<h4 id=\"activatedroutestub\"><em>ActivatedRouteStub</em></h4>\n\n\n\n<p>The following&nbsp;<code>ActivatedRouteStub</code>&nbsp;class serves as a test double for&nbsp;<code><a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a></code>.testing/activated-route-stub.ts (ActivatedRouteStub)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>import { <a href=\"https://angular.io/api/router/convertToParamMap\">convertToParamMap</a>, <a href=\"https://angular.io/api/router/ParamMap\">ParamMap</a>, <a href=\"https://angular.io/api/router/Params\">Params</a> } from '@angular/router';\nimport { ReplaySubject } from 'rxjs';\n\n/**\n * An ActivateRoute test double with a `paramMap` observable.\n * Use the `setParamMap()` method to add the next `paramMap` value.\n */\nexport class ActivatedRouteStub {\n  // Use a ReplaySubject to share previous values with subscribers\n  // and pump new values into the `paramMap` observable\n  private subject = new ReplaySubject&lt;<a href=\"https://angular.io/api/router/ParamMap\">ParamMap</a>&gt;();\n\n  constructor(initialParams?: <a href=\"https://angular.io/api/router/Params\">Params</a>) {\n    this.setParamMap(initialParams);\n  }\n\n  /** The mock paramMap observable */\n  readonly paramMap = this.subject.asObservable();\n\n  /** Set the paramMap observables's next value */\n  setParamMap(params?: <a href=\"https://angular.io/api/router/Params\">Params</a>) {\n    this.subject.next(<a href=\"https://angular.io/api/router/convertToParamMap\">convertToParamMap</a>(params));\n  }\n}</code></code></pre>\n\n\n\n<p>Consider placing such helpers in a&nbsp;<code>testing</code>&nbsp;folder sibling to the&nbsp;<code>app</code>&nbsp;folder. This sample puts&nbsp;<code>ActivatedRouteStub</code>&nbsp;in&nbsp;<code>testing/activated-route-stub.ts</code>.</p>\n\n\n\n<p>Consider writing a more capable version of this stub class with the&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#marble-testing\"><em>marble testing library</em></a>.</p>\n\n\n\n<h4 id=\"testing-with-activatedroutestub\">Testing with&nbsp;<em>ActivatedRouteStub</em></h4>\n\n\n\n<p>Here&#8217;s a test demonstrating the component&#8217;s behavior when the observed&nbsp;<code>id</code>&nbsp;refers to an existing hero:app/hero/hero-detail.component.spec.ts (existing id)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>describe('when navigate to existing hero', () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n    expectedHero = firstHero;\n    activatedRoute.setParamMap({id: expectedHero.id});\n    createComponent();\n  }));\n\n  it('should display that hero\\'s name', () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});</code></code></pre>\n\n\n\n<p>The&nbsp;<code>createComponent()</code>&nbsp;method and&nbsp;<code>page</code>&nbsp;object are discussed&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#page-object\">below</a>. Rely on your intuition for now.</p>\n\n\n\n<p>When the&nbsp;<code>id</code>&nbsp;cannot be found, the component should re-route to the&nbsp;<code>HeroListComponent</code>.</p>\n\n\n\n<p>The test suite setup provided the same router spy&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#routing-component\">described above</a>&nbsp;which spies on the router without actually navigating.</p>\n\n\n\n<p>This test expects the component to try to navigate to the&nbsp;<code>HeroListComponent</code>.app/hero/hero-detail.component.spec.ts (bad id)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>describe('when navigate to non-existent hero id', () =&gt; {\n  beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n    activatedRoute.setParamMap({id: 99999});\n    createComponent();\n  }));\n\n  it('should try to navigate back to hero list', () =&gt; {\n    expect(page.gotoListSpy.calls.any()).toBe(true, 'comp.gotoList called');\n    expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n  });\n});</code></code></pre>\n\n\n\n<p>While this app doesn&#8217;t have a route to the&nbsp;<code>HeroDetailComponent</code>&nbsp;that omits the&nbsp;<code>id</code>&nbsp;parameter, it might add such a route someday. The component should do something reasonable when there is no&nbsp;<code>id</code>.</p>\n\n\n\n<p>In this implementation, the component should create and display a new hero. New heroes have&nbsp;<code>id=0</code>&nbsp;and a blank&nbsp;<code>name</code>. This test confirms that the component behaves as expected:app/hero/hero-detail.component.spec.ts (no id)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>describe('when navigate with no hero id', () =&gt; {\n  beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(createComponent));\n\n  it('should have hero.id === 0', () =&gt; {\n    expect(component.hero.id).toBe(0);\n  });\n\n  it('should display empty hero name', () =&gt; {\n    expect(page.nameDisplay.textContent).toBe('');\n  });\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>A&nbsp;routed component&nbsp;is the destination of a&nbsp;Router&nbsp;navigation. It can be trickier to test, especially when the route to the component&nbsp;includes parameters. The&nbsp;HeroDetailComponent&nbsp;is a&nbsp;routed component&nbsp;that is the destination of such a route. When a user clicks a&nbsp;Dashboard&nbsp;hero, the&nbsp;DashboardComponent&nbsp;tells the&nbsp;Router&nbsp;to navigate to&nbsp;heroes/:id. The&nbsp;:id&nbsp;is a route parameter whose value is the&nbsp;id&nbsp;of the hero to edit. The&nbsp;Router&nbsp;matches that URL to [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4611"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4611"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4611/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4628,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4611/revisions/4628"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4611"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4611"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4611"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4610,
    "date": "2021-02-25T11:34:50",
    "date_gmt": "2021-02-25T11:34:50",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4610"
    },
    "modified": "2021-02-25T11:34:50",
    "modified_gmt": "2021-02-25T11:34:50",
    "slug": "nested-component-tests",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/nested-component-tests/",
    "title": {
      "rendered": "Nested component tests"
    },
    "content": {
      "rendered": "\n<p>Component templates often have nested components, whose templates may contain more components.</p>\n\n\n\n<p>The component tree can be very deep and, most of the time, the nested components play no role in testing the component at the top of the tree.</p>\n\n\n\n<p>The&nbsp;<code>AppComponent</code>, for example, displays a navigation bar with anchors and their&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;directives.app/app.component.html</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>&lt;app-banner&gt;&lt;/app-banner&gt;\n&lt;app-welcome&gt;&lt;/app-welcome&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>&gt;&lt;/<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>&gt;</code></code></pre>\n\n\n\n<p>While the&nbsp;<code>AppComponent</code>&nbsp;<em>class</em>&nbsp;is empty, you may want to write unit tests to confirm that the links are wired properly to the&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;directives, perhaps for the reasons&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#why-stubbed-routerlink-tests\">explained below</a>.</p>\n\n\n\n<p>To validate the links, you don&#8217;t need the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;to navigate and you don&#8217;t need the&nbsp;<code>&lt;<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>&gt;</code>&nbsp;to mark where the&nbsp;<code><a href=\"https://angular.io/api/router/Router\">Router</a></code>&nbsp;inserts&nbsp;<em>routed components</em>.</p>\n\n\n\n<p>The&nbsp;<code>BannerComponent</code>&nbsp;and&nbsp;<code>WelcomeComponent</code>&nbsp;(indicated by&nbsp;<code>&lt;app-banner&gt;</code>&nbsp;and&nbsp;<code>&lt;app-welcome&gt;</code>) are also irrelevant.</p>\n\n\n\n<p>Yet any test that creates the&nbsp;<code>AppComponent</code>&nbsp;in the DOM will also create instances of these three components and, if you let that happen, you&#8217;ll have to configure the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;to create them.</p>\n\n\n\n<p>If you neglect to declare them, the Angular compiler won&#8217;t recognize the&nbsp;<code>&lt;app-banner&gt;</code>,&nbsp;<code>&lt;app-welcome&gt;</code>, and&nbsp;<code>&lt;<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>&gt;</code>&nbsp;tags in the&nbsp;<code>AppComponent</code>&nbsp;template and will throw an error.</p>\n\n\n\n<p>If you declare the real components, you&#8217;ll also have to declare&nbsp;<em>their</em>&nbsp;nested components and provide for&nbsp;<em>all</em>&nbsp;services injected in&nbsp;<em>any</em>&nbsp;component in the tree.</p>\n\n\n\n<p>That&#8217;s too much effort just to answer a few simple questions about links.</p>\n\n\n\n<p>This section describes two techniques for minimizing the setup. Use them, alone or in combination, to stay focused on testing the primary component.</p>\n\n\n\n<h5 id=\"stubbing-unneeded-components\">Stubbing unneeded components</h5>\n\n\n\n<p>In the first technique, you create and declare stub versions of the components and directive that play little or no role in the tests.app/app.component.spec.ts (stub declaration)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Component\">Component</a>({selector: 'app-banner', template: ''})\nclass BannerStubComponent {\n}\n\n@<a href=\"https://angular.io/api/core/Component\">Component</a>({selector: '<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>', template: ''})\nclass RouterOutletStubComponent {\n}\n\n@<a href=\"https://angular.io/api/core/Component\">Component</a>({selector: 'app-welcome', template: ''})\nclass WelcomeStubComponent {\n}</code></code></pre>\n\n\n\n<p>The stub selectors match the selectors for the corresponding real components. But their templates and classes are empty.</p>\n\n\n\n<p>Then declare them in the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;configuration next to the components, directives, and pipes that need to be real.app/app.component.spec.ts (TestBed stubs)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({\n      declarations: &#91;\n        AppComponent, RouterLinkDirectiveStub, BannerStubComponent, RouterOutletStubComponent,\n        WelcomeStubComponent\n      ]\n    })</code></code></pre>\n\n\n\n<p>The&nbsp;<code>AppComponent</code>&nbsp;is the test subject, so of course you declare the real version.</p>\n\n\n\n<p>The&nbsp;<code>RouterLinkDirectiveStub</code>,&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#routerlink\">described later</a>, is a test version of the real&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;that helps with the link tests.</p>\n\n\n\n<p>The rest are stubs.</p>\n\n\n\n<h4 id=\"no_errors_schema\"><em>NO_ERRORS_SCHEMA</em></h4>\n\n\n\n<p>In the second approach, add&nbsp;<code><a href=\"https://angular.io/api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a></code>&nbsp;to the&nbsp;<code>TestBed.schemas</code>&nbsp;metadata.app/app.component.spec.ts (NO_ERRORS_SCHEMA)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({\n      declarations: &#91;\n        AppComponent,\n        RouterLinkDirectiveStub\n      ],\n      schemas: &#91;<a href=\"https://angular.io/api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a>]\n    })</code></code></pre>\n\n\n\n<p>The&nbsp;<code><a href=\"https://angular.io/api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a></code>&nbsp;tells the Angular compiler to ignore unrecognized elements and attributes.</p>\n\n\n\n<p>The compiler will recognize the&nbsp;<code>&lt;app-root&gt;</code>&nbsp;element and the&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">routerLink</a></code>&nbsp;attribute because you declared a corresponding&nbsp;<code>AppComponent</code>&nbsp;and&nbsp;<code>RouterLinkDirectiveStub</code>&nbsp;in the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;configuration.</p>\n\n\n\n<p>But the compiler won&#8217;t throw an error when it encounters&nbsp;<code>&lt;app-banner&gt;</code>,&nbsp;<code>&lt;app-welcome&gt;</code>, or&nbsp;<code>&lt;<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>&gt;</code>. It simply renders them as empty tags and the browser ignores them.</p>\n\n\n\n<p>You no longer need the stub components.</p>\n\n\n\n<h4 id=\"use-both-techniques-together\">Use both techniques together</h4>\n\n\n\n<p>These are techniques for&nbsp;<em>Shallow Component Testing</em>&nbsp;, so-named because they reduce the visual surface of the component to just those elements in the component&#8217;s template that matter for tests.</p>\n\n\n\n<p>The&nbsp;<code><a href=\"https://angular.io/api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a></code>&nbsp;approach is the easier of the two but don&#8217;t overuse it.</p>\n\n\n\n<p>The&nbsp;<code><a href=\"https://angular.io/api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a></code>&nbsp;also prevents the compiler from telling you about the missing components and attributes that you omitted inadvertently or misspelled. You could waste hours chasing phantom bugs that the compiler would have caught in an instant.</p>\n\n\n\n<p>The&nbsp;<em>stub component</em>&nbsp;approach has another advantage. While the stubs in&nbsp;<em>this</em>&nbsp;example were empty, you could give them stripped-down templates and classes if your tests need to interact with them in some way.</p>\n\n\n\n<p>In practice you will combine the two techniques in the same setup, as seen in this example.app/app.component.spec.ts (mixed setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({\n      declarations: &#91;\n        AppComponent,\n        BannerStubComponent,\n        RouterLinkDirectiveStub\n      ],\n      schemas: &#91;<a href=\"https://angular.io/api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a>]\n    })</code></code></pre>\n\n\n\n<p>The Angular compiler creates the&nbsp;<code>BannerComponentStub</code>&nbsp;for the&nbsp;<code>&lt;app-banner&gt;</code>&nbsp;element and applies the&nbsp;<code>RouterLinkStubDirective</code>&nbsp;to the anchors with the&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">routerLink</a></code>&nbsp;attribute, but it ignores the&nbsp;<code>&lt;app-welcome&gt;</code>&nbsp;and&nbsp;<code>&lt;<a href=\"https://angular.io/api/router/RouterOutlet\">router-outlet</a>&gt;</code>&nbsp;tags.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Component templates often have nested components, whose templates may contain more components. The component tree can be very deep and, most of the time, the nested components play no role in testing the component at the top of the tree. The&nbsp;AppComponent, for example, displays a navigation bar with anchors and their&nbsp;RouterLink&nbsp;directives.app/app.component.html While the&nbsp;AppComponent&nbsp;class&nbsp;is empty, you [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4610"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4610"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4610/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4629,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4610/revisions/4629"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4610"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4610"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4610"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4636,
    "date": "2021-02-25T11:37:12",
    "date_gmt": "2021-02-25T11:37:12",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4636"
    },
    "modified": "2021-02-25T11:37:12",
    "modified_gmt": "2021-02-25T11:37:12",
    "slug": "components-with-routerlink",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/components-with-routerlink/",
    "title": {
      "rendered": "Components with RouterLink"
    },
    "content": {
      "rendered": "\n<p>The real&nbsp;<code>RouterLinkDirective</code>&nbsp;is quite complicated and entangled with other components and directives of the&nbsp;<code><a href=\"https://angular.io/api/router/RouterModule\">RouterModule</a></code>. It requires challenging setup to mock and use in tests.</p>\n\n\n\n<p>The&nbsp;<code>RouterLinkDirectiveStub</code>&nbsp;in this sample code replaces the real directive with an alternative version designed to validate the kind of anchor tag wiring seen in the&nbsp;<code>AppComponent</code>&nbsp;template.testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Directive\">Directive</a>({\n  selector: '&#91;<a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>]'\n})\nexport class RouterLinkDirectiveStub {\n  @<a href=\"https://angular.io/api/core/Input\">Input</a>('<a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>') linkParams: any;\n  navigatedTo: any = null;\n\n  @<a href=\"https://angular.io/api/core/HostListener\">HostListener</a>('click')\n  onClick() {\n    this.navigatedTo = this.linkParams;\n  }\n}</code></code></pre>\n\n\n\n<p>The URL bound to the&nbsp;<code>[<a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>]</code>&nbsp;attribute flows in to the directive&#8217;s&nbsp;<code>linkParams</code>&nbsp;property.</p>\n\n\n\n<p>The&nbsp;<code><a href=\"https://angular.io/api/core/HostListener\">HostListener</a></code>&nbsp;wires the click event of the host element (the&nbsp;<code>&lt;a&gt;</code>&nbsp;anchor elements in&nbsp;<code>AppComponent</code>) to the stub directive&#8217;s&nbsp;<code>onClick</code>&nbsp;method.</p>\n\n\n\n<p>Clicking the anchor should trigger the&nbsp;<code>onClick()</code>&nbsp;method, which sets the stub&#8217;s telltale&nbsp;<code>navigatedTo</code>&nbsp;property. Tests inspect&nbsp;<code>navigatedTo</code>&nbsp;to confirm that clicking the anchor sets the expected route definition.</p>\n\n\n\n<p>Whether the router is configured properly to navigate with that route definition is a question for a separate set of tests.</p>\n\n\n\n<h4 id=\"bydirective-and-injected-directives\"><em>By.directive</em>&nbsp;and injected directives</h4>\n\n\n\n<p>A little more setup triggers the initial data binding and gets references to the navigation links:app/app.component.spec.ts (test setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(() =&gt; {\n  fixture.detectChanges();  // <a href=\"https://angular.io/api/animations/trigger\">trigger</a> initial data binding\n\n  // find DebugElements with an attached RouterLinkStubDirective\n  linkDes = fixture.debugElement.queryAll(By.directive(RouterLinkDirectiveStub));\n\n  // get attached link directive instances\n  // using each <a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a>'s injector\n  routerLinks = linkDes.map(de =&gt; de.injector.get(RouterLinkDirectiveStub));\n});</code></code></pre>\n\n\n\n<p>Three points of special interest:</p>\n\n\n\n<ol><li>You can locate the anchor elements with an attached directive using&nbsp;<code>By.directive</code>.</li><li>The query returns&nbsp;<code><a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a></code>&nbsp;wrappers around the matching elements.</li><li>Each&nbsp;<code><a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a></code>&nbsp;exposes a dependency injector with the specific instance of the directive attached to that element.</li></ol>\n\n\n\n<p>The&nbsp;<code>AppComponent</code>&nbsp;links to validate are as follows:app/app.component.html (navigation links)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>&lt;nav&gt;\n  &lt;a <a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"https://angular.io/api/router/RouterLink\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;</code></code></pre>\n\n\n\n<p>Here are some tests that confirm those links are wired to the&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">routerLink</a></code>&nbsp;directives as expected:app/app.component.spec.ts (selected tests)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('can get RouterLinks from template', () =&gt; {\n  expect(routerLinks.length).toBe(3, 'should have 3 routerLinks');\n  expect(routerLinks&#91;0].linkParams).toBe('/dashboard');\n  expect(routerLinks&#91;1].linkParams).toBe('/heroes');\n  expect(routerLinks&#91;2].linkParams).toBe('/about');\n});\n\nit('can click Heroes link in template', () =&gt; {\n  const heroesLinkDe = linkDes&#91;1];    // heroes link <a href=\"https://angular.io/api/core/DebugElement\">DebugElement</a>\n  const heroesLink = routerLinks&#91;1];  // heroes link directive\n\n  expect(heroesLink.navigatedTo).toBeNull('should not have navigated yet');\n\n  heroesLinkDe.triggerEventHandler('click', null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe('/heroes');\n});</code></code></pre>\n\n\n\n<p>The &#8220;click&#8221; test&nbsp;<em>in this example</em>&nbsp;is misleading. It tests the&nbsp;<code>RouterLinkDirectiveStub</code>&nbsp;rather than the&nbsp;<em>component</em>. This is a common failing of directive stubs.</p>\n\n\n\n<p>It has a legitimate purpose in this guide. It demonstrates how to find a&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;element, click it, and inspect a result, without engaging the full router machinery. This is a skill you may need to test a more sophisticated component, one that changes the display, re-calculates parameters, or re-arranges navigation options when the user clicks the link.</p>\n\n\n\n<h4 id=\"what-good-are-these-tests\">What good are these tests?</h4>\n\n\n\n<p>Stubbed&nbsp;<code><a href=\"https://angular.io/api/router/RouterLink\">RouterLink</a></code>&nbsp;tests can confirm that a component with links and an outlet is setup properly, that the component has the links it should have, and that they are all pointing in the expected direction. These tests do not concern whether the app will succeed in navigating to the target component when the user clicks a link.</p>\n\n\n\n<p>Stubbing the RouterLink and RouterOutlet is the best option for such limited testing goals. Relying on the real router would make them brittle. They could fail for reasons unrelated to the component. For example, a navigation guard could prevent an unauthorized user from visiting the&nbsp;<code>HeroListComponent</code>. That&#8217;s not the fault of the&nbsp;<code>AppComponent</code>&nbsp;and no change to that component could cure the failed test.</p>\n\n\n\n<p>A&nbsp;<em>different</em>&nbsp;battery of tests can explore whether the application navigates as expected in the presence of conditions that influence guards such as whether the user is authenticated and authorized.</p>\n\n\n\n<p>A future guide update will explain how to write such tests with the&nbsp;<code><a href=\"https://angular.io/api/router/testing/RouterTestingModule\">RouterTestingModule</a></code>.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The real&nbsp;RouterLinkDirective&nbsp;is quite complicated and entangled with other components and directives of the&nbsp;RouterModule. It requires challenging setup to mock and use in tests. The&nbsp;RouterLinkDirectiveStub&nbsp;in this sample code replaces the real directive with an alternative version designed to validate the kind of anchor tag wiring seen in the&nbsp;AppComponent&nbsp;template.testing/router-link-directive-stub.ts (RouterLinkDirectiveStub) The URL bound to the&nbsp;[routerLink]&nbsp;attribute flows in [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4636"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4636"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4636/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4637,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4636/revisions/4637"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4636"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4636"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4636"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4633,
    "date": "2021-02-25T11:37:45",
    "date_gmt": "2021-02-25T11:37:45",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4633"
    },
    "modified": "2021-02-25T11:37:45",
    "modified_gmt": "2021-02-25T11:37:45",
    "slug": "use-a-page-object",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/use-a-page-object/",
    "title": {
      "rendered": "Use a page object"
    },
    "content": {
      "rendered": "\n<p>The&nbsp;<code>HeroDetailComponent</code>&nbsp;is a simple view with a title, two hero fields, and two buttons.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://angular.io/generated/images/guide/testing/hero-detail.component.png\" alt=\"HeroDetailComponent in action\"/></figure>\n\n\n\n<p>But there&#8217;s plenty of template complexity even in this simple form.app/hero/hero-detail.component.html</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>&lt;div *<a href=\"https://angular.io/api/common/NgIf\">ngIf</a>=\"hero\"&gt;\n  &lt;h2&gt;&lt;span&gt;{{hero.name | <a href=\"https://angular.io/api/common/TitleCasePipe\">titlecase</a>}}&lt;/span&gt; Details&lt;/h2&gt;\n  &lt;div&gt;\n    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;\n  &lt;div&gt;\n    &lt;label for=\"name\"&gt;name: &lt;/label&gt;\n    &lt;input id=\"name\" &#91;(<a href=\"https://angular.io/api/forms/NgModel\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" /&gt;\n  &lt;/div&gt;\n  &lt;button (click)=\"save()\"&gt;Save&lt;/button&gt;\n  &lt;button (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n&lt;/div&gt;</code></code></pre>\n\n\n\n<p>Tests that exercise the component need &#8230;</p>\n\n\n\n<ul><li>to wait until a hero arrives before elements appear in the DOM.</li><li>a reference to the title text.</li><li>a reference to the name input box to inspect and set it.</li><li>references to the two buttons so they can click them.</li><li>spies for some of the component and router methods.</li></ul>\n\n\n\n<p>Even a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.</p>\n\n\n\n<p>Tame the complexity with a&nbsp;<code>Page</code>&nbsp;class that handles access to component properties and encapsulates the logic that sets them.</p>\n\n\n\n<p>Here is such a&nbsp;<code>Page</code>&nbsp;class for the&nbsp;<code>hero-detail.component.spec.ts</code>app/hero/hero-detail.component.spec.ts (Page)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>class Page {\n  // getter properties wait to <a href=\"https://angular.io/api/animations/query\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons&#91;0];\n  }\n  get cancelBtn() {\n    return this.buttons&#91;1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  gotoListSpy: jasmine.Spy;\n  navigateSpy: jasmine.Spy;\n\n  constructor(someFixture: <a href=\"https://angular.io/api/core/testing/ComponentFixture\">ComponentFixture</a>&lt;HeroDetailComponent&gt;) {\n    // get the navigate spy from the injected router spy object\n    const routerSpy = someFixture.debugElement.injector.get(<a href=\"https://angular.io/api/router/Router\">Router</a>) as any;\n    this.navigateSpy = routerSpy.navigate;\n\n    // spy on component's `gotoList()` method\n    const someComponent = someFixture.componentInstance;\n    this.gotoListSpy = spyOn(someComponent, 'gotoList').and.callThrough();\n  }\n\n  //// <a href=\"https://angular.io/api/animations/query\">query</a> helpers ////\n  private <a href=\"https://angular.io/api/animations/query\">query</a>&lt;T&gt;(selector: string): T {\n    return fixture.nativeElement.querySelector(selector);\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T&#91;] {\n    return fixture.nativeElement.querySelectorAll(selector);\n  }\n}</code></code></pre>\n\n\n\n<p>Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of&nbsp;<code>Page</code>.</p>\n\n\n\n<p>A&nbsp;<code>createComponent</code>&nbsp;method creates a&nbsp;<code>page</code>&nbsp;object and fills in the blanks once the&nbsp;<code>hero</code>&nbsp;arrives.app/hero/hero-detail.component.spec.ts (createComponent)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>/** Create the HeroDetailComponent, initialize it, set test variables  */\nfunction createComponent() {\n  fixture = TestBed.createComponent(HeroDetailComponent);\n  component = fixture.componentInstance;\n  page = new Page(fixture);\n\n  // 1st change detection triggers ngOnInit which gets a hero\n  fixture.detectChanges();\n  return fixture.whenStable().then(() =&gt; {\n    // 2nd change detection displays the async-fetched hero\n    fixture.detectChanges();\n  });\n}</code></code></pre>\n\n\n\n<p>The&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#tests-w-test-double\"><em>HeroDetailComponent</em>&nbsp;tests</a>&nbsp;in an earlier section demonstrate how&nbsp;<code>createComponent</code>&nbsp;and&nbsp;<code>page</code>&nbsp;keep the tests short and&nbsp;<em>on message</em>. There are no distractions: no waiting for promises to resolve and no searching the DOM for element values to compare.</p>\n\n\n\n<p>Here are a few more&nbsp;<code>HeroDetailComponent</code>&nbsp;tests to reinforce the point.app/hero/hero-detail.component.spec.ts (selected tests)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>it('should display that hero\\'s name', () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () =&gt; {\n  click(page.cancelBtn);\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n});\n\nit('should save when click save but not navigate immediately', () =&gt; {\n  // Get service injected into component and spy on its`saveHero` method.\n  // It delegates to fake `HeroService.updateHero` which delivers a safe test result.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, 'saveHero').and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, 'HeroDetailService.save called');\n  expect(page.navigateSpy.calls.any()).toBe(false, 'router.navigate not called');\n});\n\nit('should navigate when click save and save resolves', <a href=\"https://angular.io/api/core/testing/fakeAsync\">fakeAsync</a>(() =&gt; {\n     click(page.saveBtn);\n     <a href=\"https://angular.io/api/core/testing/tick\">tick</a>();  // wait for async save to complete\n     expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n   }));\n\nit('should convert hero name to <a href=\"https://angular.io/api/platform-browser/Title\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  // In older browsers, such as IE, you might need a CustomEvent instead. See\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n  nameInput.dispatchEvent(new <a href=\"https://angular.io/api/router/Event\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The&nbsp;HeroDetailComponent&nbsp;is a simple view with a title, two hero fields, and two buttons. But there&#8217;s plenty of template complexity even in this simple form.app/hero/hero-detail.component.html Tests that exercise the component need &#8230; to wait until a hero arrives before elements appear in the DOM. a reference to the title text. a reference to the name input [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4633"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4633"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4633/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4638,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4633/revisions/4638"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4633"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4633"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4633"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4635,
    "date": "2021-02-25T11:38:34",
    "date_gmt": "2021-02-25T11:38:34",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4635"
    },
    "modified": "2021-02-25T11:38:34",
    "modified_gmt": "2021-02-25T11:38:34",
    "slug": "calling-compilecomponents",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/calling-compilecomponents/",
    "title": {
      "rendered": "Calling compileComponents()"
    },
    "content": {
      "rendered": "\n<p>You can ignore this section if you&nbsp;<em>only</em>&nbsp;run tests with the CLI&nbsp;<code>ng test</code>&nbsp;command because the CLI compiles the application before running the tests.</p>\n\n\n\n<p>If you run tests in a&nbsp;<strong>non-CLI environment</strong>, the tests may fail with a message like this one:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Error: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.</code></pre>\n\n\n\n<p>The root of the problem is at least one of the components involved in the test specifies an external template or CSS file as the following version of the&nbsp;<code>BannerComponent</code>&nbsp;does.app/banner/banner-external.component.ts (external template &amp; css)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>import { <a href=\"https://angular.io/api/core/Component\">Component</a> } from '@angular/core';\n\n@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  &#91;'./banner-external.component.css']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}</code></code></pre>\n\n\n\n<p>The test fails when the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;tries to create the component.app/banner/banner.component.spec.ts (setup that fails)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: &#91; BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n});</code></code></pre>\n\n\n\n<p>Recall that the app hasn&#8217;t been compiled. So when you call&nbsp;<code>createComponent()</code>, the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;compiles implicitly.</p>\n\n\n\n<p>That&#8217;s not a problem when the source code is in memory. But the&nbsp;<code>BannerComponent</code>&nbsp;requires external files that the compiler must read from the file system, an inherently&nbsp;<em>asynchronous</em>&nbsp;operation.</p>\n\n\n\n<p>If the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;were allowed to continue, the tests would run and fail mysteriously before the compiler could finished.</p>\n\n\n\n<p>The preemptive error message tells you to compile explicitly with&nbsp;<code>compileComponents()</code>.</p>\n\n\n\n<h4 id=\"compilecomponents-is-async\"><em>compileComponents()</em>&nbsp;is async</h4>\n\n\n\n<p>You must call&nbsp;<code>compileComponents()</code>&nbsp;within an asynchronous test function.</p>\n\n\n\n<p>If you neglect to make the test function async (e.g., forget to use&nbsp;<code><a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>()</code>&nbsp;as described below), you&#8217;ll see this error message</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Error: ViewDestroyedError: Attempt to use a destroyed view</code></pre>\n\n\n\n<p>A typical approach is to divide the setup logic into two separate&nbsp;<code>beforeEach()</code>&nbsp;functions:</p>\n\n\n\n<ol><li>An async&nbsp;<code>beforeEach()</code>&nbsp;that compiles the components</li><li>A synchronous&nbsp;<code>beforeEach()</code>&nbsp;that performs the remaining setup.</li></ol>\n\n\n\n<p>To follow this pattern, import the&nbsp;<code><a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>()</code>&nbsp;helper with the other testing symbols.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>import { <a href=\"https://angular.io/api/core/testing/ComponentFixture\">ComponentFixture</a>, <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>, <a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a> } from '@angular/core/testing';</code></code></pre>\n\n\n\n<h4 id=\"the-async-beforeeach\">The async&nbsp;<em>beforeEach</em></h4>\n\n\n\n<p>Write the first async&nbsp;<code>beforeEach</code>&nbsp;like this.app/banner/banner-external.component.spec.ts (async beforeEach)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n      .configureTestingModule({\n        declarations: &#91;BannerComponent],\n      })\n      .compileComponents();  // compile template and css\n}));</code></code></pre>\n\n\n\n<p>The&nbsp;<code><a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>()</code>&nbsp;helper function takes a parameterless function with the body of the setup.</p>\n\n\n\n<p>The&nbsp;<code>TestBed.configureTestingModule()</code>&nbsp;method returns the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;class so you can chain calls to other&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;static methods such as&nbsp;<code>compileComponents()</code>.</p>\n\n\n\n<p>In this example, the&nbsp;<code>BannerComponent</code>&nbsp;is the only component to compile. Other examples configure the testing module with multiple components and may import application modules that hold yet more components. Any of them could require external files.</p>\n\n\n\n<p>The&nbsp;<code>TestBed.compileComponents</code>&nbsp;method asynchronously compiles all components configured in the testing module.</p>\n\n\n\n<p>Do not re-configure the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;after calling&nbsp;<code>compileComponents()</code>.</p>\n\n\n\n<p>Calling&nbsp;<code>compileComponents()</code>&nbsp;closes the current&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;instance to further configuration. You cannot call any more&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;configuration methods, not&nbsp;<code>configureTestingModule()</code>&nbsp;nor any of the&nbsp;<code>override...</code>&nbsp;methods. The&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>&nbsp;throws an error if you try.</p>\n\n\n\n<p>Make&nbsp;<code>compileComponents()</code>&nbsp;the last step before calling&nbsp;<code>TestBed.createComponent()</code>.</p>\n\n\n\n<h4 id=\"the-synchronous-beforeeach\">The synchronous&nbsp;<em>beforeEach</em></h4>\n\n\n\n<p>The second, synchronous&nbsp;<code>beforeEach()</code>&nbsp;contains the remaining setup steps, which include creating the component and querying for elements to inspect.app/banner/banner-external.component.spec.ts (synchronous beforeEach)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;  // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});</code></code></pre>\n\n\n\n<p>You can count on the test runner to wait for the first asynchronous&nbsp;<code>beforeEach</code>&nbsp;to finish before calling the second.</p>\n\n\n\n<h4 id=\"consolidated-setup\">Consolidated setup</h4>\n\n\n\n<p>You can consolidate the two&nbsp;<code>beforeEach()</code>&nbsp;functions into a single, async&nbsp;<code>beforeEach()</code>.</p>\n\n\n\n<p>The&nbsp;<code>compileComponents()</code>&nbsp;method returns a promise so you can perform the synchronous setup tasks&nbsp;<em>after</em>&nbsp;compilation by moving the synchronous code into a&nbsp;<code>then(...)</code>&nbsp;callback.app/banner/banner-external.component.spec.ts (one beforeEach)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n      .configureTestingModule({\n        declarations: &#91;BannerComponent],\n      })\n      .compileComponents()\n      .then(() =&gt; {\n        fixture = TestBed.createComponent(BannerComponent);\n        component = fixture.componentInstance;\n        h1 = fixture.nativeElement.querySelector('h1');\n      });\n}));</code></code></pre>\n\n\n\n<h4 id=\"compilecomponents-is-harmless\"><em>compileComponents()</em>&nbsp;is harmless</h4>\n\n\n\n<p>There&#8217;s no harm in calling&nbsp;<code>compileComponents()</code>&nbsp;when it&#8217;s not required.</p>\n\n\n\n<p>The component test file generated by the CLI calls&nbsp;<code>compileComponents()</code>&nbsp;even though it is never required when running&nbsp;<code>ng test</code>.</p>\n\n\n\n<p>The tests in this guide only call&nbsp;<code>compileComponents</code>&nbsp;when necessary.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>You can ignore this section if you&nbsp;only&nbsp;run tests with the CLI&nbsp;ng test&nbsp;command because the CLI compiles the application before running the tests. If you run tests in a&nbsp;non-CLI environment, the tests may fail with a message like this one: The root of the problem is at least one of the components involved in the test [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4635"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4635"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4635/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4639,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4635/revisions/4639"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4635"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4635"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4635"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4634,
    "date": "2021-02-25T11:39:11",
    "date_gmt": "2021-02-25T11:39:11",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4634"
    },
    "modified": "2021-02-25T11:39:11",
    "modified_gmt": "2021-02-25T11:39:11",
    "slug": "setup-with-module-imports",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/setup-with-module-imports/",
    "title": {
      "rendered": "Setup with module imports"
    },
    "content": {
      "rendered": "\n<p>Earlier component tests configured the testing module with a few&nbsp;<code>declarations</code>&nbsp;like this:app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n    .configureTestingModule({declarations: &#91;DashboardHeroComponent]})</code></code></pre>\n\n\n\n<p>The&nbsp;<code>DashboardComponent</code>&nbsp;is simple. It needs no help. But more complex components often depend on other components, directives, pipes, and providers and these must be added to the testing module too.</p>\n\n\n\n<p>Fortunately, the&nbsp;<code>TestBed.configureTestingModule</code>&nbsp;parameter parallels the metadata passed to the&nbsp;<code>@<a href=\"https://angular.io/api/core/NgModule\">NgModule</a></code>&nbsp;decorator which means you can also specify&nbsp;<code>providers</code>&nbsp;and&nbsp;<code>imports</code>.</p>\n\n\n\n<p>The&nbsp;<code>HeroDetailComponent</code>&nbsp;requires a lot of help despite its small size and simple construction. In addition to the support it receives from the default testing module&nbsp;<code><a href=\"https://angular.io/api/common/CommonModule\">CommonModule</a></code>, it needs:</p>\n\n\n\n<ul><li><code><a href=\"https://angular.io/api/forms/NgModel\">NgModel</a></code>&nbsp;and friends in the&nbsp;<code><a href=\"https://angular.io/api/forms/FormsModule\">FormsModule</a></code>&nbsp;to enable two-way data binding.</li><li>The&nbsp;<code><a href=\"https://angular.io/api/common/TitleCasePipe\">TitleCasePipe</a></code>&nbsp;from the&nbsp;<code>shared</code>&nbsp;folder.</li><li>Router services (which these tests are stubbing).</li><li>Hero data access services (also stubbed).</li></ul>\n\n\n\n<p>One approach is to configure the testing module from the individual pieces as in this example:app/hero/hero-detail.component.spec.ts (FormsModule setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n      .configureTestingModule({\n        imports: &#91;<a href=\"https://angular.io/api/forms/FormsModule\">FormsModule</a>],\n        declarations: &#91;HeroDetailComponent, <a href=\"https://angular.io/api/common/TitleCasePipe\">TitleCasePipe</a>],\n        providers: &#91;\n          {provide: <a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: <a href=\"https://angular.io/api/router/Router\">Router</a>, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));</code></code></pre>\n\n\n\n<p>Notice that the&nbsp;<code>beforeEach()</code>&nbsp;is asynchronous and calls&nbsp;<code>TestBed.compileComponents</code>&nbsp;because the&nbsp;<code>HeroDetailComponent</code>&nbsp;has an external template and css file.</p>\n\n\n\n<p>As explained in&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#compile-components\"><em>Calling compileComponents()</em></a>&nbsp;above, these tests could be run in a non-CLI environment where Angular would have to compile them in the browser.</p>\n\n\n\n<h4 id=\"import-a-shared-module\">Import a shared module</h4>\n\n\n\n<p>Because many app components need the&nbsp;<code><a href=\"https://angular.io/api/forms/FormsModule\">FormsModule</a></code>&nbsp;and the&nbsp;<code><a href=\"https://angular.io/api/common/TitleCasePipe\">TitleCasePipe</a></code>, the developer created a&nbsp;<code>SharedModule</code>&nbsp;to combine these and other frequently requested parts.</p>\n\n\n\n<p>The test configuration can use the&nbsp;<code>SharedModule</code>&nbsp;too as seen in this alternative setup:app/hero/hero-detail.component.spec.ts (SharedModule setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n      .configureTestingModule({\n        imports: &#91;SharedModule],\n        declarations: &#91;HeroDetailComponent],\n        providers: &#91;\n          {provide: <a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: <a href=\"https://angular.io/api/router/Router\">Router</a>, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));</code></code></pre>\n\n\n\n<p>It&#8217;s a bit tighter and smaller, with fewer import statements (not shown).</p>\n\n\n\n<h4 id=\"import-a-feature-module\">Import a feature module</h4>\n\n\n\n<p>The&nbsp;<code>HeroDetailComponent</code>&nbsp;is part of the&nbsp;<code>HeroModule</code>&nbsp;<a href=\"https://angular.io/guide/feature-modules\">Feature Module</a>&nbsp;that aggregates more of the interdependent pieces including the&nbsp;<code>SharedModule</code>. Try a test configuration that imports the&nbsp;<code>HeroModule</code>&nbsp;like this one:app/hero/hero-detail.component.spec.ts (HeroModule setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n      .configureTestingModule({\n        imports: &#91;HeroModule],\n        providers: &#91;\n          {provide: <a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: HeroService, useClass: TestHeroService},\n          {provide: <a href=\"https://angular.io/api/router/Router\">Router</a>, useValue: routerSpy},\n        ]\n      })\n      .compileComponents();\n}));</code></code></pre>\n\n\n\n<p>That&#8217;s&nbsp;<em>really</em>&nbsp;crisp. Only the&nbsp;<em>test doubles</em>&nbsp;in the&nbsp;<code>providers</code>&nbsp;remain. Even the&nbsp;<code>HeroDetailComponent</code>&nbsp;declaration is gone.</p>\n\n\n\n<p>In fact, if you try to declare it, Angular will throw an error because&nbsp;<code>HeroDetailComponent</code>&nbsp;is declared in both the&nbsp;<code>HeroModule</code>&nbsp;and the&nbsp;<code>DynamicTestModule</code>&nbsp;created by the&nbsp;<code><a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a></code>.</p>\n\n\n\n<p>Importing the component&#8217;s feature module can be the easiest way to configure tests when there are many mutual dependencies within the module and the module is small, as feature modules tend to be.</p>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Earlier component tests configured the testing module with a few&nbsp;declarations&nbsp;like this:app/dashboard/dashboard-hero.component.spec.ts (configure TestBed) The&nbsp;DashboardComponent&nbsp;is simple. It needs no help. But more complex components often depend on other components, directives, pipes, and providers and these must be added to the testing module too. Fortunately, the&nbsp;TestBed.configureTestingModule&nbsp;parameter parallels the metadata passed to the&nbsp;@NgModule&nbsp;decorator which means you can also [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4634"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4634"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4634/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4640,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4634/revisions/4640"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4634"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4634"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4634"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  },
  {
    "id": 4632,
    "date": "2021-02-25T11:40:09",
    "date_gmt": "2021-02-25T11:40:09",
    "guid": {
      "rendered": "http://angular.foobrdigital.com/?p=4632"
    },
    "modified": "2021-02-25T11:40:09",
    "modified_gmt": "2021-02-25T11:40:09",
    "slug": "override-component-providers",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/override-component-providers/",
    "title": {
      "rendered": "Override component providers"
    },
    "content": {
      "rendered": "\n<p>The&nbsp;<code>HeroDetailComponent</code>&nbsp;provides its own&nbsp;<code>HeroDetailService</code>.app/hero/hero-detail.component.ts (prototype)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Component\">Component</a>({\n  selector:    'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls:  &#91;'./hero-detail.component.css' ],\n  providers:  &#91; HeroDetailService ]\n})\nexport class HeroDetailComponent implements <a href=\"https://angular.io/api/core/OnInit\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route: <a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a>,\n    private router: <a href=\"https://angular.io/api/router/Router\">Router</a>) {\n  }\n}</code></code></pre>\n\n\n\n<p>It&#8217;s not possible to stub the component&#8217;s&nbsp;<code>HeroDetailService</code>&nbsp;in the&nbsp;<code>providers</code>&nbsp;of the&nbsp;<code>TestBed.configureTestingModule</code>. Those are providers for the&nbsp;<em>testing module</em>, not the component. They prepare the dependency injector at the&nbsp;<em>fixture level</em>.</p>\n\n\n\n<p>Angular creates the component with its&nbsp;<em>own</em>&nbsp;injector, which is a&nbsp;<em>child</em>&nbsp;of the fixture injector. It registers the component&#8217;s providers (the&nbsp;<code>HeroDetailService</code>&nbsp;in this case) with the child injector.</p>\n\n\n\n<p>A test cannot get to child injector services from the fixture injector. And&nbsp;<code>TestBed.configureTestingModule</code>&nbsp;can&#8217;t configure them either.</p>\n\n\n\n<p>Angular has been creating new instances of the real&nbsp;<code>HeroDetailService</code>&nbsp;all along!</p>\n\n\n\n<p>These tests could fail or timeout if the&nbsp;<code>HeroDetailService</code>&nbsp;made its own XHR calls to a remote server. There might not be a remote server to call.</p>\n\n\n\n<p>Fortunately, the&nbsp;<code>HeroDetailService</code>&nbsp;delegates responsibility for remote data access to an injected&nbsp;<code>HeroService</code>.app/hero/hero-detail.service.ts (prototype)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>@<a href=\"https://angular.io/api/core/Injectable\">Injectable</a>()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}</code></code></pre>\n\n\n\n<p>The\u00a0previous test configuration\u00a0replaces the real\u00a0<code>HeroService</code>\u00a0with a\u00a0<code>TestHeroService</code>\u00a0that intercepts server requests and fakes their responses.</p>\n\n\n\n<p>What if you aren&#8217;t so lucky. What if faking the&nbsp;<code>HeroService</code>&nbsp;is hard? What if&nbsp;<code>HeroDetailService</code>&nbsp;makes its own server requests?</p>\n\n\n\n<p>The&nbsp;<code>TestBed.overrideComponent</code>&nbsp;method can replace the component&#8217;s&nbsp;<code>providers</code>&nbsp;with easy-to-manage&nbsp;<em>test doubles</em>&nbsp;as seen in the following setup variation:app/hero/hero-detail.component.spec.ts (Override setup)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>beforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  <a href=\"https://angular.io/api/core/testing/TestBed\">TestBed</a>\n      .configureTestingModule({\n        imports: &#91;HeroModule],\n        providers: &#91;\n          {provide: <a href=\"https://angular.io/api/router/ActivatedRoute\">ActivatedRoute</a>, useValue: activatedRoute},\n          {provide: <a href=\"https://angular.io/api/router/Router\">Router</a>, useValue: routerSpy},\n        ]\n      })\n\n      // Override component's own provider\n      .overrideComponent(\n          HeroDetailComponent,\n          {set: {providers: &#91;{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n\n      .compileComponents();\n}));</code></code></pre>\n\n\n\n<p>Notice that&nbsp;<code>TestBed.configureTestingModule</code>&nbsp;no longer provides a (fake)&nbsp;<code>HeroService</code>&nbsp;because it&#8217;s&nbsp;<a href=\"https://angular.io/guide/testing-components-scenarios#spy-stub\">not needed</a>.</p>\n\n\n\n<h4 id=\"the-overridecomponent-method\">The&nbsp;<em>overrideComponent</em>&nbsp;method</h4>\n\n\n\n<p>Focus on the&nbsp;<code>overrideComponent</code>&nbsp;method.app/hero/hero-detail.component.spec.ts (overrideComponent)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>.overrideComponent(\n    HeroDetailComponent,\n    {set: {providers: &#91;{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})</code></code></pre>\n\n\n\n<p>It takes two arguments: the component type to override (<code>HeroDetailComponent</code>) and an override metadata object. The&nbsp;<a href=\"https://angular.io/guide/testing-utility-apis#metadata-override-object\">override metadata object</a>&nbsp;is a generic defined as follows:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>type <a href=\"https://angular.io/api/core/testing/MetadataOverride\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};</code></code></pre>\n\n\n\n<p>A metadata override object can either add-and-remove elements in metadata properties or completely reset those properties. This example resets the component&#8217;s&nbsp;<code>providers</code>&nbsp;metadata.</p>\n\n\n\n<p>The type parameter,&nbsp;<code>T</code>, is the kind of metadata you&#8217;d pass to the&nbsp;<code>@<a href=\"https://angular.io/api/core/Component\">Component</a></code>&nbsp;decorator:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>selector?: string;\ntemplate?: string;\ntemplateUrl?: string;\nproviders?: any&#91;];\n...</code></code></pre>\n\n\n\n<h4 id=\"provide-a-spy-stub-herodetailservicespy\">Provide a&nbsp;<em>spy stub</em>&nbsp;(<em>HeroDetailServiceSpy</em>)</h4>\n\n\n\n<p>This example completely replaces the component&#8217;s&nbsp;<code>providers</code>&nbsp;array with a new array containing a&nbsp;<code>HeroDetailServiceSpy</code>.</p>\n\n\n\n<p>The&nbsp;<code>HeroDetailServiceSpy</code>&nbsp;is a stubbed version of the real&nbsp;<code>HeroDetailService</code>&nbsp;that fakes all necessary features of that service. It neither injects nor delegates to the lower level&nbsp;<code>HeroService</code>&nbsp;so there&#8217;s no need to provide a test double for that.</p>\n\n\n\n<p>The related&nbsp;<code>HeroDetailComponent</code>&nbsp;tests will assert that methods of the&nbsp;<code>HeroDetailService</code>&nbsp;were called by spying on the service methods. Accordingly, the stub implements its methods as spies:app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>class HeroDetailServiceSpy {\n  testHero: Hero = {id: 42, name: 'Test Hero'};\n\n  /* emit cloned test hero */\n  getHero = jasmine.createSpy('getHero').and.callFake(\n      () =&gt; asyncData(Object.assign({}, this.testHero)));\n\n  /* emit clone of test hero, with changes merged in */\n  saveHero = jasmine.createSpy('saveHero')\n                 .and.callFake((hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero)));\n}</code></code></pre>\n\n\n\n<h4 id=\"the-override-tests\">The override tests</h4>\n\n\n\n<p>Now the tests can control the component&#8217;s hero directly by manipulating the spy-stub&#8217;s&nbsp;<code>testHero</code>&nbsp;and confirm that service methods were called.app/hero/hero-detail.component.spec.ts (override tests)</p>\n\n\n\n<pre class=\"wp-block-code\"><code>content_copy<code>let hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach(<a href=\"https://angular.io/api/core/testing/waitForAsync\">waitForAsync</a>(() =&gt; {\n  createComponent();\n  // get the component's injected HeroDetailServiceSpy\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit('should have called `getHero`', () =&gt; {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, 'getHero called once');\n});\n\nit('should display stub hero\\'s name', () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit('should save stub hero change', <a href=\"https://angular.io/api/core/testing/fakeAsync\">fakeAsync</a>(() =&gt; {\n     const origName = hdsSpy.testHero.name;\n     const newName = 'New Name';\n\n     page.nameInput.value = newName;\n\n     // In older browsers, such as IE, you might need a CustomEvent instead. See\n     // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\n     page.nameInput.dispatchEvent(new <a href=\"https://angular.io/api/router/Event\">Event</a>('input')); // tell Angular\n\n     expect(component.hero.name).toBe(newName, 'component hero has new name');\n     expect(hdsSpy.testHero.name).toBe(origName, 'service hero unchanged before save');\n\n     click(page.saveBtn);\n     expect(hdsSpy.saveHero.calls.count()).toBe(1, 'saveHero called once');\n\n     <a href=\"https://angular.io/api/core/testing/tick\">tick</a>();  // wait for async save to complete\n     expect(hdsSpy.testHero.name).toBe(newName, 'service hero has new name after save');\n     expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n   }));</code></code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>The&nbsp;HeroDetailComponent&nbsp;provides its own&nbsp;HeroDetailService.app/hero/hero-detail.component.ts (prototype) It&#8217;s not possible to stub the component&#8217;s&nbsp;HeroDetailService&nbsp;in the&nbsp;providers&nbsp;of the&nbsp;TestBed.configureTestingModule. Those are providers for the&nbsp;testing module, not the component. They prepare the dependency injector at the&nbsp;fixture level. Angular creates the component with its&nbsp;own&nbsp;injector, which is a&nbsp;child&nbsp;of the fixture injector. It registers the component&#8217;s providers (the&nbsp;HeroDetailService&nbsp;in this case) with the child injector. A [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [244],
    "tags": [],
    "_links": {
      "self": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4632"
        }
      ],
      "collection": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts"
        }
      ],
      "about": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post"
        }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=4632"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4632/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 4641,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/4632/revisions/4641"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=4632"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=4632"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=4632"
        }
      ],
      "curies": [
        {
          "name": "wp",
          "href": "https://api.w.org/{rel}",
          "templated": true
        }
      ]
    }
  }
]
