[
  {
    "id": 3904,
    "date": "2020-12-10T11:32:23",
    "date_gmt": "2020-12-10T11:32:23",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3904" },
    "modified": "2020-12-10T11:32:23",
    "modified_gmt": "2020-12-10T11:32:23",
    "slug": "error-handling-in-angular-applications",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/error-handling-in-angular-applications/",
    "title": { "rendered": "Error Handling in Angular Applications" },
    "content": {
      "rendered": "\n<h2>Why Handle Errors</h2>\n\n\n\n<p>Handling error is an important part of the application design. The JavaScript can throws errors each time something goes wrong. For Example, the Javascipt throws errors in the following conditions</p>\n\n\n\n<ol><li>When we reference a non-existent variable.</li><li>The value provided is not in the range of allowed values.</li><li>When Interpreting syntactically invalid code</li><li>When a value is not of the expected type</li><li>Internal errors in the JavaScript engine</li></ol>\n\n\n\n<p>The apart from the above, the unexpected errors can happen any time. like broken connection, null pointer exception, no internet, HTTP errors like unauthorized user, session expired etc.</p>\n\n\n\n<p>The Angular handles the errors, but it wont do anything except writing it the console. And that is not useful either to the user or to the developer.</p>\n\n\n\n<p>There are two types of error handling mechanism in Angular. One catches all the&nbsp;<strong>client side errors</strong>&nbsp;and the other one catches the&nbsp;<strong>HTTP Errors.</strong></p>\n\n\n\n<h3><strong>HTTP Errors</strong></h3>\n\n\n\n<p>The HTTP Errors are thrown, when you send a HTTP Request using the HttpClient Module. The errors again falls into two categories. One is generated by the server like unauthorized user, session expired, Server down etc. The Other one is generated at the client side, while trying to generate the HTTP Request. These errors could be network error, error while generating the request etc</p>\n\n\n\n<p>The HTTP errors are handled by the HTTP Interceptors</p>\n\n\n\n<h3>Client Side Errors</h3>\n\n\n\n<p>All other errors thrown by the code falls into this category. These are are handled by the&nbsp;<code>ErrorHandler</code>&nbsp;class, which is the default error handler for Angular.</p>\n\n\n\n<h2>Default Error Handling in Angular</h2>\n\n\n\n<p>The default Error handling in Angular is handled by&nbsp;<code>Errorhandler</code>&nbsp;class, which is part of the&nbsp;<code>@angular/core</code>&nbsp;module. This is global error handler class which catches all exception occurring in the App. This class has a method&nbsp;<code>handleError(error)</code>. Whenever the app throws an&nbsp;<em><strong>unhandled exception</strong></em>&nbsp;anywhere in the application angular intercepts that exception. It then invokes the method&nbsp;<code>handleError(error)</code>&nbsp;which writes the error messages to browser console.</p>\n\n\n\n<h3>Error Handling Example</h3>\n\n\n\n<p>Create a new Angular application. Add the following code snippet to&nbsp;<code>app.component.html</code>&nbsp;&amp;&nbsp;<code>app.component.ts</code></p>\n\n\n\n<p><strong>app.component.html</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\n&lt;h1> {{title}} &lt;/h1>\r\n \r\n&lt;button (click)=\"throwError1()\"> Throw Error-1 &lt;/button>\r\n&lt;button (click)=\"throwError2()\"> Throw Error-2 &lt;/button>\r\n \r\n&lt;router-outlet>&lt;/router-outlet></code></pre>\n\n\n\n<p><strong>app.component.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: &#91;'./app.component.css']\r\n})\r\nexport class AppComponent\r\n{\r\n    title: string = 'Global Error Handler in Angular' ;\r\n \r\n    throwError1() {\r\n      var a= b;  \r\n    }\r\n \r\n    throwError2() {\r\n      try {\r\n        var a= b;  \r\n      } catch (error) {\r\n         //here you can handle the error\r\n         //\r\n      }\r\n    }\r\n}</code></pre>\n\n\n\n<p>The code mimics an error by using the statement<code>var a= b;</code>, where b is not defined. The first method&nbsp;<code>throwError1()</code>&nbsp;does not handle error, while&nbsp;<code>throwError2()</code>&nbsp;method uses&nbsp;<code>try..catch</code>&nbsp;block to handle the error.</p>\n\n\n\n<p>Run the app and keep the chrome developer tool open. Click on&nbsp;<code>throw error&nbsp;1</code>&nbsp;button. The default Error Handler of angular intercepts the error and writes to the console as shown in image below</p>\n\n\n\n<p>But, clicking on the&nbsp;<code>throw error&nbsp;2</code>&nbsp;button, does not trigger the Error Handler as it is handled by using the&nbsp;<code>try..catch</code>&nbsp;block.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/01/Default-Error-Handling-in-Angular.gif\" alt=\"\" class=\"wp-image-11455\"/></figure>\n\n\n\n<p>If you are not handling the error in the <code>try..catch</code> block, then you must use <code>throw error</code> so that the default error handler can catch it.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>  throwError2() {\r\n      try {\r\n        var a= b;  \r\n      } catch (error) {\r\n        throw error;    //rethrow the error\r\n      }\r\n    }</code></pre>\n\n\n\n<h2>Global Error Handler</h2>\n\n\n\n<p>The built in&nbsp;<code>ErrorHandler</code>&nbsp;is simple solution and provides a good option while developing the app. But it does not help to find out the error thrown in the the production environment. We have no way of knowing about the errors which happen at the users end.</p>\n\n\n\n<p>Hence, it advisable to create our own global error handler class, because</p>\n\n\n\n<ol><li>We can show a simple error page to the user, with a option to retry the operation</li><li>We can log the errors back to the back end server, where we can read all the errors. Then we can make necessary changes to the app to remove the error</li></ol>\n\n\n\n<h3>How to Create Global Error Handler ?</h3>\n\n\n\n<p>To create a custom error handler service, we need to use the following steps.</p>\n\n\n\n<p>First.create a <code>GlobalErrorHandlerService</code>  which implements the <code>ErrorHandler</code><br>Then, override the <code>handleError(error)</code> method and handle the error.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>export class GlobalErrorHandlerService implements ErrorHandler {\r\n \r\n  constructor() { \r\n  }\r\n \r\n  handleError(error) {\r\n     console.error('An error occurred:', error.message);\r\n  }\r\n  \r\n}</code></pre>\n\n\n\n<p>Next, register the <code>GlobalErrorHandlerService</code> in the Application root module using the token <code>ErrorHandler.</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n@NgModule({\r\n  ------\r\n  providers: &#91;\r\n    { provide: ErrorHandler, useClass: GlobalErrorHandlerService },\r\n  ]\r\n})\r\nexport class AppModule { } </code></pre>\n\n\n\n<h2 id=\"mce_18\">Error Handler Example</h2>\n\n\n\n<p>Create <code>global-error-handler.service.ts</code> and add the following code.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { ErrorHandler, Injectable} from '@angular/core';\r\n \r\n@Injectable()\r\nexport class GlobalErrorHandlerService implements ErrorHandler {\r\n \r\n    constructor() { \r\n    }\r\n  \r\n    handleError(error) {\r\n       console.error('An error occurred:', error.message);\r\n       console.error(error);\r\n       alert(error);\r\n   }\r\n \r\n}</code></pre>\n\n\n\n<p>Next, open the <code>pp.module.ts</code> and register the <code>GlobalErrorHandlerService</code> using the injection token <code>ErrorHandler</code>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule,ErrorHandler } from '@angular/core';\r\n \r\nimport { AppComponent } from './app.component';\r\nimport  {GlobalErrorHandlerService} from './global-error-handler.service';\r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n  ],\r\n  providers: &#91;\r\n    { provide: ErrorHandler, useClass: GlobalErrorHandlerService },\r\n  ],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<p>Run the app and you will see that the our custom error handler gets invoked, when you click on the button throw error.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2019/01/Global-Error-Handling-in-Angular.gif\" alt=\"\" class=\"wp-image-11446\"/></figure>\n\n\n\n<h2>Best Practices in Handling Errors</h2>\n\n\n\n<p>Now, we learned how to handle errors, here are a few things you should keep in mind while designing an Error Handler service.</p>\n\n\n\n<ol><li>Use a try.. catch block to handle the known errors. Handle it accordingly. If you are not able to handle it, then re-throw it.</li><li>Use a global error handler to trap all unhandled errors and show a notification to the user.</li><li>The ErrorHandler does not trap HTTP Errors, You need to Use HTTP Interceptors to handle HTTP Errors. You can refer to this article how to handle HTTP Errors in Angular.</li><li>Check for type of error in the error handler and act accordingly.<ul><li>For Example, if is an error from the back end (HTTP Error) you can use the HTTP Status Code to take necessary action.</li><li>401 Unauthorized error you can redirect the user to the login page.</li><li>500 Internal Server Error you can ask the user to retry after some time while sending a notification to the server administrator e</li></ul></li><li>For all other unhandled errors, log the errors back to the back end server ( or to any third party error providers). You can then look at those logs and make necessary changes to the app.</li></ol>\n\n\n\n<h2>Tips for Error Handler</h2>\n\n\n\n<h3>Injecting other services to the global error handler</h3>\n\n\n\n<p>The Angular creates the error handler service before the providers. Otherwise, it won’t be able catch errors that occur very early in the application. It also means that the angular providers won’t be available to the&nbsp;<code>ErrorHandler</code>.</p>\n\n\n\n<p>What if we wanted to use another service in the error handler. Then, we need to use the <code>Injector</code> instance to directly to inject the dependency and not depend on the Dependency injection framework</p>\n\n\n\n<p>To do that first we need to import the&nbsp;<code>injector</code></p>\n\n\n\n<p>Then we need to inject the injector to the&nbsp;<code>GlobalErrorHandlerService</code>.</p>\n\n\n\n<p>Finally, use the&nbsp;<code>injector</code>&nbsp;to get the instance of any required service.</p>\n\n\n\n<p>The following example service uses the <code>injector</code> to get the Router Service.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { ErrorHandler, Injectable, Injector} from '@angular/core';\r\nimport { Router } from '@angular/router';\r\n \r\n@Injectable()\r\nexport class GlobalErrorHandlerService implements ErrorHandler {\r\n \r\n    constructor(private injector: Injector) {\r\n    }\r\n \r\n    handleError(error) {\r\n \r\n        let router = this.injector.get(Router);\r\n        console.log('URL: ' + router.url);\r\n        console.error('An error occurred:', error.message);\r\n       \r\n       alert(error);\r\n   }\r\n}</code></pre>\n\n\n\n<h3>User Notification Page</h3>\n\n\n\n<p>It is a good design practice to notify the user regarding the error by using the error page.</p>\n\n\n\n<p><strong>error.component .ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { Component } from '@angular/core';\r\n \r\n@Component({\r\n  template: `\r\n     &lt;h2>An unknown error occurred.&lt;/h2>\r\n  `\r\n})\r\nexport class ErrorComponent {\r\n} \r\n </code></pre>\n\n\n\n<p>Do not forget to add it in the routing Module.</p>\n\n\n\n<p><strong>app-routing.module.ts</strong></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { NgModule } from '@angular/core';\r\nimport { Routes, RouterModule } from '@angular/router';\r\nimport { ErrorComponent } from './error.component ';\r\n \r\nconst routes: Routes = &#91;\r\n  {path: 'error', component: ErrorComponent }\r\n]\r\n \r\n@NgModule({\r\n  imports: &#91;RouterModule.forRoot(routes)],\r\n  exports: &#91;RouterModule],\r\n  providers: &#91;]\r\n})\r\nexport class AppRoutingModule { }\r\n </code></pre>\n\n\n\n<p>And in the <code>GlobalErrorHandlerService</code>, inject <code>router</code> and use <code>router.navigate(['/error'])</code> to go to the custom error page</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { ErrorHandler, Injectable, Injector} from '@angular/core';\r\nimport { Router } from '@angular/router';\r\n \r\n@Injectable()\r\nexport class GlobalErrorHandlerService implements ErrorHandler {\r\n \r\n    constructor(private injector: Injector) {    }\r\n \r\n    handleError(error) {\r\n \r\n        let router = this.injector.get(Router);\r\n        console.log('URL: ' + router.url);\r\n        console.error(error);\r\n       \r\n        router.navigate(&#91;'/error']);\r\n   }\r\n \r\n}</code></pre>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>Why Handle Errors Handling error is an important part of the application design. The JavaScript can throws errors each time something goes wrong. For Example, the Javascipt throws errors in the following conditions When we reference a non-existent variable. The value provided is not in the range of allowed values. When Interpreting syntactically invalid code When a [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [141],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3904" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3904"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3904/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3905,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3904/revisions/3905"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3904"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3904"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3904"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  },
  {
    "id": 3906,
    "date": "2020-12-10T11:37:50",
    "date_gmt": "2020-12-10T11:37:50",
    "guid": { "rendered": "http://angular.foobrdigital.com/?p=3906" },
    "modified": "2020-12-10T11:37:50",
    "modified_gmt": "2020-12-10T11:37:50",
    "slug": "angular-http-error-handling",
    "status": "publish",
    "type": "post",
    "link": "https://angular.foobrdigital.com/angular-http-error-handling/",
    "title": { "rendered": "Angular HTTP Error Handling" },
    "content": {
      "rendered": "\n<h2>HttpErrorResponse</h2>\n\n\n\n<p>The&nbsp;<code>HttpClient</code>&nbsp;captures the errors and wraps it in the generic&nbsp;<code>HttpErrorResponse</code>, before passing it to our app. The&nbsp;<code>error</code>&nbsp;property of the&nbsp;<code>HttpErrorResponse</code>&nbsp;contains the underlying&nbsp;<code>error</code>&nbsp;object. It also provides additional context about the state of the HTTP layer when the error occurred.</p>\n\n\n\n<p>The HTTP errors fall into two categories. The back end server may generate the error and send the error response. Or the client-side code may fail to generate the request and throw the error (<code>ErrorEvent</code>&nbsp;objects).</p>\n\n\n\n<p>The server might reject the request for various reasons. Whenever it does it will return the <code>error response</code> with the HTTP Status Codes such as <code>Unauthorized</code> (401), <code>Forbidden</code> (403), <code>Not found</code> (404), <code>internal Server Error</code> (500), etc. The Angular assigns the <code>error response</code> to <code>error</code> property of the <code>HttpErrorResponse</code>.</p>\n\n\n\n<p>The client-side code can also generate the error. The error may be due to a network error or an error while executing the HTTP request or an exception thrown in an RxJS operator. These errors produce JavaScript <code>ErrorEvent</code> objects. The Angular assigns the <code>ErrorEvent</code> object to <code>error</code> property of the <code>HttpErrorResponse</code>.</p>\n\n\n\n<p>In both the cases, the generic&nbsp;<code>HttpErrorResponse</code>&nbsp;is returned by the HTTP Module. We will inspect the error property to find out the type of Error and handle accordingly.</p>\n\n\n\n<h2>Catching Errors in HTTP Request</h2>\n\n\n\n<p>We can catch the HTTP Errors at three different places.</p>\n\n\n\n<ol><li>Component</li><li>Service</li><li>Globally</li></ol>\n\n\n\n<h3>Catch Errors in Component</h3>\n\n\n\n<p>Refer to our tutorial on Angular HTTP Get Request. We created a <code>GitHubService</code>, where we made a <code>GET</code> request to the GitHub API to get the list of Repositories. The following is the <code>getRepos()</code> method from the service. We have intentionally changed the URL (<code>uersY</code>) so that it will result in an error.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>getRepos(userName: string): Observable&lt;any> {\r\n   return this.http.get(this.baseURL + 'usersY/' + userName + '/repos')\r\n}\r\n </code></pre>\n\n\n\n<p>We <code>subscribe</code> to the <code>httpClient.get</code> method in the component class</p>\n\n\n\n<pre class=\"wp-block-code\"><code>public getRepos() {\r\n    this.loading = true;\r\n    this.errorMessage = \"\";\r\n    this.githubService.getReposCatchError(this.userName)\r\n      .subscribe(\r\n        (response) => {                           //Next callback\r\n          console.log('response received')\r\n          this.repos = response;\r\n        },\r\n        (error) => {                              //Error callback\r\n          console.error('error caught in component')\r\n          this.errorMessage = error;\r\n          this.loading = false;\r\n    \r\n          //throw error;   //You can also throw the error to a global error handler\r\n        }\r\n      )\r\n  }\r\n </code></pre>\n\n\n\n<p>The <code>subscribe</code> method has three callback arguments.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n.subscribe(success, error, completed); \r\n </code></pre>\n\n\n\n<p>The observable invokes the first callback&nbsp;<code>success</code>, when the HTTP request successfully returns a response. The third call back&nbsp;<code>completed</code>&nbsp;is called when the observable finishes without any error.</p>\n\n\n\n<p>The second callback <code>error</code>, is invoked when the HTTP Request end in an error. We handle error here by figuring out the type of error and handle it accordingly. It gets the <code>error</code> object which is of type <code>HttpErrorResponse</code>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>    (error) => {                              //Error callback\r\n          console.error('error caught in component')\r\n          this.errorMessage = error;\r\n          this.loading = false;\r\n        }\r\n </code></pre>\n\n\n\n<h3>Catch Errors in Service</h3>\n\n\n\n<p>We can also catch errors in the service, which makes the HTTP Request using the <code>catchError</code> Operator as shown below. Once you handle the error, you can re-throw it back to the component for further handling.</p>\n\n\n\n<pre class=\"wp-block-code\"><code> getRepos(userName: string): Observable&lt;repos&#91;]> {\r\n    return this.http.get&lt;repos&#91;]>(this.baseURL + 'usersY/' + userName + '/repos')\r\n      .pipe(\r\n        catchError((err) => {\r\n          console.log('error caught in service')\r\n          console.error(err);\r\n \r\n          //Handle the error here\r\n \r\n          return throwError(err);    //Rethrow it back to component\r\n        })\r\n      )\r\n  }\r\n </code></pre>\n\n\n\n<h3>Catch error globally using HTTP Interceptor</h3>\n\n\n\n<p>The type of error we may encounter vary. But some of those errors are common to every HTTP request. For Example</p>\n\n\n\n<ol><li>You are unauthorized to access the API Service,</li><li>You are authorized, but forbidden to access a particular resource</li><li>The API End Point is invalid or does not exist</li><li>Network error</li><li>Server down</li></ol>\n\n\n\n<p>We can check all these errors in the service or in component, but our app may contain many such service or components. Checking for common errors in each and every method is inefficient and error-prone.</p>\n\n\n\n<p>The Right thing to do is to handle only the errors specific to this API call in this component/service and move all the common errors to one single place. This is where we use the HTTP Interceptor.</p>\n\n\n\n<p>The HTTP Interceptor is a service, which we create and register it globally at the root module using the Angular Providers. Once defined, it will intercept all the HTTP requests passing through the app. It intercepts when we make the HTTP request and also intercepts when the response arrives. This makes it an ideal place to catch all the common errors and handle it</p>\n\n\n\n<p>We create the Interceptor by creating a Global Service class, which implements the&nbsp;<code>HttpInterceptor</code>&nbsp;Interface. Then we will override the&nbsp;<code>intercept</code>&nbsp;method in that service.</p>\n\n\n\n<p>The following code shows a simple <code>GlobalHttpInterceptorService</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport {Injectable} from \"@angular/core\";\r\nimport {HttpEvent, HttpHandler, HttpInterceptor,HttpRequest,HttpResponse,HttpErrorResponse} from '@angular/common/http';\r\nimport {Observable, of, throwError} from \"rxjs\";\r\nimport {catchError, map} from 'rxjs/operators';\r\n \r\n@Injectable()\r\nexport class GlobalHttpInterceptorService implements HttpInterceptor {\r\n    \r\n  constructor(public router: Router) {\r\n  }\r\n \r\n  intercept(req: HttpRequest&lt;any>, next: HttpHandler): Observable&lt;HttpEvent&lt;any>> {\r\n \r\n    return next.handle(req).pipe(\r\n      catchError((error) => {\r\n        console.log('error is intercept')\r\n        console.error(error);\r\n        return throwError(error.message);\r\n      })\r\n    )\r\n  }\r\n}</code></pre>\n\n\n\n<p>The caching of the Error is done using the&nbsp;<code>catchError</code>&nbsp;RxJS operator. We then re-throw it to the subscriber using the&nbsp;<code>throwError</code></p>\n\n\n\n<p>The&nbsp;<code>catchError</code>&nbsp;is added to the request pipeline using the RxJs&nbsp;<code>pipe</code>&nbsp;operator . When the error occurs in the HTTP Request it is intercepted and invokes the&nbsp;<code>catchError</code>. Inside the&nbsp;<code>catchError</code>&nbsp;you can handle the error and then use&nbsp;<code>throwError</code>&nbsp;to throw it to the service.</p>\n\n\n\n<p>We then register the Interceptor in the Providers array of the root module using the injection token <code>HTTP_INTERCEPTORS</code>. Note that you can provide more than one Interceptor <code>(multi: true)</code>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>providers: &#91;\r\n    GitHubService,\r\n    { provide: HTTP_INTERCEPTORS, useClass: GlobalHttpInterceptorService, multi: true  }\r\n]</code></pre>\n\n\n\n<h2>HTTP Error Handling</h2>\n\n\n\n<p>Next, step is what to do with the errors</p>\n\n\n\n<p>The server-side errors return status codes, we can take appropriate actions based on that. For Example for Status code 401&nbsp;<code>Unauthorized</code>,&nbsp;we&nbsp;can redirect the user to the login page, for 408 Request Timeout, we can retry the operation, etc.</p>\n\n\n\n<p>The following example code shows how to check for status codes 401 &amp; 403 and redirect to the login page.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>if (error instanceof HttpErrorResponse) {\r\n    if (error.error instanceof ErrorEvent) {\r\n        console.error(\"Error Event\");\r\n    } else {\r\n        console.log(`error status : ${error.status} ${error.statusText}`);\r\n        switch (error.status) {\r\n            case 401:      //login\r\n                this.router.navigateByUrl(\"/login\");\r\n                break;\r\n            case 403:     //forbidden\r\n                this.router.navigateByUrl(\"/unauthorized\");\r\n                break;\r\n        }\r\n    } \r\n} else {\r\n    console.error(\"some thing else happened\");\r\n}\r\nreturn throwError(error);</code></pre>\n\n\n\n<p>For Server errors with status codes&nbsp;<em>5XX</em>, you can simply ask the user to retry the operation. You can do this by showing an alert box or redirect him to a special page or show the error message at the top of the page bypassing the error message to a special service AlertService.</p>\n\n\n\n<p>For other errors, you can simply re-throw it back to the service.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>return throwError(error);</code></pre>\n\n\n\n<p>You can further handle the error in service or throw it back to the component.</p>\n\n\n\n<p>The component must display the error message to the user. You can also throw it back to a global error handler in Angular.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\n.subscribe(\r\n   (response) => {\r\n      this.repos = response;\r\n   },\r\n   (error) => {\r\n      //Handle the error here\r\n      //If not handled, then throw it\r\n      throw error; \r\n   }\r\n)</code></pre>\n\n\n\n<h2>HTTP Error handling example</h2>\n\n\n\n<p>The complete code of this example</p>\n\n\n\n<p><code>app.component.html</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;h1 class=\"heading\">&lt;strong>Angular HTTP&lt;/strong>Error Example&lt;/h1>\r\n \r\n&lt;div class=\"form-group\">\r\n  &lt;label for=\"userName\">GitHub User Name&lt;/label>\r\n  &lt;input type=\"text\" class=\"form-control\" name=\"userName\" &#91;(ngModel)]=\"userName\">\r\n&lt;/div>\r\n \r\n&lt;div class=\"form-group\">\r\n  &lt;button type=\"button\" (click)=\"getRepos()\">Get Repos&lt;/button>\r\n&lt;/div>\r\n \r\n&lt;div *ngIf=\"loading\">loading...&lt;/div>\r\n \r\n&lt;div *ngIf=\"errorMessage\" class=\"alert alert-warning\">\r\n  &lt;strong>Warning!&lt;/strong> {{errorMessage | json}}\r\n&lt;/div>\r\n \r\n&lt;table class='table'>\r\n  &lt;thead>\r\n    &lt;tr>\r\n      &lt;th>ID&lt;/th>\r\n      &lt;th>Name&lt;/th>\r\n      &lt;th>HTML Url&lt;/th>\r\n      &lt;th>description&lt;/th>\r\n    &lt;/tr>\r\n  &lt;/thead>\r\n  &lt;tbody>\r\n    &lt;tr *ngFor=\"let repo of repos;\">\r\n      &lt;td>{{repo.id}}&lt;/td>\r\n      &lt;td>{{repo.name}}&lt;/td>\r\n      &lt;td>{{repo.html_url}}&lt;/td>\r\n      &lt;td>{{repo.description}}&lt;/td>\r\n    &lt;/tr>\r\n  &lt;/tbody>\r\n&lt;/table> -\r\n \r\n&lt;pre>{{repos | json}}&lt;/pre></code></pre>\n\n\n\n<p><code>app.component.ts</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Component } from '@angular/core';\r\n \r\nimport { GitHubService } from './github.service';\r\nimport { repos } from './repos';\r\n \r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n})\r\nexport class AppComponent {\r\n  userName: string = \"tektutorialshub\"\r\n  repos: repos&#91;];\r\n \r\n  loading: boolean = false;\r\n  errorMessage;\r\n \r\n  constructor(private githubService: GitHubService) {\r\n  }\r\n \r\n  public getRepos() {\r\n    this.loading = true;\r\n    this.errorMessage = \"\";\r\n    this.githubService.getReposCatchError(this.userName)\r\n      .subscribe(\r\n        (response) => {                           //Next callback\r\n          console.log('response received')\r\n          this.repos = response;\r\n        },\r\n        (error) => {                              //Error callback\r\n          console.error('error caught in component')\r\n          this.errorMessage = error;\r\n          this.loading = false;\r\n \r\n          throw error;\r\n        }\r\n      )\r\n  }\r\n}</code></pre>\n\n\n\n<p>github.service.ts</p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { Injectable } from '@angular/core';\r\n \r\nimport { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\nimport { map, catchError } from 'rxjs/operators';\r\n \r\nimport { repos } from './repos';\r\n \r\n@Injectable( {providedIn:'root'})\r\nexport class GitHubService {\r\n \r\n  baseURL: string = \"https://api.github.com/\";\r\n \r\n  constructor(private http: HttpClient) {\r\n  }\r\n \r\n  //Any Data Type\r\n  getRepos(userName: string): Observable&lt;any> {\r\n    return this.http.get(this.baseURL + 'usersY/' + userName + '/repos')\r\n  }\r\n \r\n \r\n  //With catchError\r\n  getReposCatchError(userName: string): Observable&lt;repos&#91;]> {\r\n    return this.http.get&lt;repos&#91;]>(this.baseURL + 'usersY/' + userName + '/repos')\r\n      .pipe(\r\n        catchError((err) => {\r\n          console.log('error caught in service')\r\n          console.error(err);\r\n          return throwError(err);\r\n        })\r\n      )\r\n  }\r\n \r\n}</code></pre>\n\n\n\n<p><code>global-http-Interceptor.service.ts</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { Injectable } from \"@angular/core\";\r\nimport { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpErrorResponse } from '@angular/common/http';\r\nimport { Observable, of, throwError } from \"rxjs\";\r\nimport { catchError, map } from 'rxjs/operators';\r\nimport { Router } from '@angular/router';\r\n \r\n@Injectable()\r\nexport class GlobalHttpInterceptorService implements HttpInterceptor {\r\n \r\n  constructor(public router: Router) {\r\n  }\r\n \r\n  //1.  No Errors\r\n  intercept1(req: HttpRequest&lt;any>, next: HttpHandler): Observable&lt;HttpEvent&lt;any>> {\r\n \r\n    return next.handle(req).pipe(\r\n      catchError((error) => {\r\n        console.log('error in intercept')\r\n        console.error(error);\r\n        return throwError(error.message);\r\n      })\r\n    )\r\n  }\r\n \r\n  //2. Sending an Invalid Token will generate error\r\n  intercept(req: HttpRequest&lt;any>, next: HttpHandler): Observable&lt;HttpEvent&lt;any>> {\r\n \r\n    const token: string = 'invald token';\r\n    req = req.clone({ headers: req.headers.set('Authorization', 'Bearer ' + token) });\r\n \r\n    return next.handle(req).pipe(\r\n      catchError((error) => {\r\n        console.log('error in intercept')\r\n        console.error(error);\r\n        return throwError(error.message);\r\n      })\r\n    )\r\n  }\r\n \r\n  intercept3(req: HttpRequest&lt;any>, next: HttpHandler): Observable&lt;HttpEvent&lt;any>> {\r\n \r\n    const token: string = 'invald token';\r\n    req = req.clone({ headers: req.headers.set('Authorization', 'Bearer ' + token) });\r\n \r\n    return next.handle(req).pipe(\r\n      catchError((error) => {\r\n \r\n        let handled: boolean = false;\r\n        console.error(error);\r\n        if (error instanceof HttpErrorResponse) {\r\n          if (error.error instanceof ErrorEvent) {\r\n            console.error(\"Error Event\");\r\n          } else {\r\n            console.log(`error status : ${error.status} ${error.statusText}`);\r\n            switch (error.status) {\r\n              case 401:      //login\r\n                this.router.navigateByUrl(\"/login\");\r\n                console.log(`redirect to login`);\r\n                handled = true;\r\n                break;\r\n              case 403:     //forbidden\r\n                this.router.navigateByUrl(\"/login\");\r\n                console.log(`redirect to login`);\r\n                handled = true;\r\n                break;\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          console.error(\"Other Errors\");\r\n        }\r\n \r\n        if (handled) {\r\n          console.log('return back ');\r\n          return of(error);\r\n        } else {\r\n          console.log('throw error back to to the subscriber');\r\n          return throwError(error);\r\n        }\r\n \r\n      })\r\n    )\r\n  }\r\n}</code></pre>\n\n\n\n<p><code>global-error-handler.service.ts</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code> \r\nimport { ErrorHandler, Injectable, Injector } from '@angular/core';\r\nimport { HttpErrorResponse } from '@angular/common/http';\r\nimport { throwError } from 'rxjs';\r\n \r\n@Injectable()\r\nexport class GlobalErrorHandlerService implements ErrorHandler {\r\n \r\n  constructor() {\r\n  }\r\n \r\n \r\n  handleError(error: Error | HttpErrorResponse) {\r\n    console.log('GlobalErrorHandlerService')\r\n    console.error(error);\r\n  }\r\n \r\n}</code></pre>\n\n\n\n<p><code>app.module.ts</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule ,ErrorHandler } from '@angular/core';\r\nimport { HttpClientModule,HTTP_INTERCEPTORS} from '@angular/common/http';\r\nimport { FormsModule } from '@angular/forms';\r\n \r\nimport { AppComponent } from './app.component';\r\n \r\nimport { GlobalHttpInterceptorService} from './global-http-Interceptor.service';\r\nimport { AppRoutingModule } from './app-routing.module';\r\nimport { GlobalErrorHandlerService } from './global-error-handler.service';\r\n \r\n \r\n \r\n@NgModule({\r\n  declarations: &#91;\r\n    AppComponent\r\n  ],\r\n  imports: &#91;\r\n    BrowserModule,\r\n    HttpClientModule,\r\n    FormsModule,\r\n    AppRoutingModule\r\n  ],\r\n  providers: &#91;\r\n    { provide: HTTP_INTERCEPTORS,    useClass: GlobalHttpInterceptorService,    multi: true  },\r\n    { provide: ErrorHandler, useClass:GlobalErrorHandlerService}\r\n],\r\n  bootstrap: &#91;AppComponent]\r\n})\r\nexport class AppModule { }</code></pre>\n\n\n\n<p><code>app-routing.module.ts</code></p>\n\n\n\n<pre class=\"wp-block-code\"><code>\r\nimport { NgModule } from '@angular/core';\r\nimport { Routes, RouterModule } from '@angular/router';\r\n \r\n \r\nconst routes: Routes = &#91;];\r\n \r\n@NgModule({\r\n  imports: &#91;RouterModule.forRoot(routes)],\r\n  exports: &#91;RouterModule]\r\n})\r\nexport class AppRoutingModule { }\r\n \r\n </code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tektutorialshub.com/wp-content/uploads/2020/03/Angular-HTTP-Error-Handling-Example.png\" alt=\"Angular HTTP Error Handling Example\" class=\"wp-image-16820\"/></figure>\n",
      "protected": false
    },
    "excerpt": {
      "rendered": "<p>HttpErrorResponse The&nbsp;HttpClient&nbsp;captures the errors and wraps it in the generic&nbsp;HttpErrorResponse, before passing it to our app. The&nbsp;error&nbsp;property of the&nbsp;HttpErrorResponse&nbsp;contains the underlying&nbsp;error&nbsp;object. It also provides additional context about the state of the HTTP layer when the error occurred. The HTTP errors fall into two categories. The back end server may generate the error and send the [&hellip;]</p>\n",
      "protected": false
    },
    "author": 2,
    "featured_media": 0,
    "comment_status": "open",
    "ping_status": "open",
    "sticky": false,
    "template": "",
    "format": "standard",
    "meta": [],
    "categories": [141],
    "tags": [],
    "_links": {
      "self": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3906" }
      ],
      "collection": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts" }
      ],
      "about": [
        { "href": "https://angular.foobrdigital.com/wp-json/wp/v2/types/post" }
      ],
      "author": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/users/2"
        }
      ],
      "replies": [
        {
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=3906"
        }
      ],
      "version-history": [
        {
          "count": 1,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3906/revisions"
        }
      ],
      "predecessor-version": [
        {
          "id": 3907,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/posts/3906/revisions/3907"
        }
      ],
      "wp:attachment": [
        {
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=3906"
        }
      ],
      "wp:term": [
        {
          "taxonomy": "category",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=3906"
        },
        {
          "taxonomy": "post_tag",
          "embeddable": true,
          "href": "https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=3906"
        }
      ],
      "curies": [
        { "name": "wp", "href": "https://api.w.org/{rel}", "templated": true }
      ]
    }
  }
]
